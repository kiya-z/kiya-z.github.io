<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Android 逆向技巧总结]]></title>
      <url>/2333/03/03/android-reversing-skills/</url>
      <content type="html"><![CDATA[<p>以代表性的 crackme 为例总结相关知识点。一緒に頑張りましょう！github 仓库<a href="https://github.com/kiya-z/android-reversing-challenges" target="_blank" rel="external">在此</a>。<br><a id="more"></a></p>
<h1 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h1><table>
<thead>
<tr>
<th>name</th>
<th>How to get</th>
</tr>
</thead>
<tbody>
<tr>
<td>jadx</td>
<td><a href="https://github.com/skylot/jadx/releases" target="_blank" rel="external">https://github.com/skylot/jadx/releases</a></td>
</tr>
<tr>
<td>jeb</td>
<td><a href="https://down.52pojie.cn/Tools/Android_Tools/" target="_blank" rel="external">https://down.52pojie.cn/Tools/Android_Tools/</a></td>
</tr>
<tr>
<td>Ida</td>
<td><a href="https://down.52pojie.cn/Tools/Disassemblers/" target="_blank" rel="external">https://down.52pojie.cn/Tools/Disassemblers/</a></td>
</tr>
<tr>
<td>ARM ⇌ Hex</td>
<td><a href="http://armconverter.com/" target="_blank" rel="external">http://armconverter.com/</a></td>
</tr>
<tr>
<td>010 Editor</td>
<td><a href="https://down.52pojie.cn/Tools/Editors/" target="_blank" rel="external">https://down.52pojie.cn/Tools/Editors/</a></td>
</tr>
<tr>
<td>010 templates</td>
<td><a href="http://www.sweetscape.com/010editor/templates/" target="_blank" rel="external">http://www.sweetscape.com/010editor/templates/</a></td>
</tr>
<tr>
<td>aapt</td>
<td>in sdk build-tools</td>
</tr>
<tr>
<td>Google signapk</td>
<td><a href="https://github.com/kiya-z/Android/tree/master/tools/signapk" target="_blank" rel="external">https://github.com/kiya-z/Android/tree/master/tools/signapk</a></td>
</tr>
<tr>
<td>Android Device Monitor</td>
<td>in sdk tools</td>
</tr>
<tr>
<td>gdb</td>
<td>in ndk toolchains (ndk &lt;= r10)</td>
</tr>
<tr>
<td>gdbserver</td>
<td>in ndk prebuilt (ndk &lt;= r10)</td>
</tr>
<tr>
<td>Android Studio</td>
<td><a href="https://developer.android.com/studio" target="_blank" rel="external">https://developer.android.com/studio</a></td>
</tr>
<tr>
<td>ShakaApktool</td>
<td><a href="https://github.com/rover12421/ShakaApktool" target="_blank" rel="external">https://github.com/rover12421/ShakaApktool</a></td>
</tr>
<tr>
<td>smalidea</td>
<td><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="external">https://bitbucket.org/JesusFreke/smali/downloads/</a></td>
</tr>
<tr>
<td>smali</td>
<td><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="external">https://bitbucket.org/JesusFreke/smali/downloads/</a></td>
</tr>
<tr>
<td>baksmali</td>
<td><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="external">https://bitbucket.org/JesusFreke/smali/downloads/</a></td>
</tr>
<tr>
<td>axmlprinter</td>
<td><a href="https://github.com/rednaga/axmlprinter/releases" target="_blank" rel="external">https://github.com/rednaga/axmlprinter/releases</a></td>
</tr>
<tr>
<td>unluac</td>
<td><a href="https://sourceforge.net/projects/unluac/" target="_blank" rel="external">https://sourceforge.net/projects/unluac/</a></td>
</tr>
<tr>
<td>sqlcipher</td>
<td><a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="external">https://github.com/sqlcipher/sqlcipher</a></td>
</tr>
<tr>
<td>android-backup-extractor</td>
<td><a href="https://github.com/nelenkov/android-backup-extractor" target="_blank" rel="external">https://github.com/nelenkov/android-backup-extractor</a></td>
</tr>
</tbody>
</table>
<h1 id="JNI-Onload-中通过-RegisterNatives-动态注册-jni-函数"><a href="#JNI-Onload-中通过-RegisterNatives-动态注册-jni-函数" class="headerlink" title="JNI_Onload 中通过 RegisterNatives 动态注册 jni 函数"></a>JNI_Onload 中通过 RegisterNatives 动态注册 jni 函数</h1><p><strong>相关函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">signed int __fastcall JNI_OnLoad(_JavaVM *a1)</div><div class="line"></div><div class="line">((int (__fastcall *)(_JavaVM *, _JNIEnv **, signed int))v1-&gt;functions-&gt;GetEnv)(v1, &amp;v8, 65540)  </div><div class="line">    /*  v1:JavaVM  v8:JniEnv  65540:jni version */</div><div class="line"></div><div class="line">((int (__fastcall *)(_JNIEnv *, char *))v3-&gt;functions-&gt;FindClass)(v3, v4)   </div><div class="line">    /*  v3:JNIEnv  v4:类名    */</div><div class="line"></div><div class="line">((int (__fastcall *)(_JNIEnv *, int, char **, signed int))v3-&gt;functions-&gt;RegisterNatives)(v3, v5, off_400C, 2)</div><div class="line">    /*  v3:JniEnv  v5:FindClass得到的jclass对象  off_400C:要注册的methods  2:注册的methods个数</div><div class="line">        method的格式为：函数名 函数描述(smali格式) 函数指针</div><div class="line">        例如(in ida)：</div><div class="line">            DCD aHello              ; &quot;hello&quot;</div><div class="line">            DCD aLjavaLangStr_1     ; &quot;()Ljava/lang/String;&quot;</div><div class="line">            DCD native_hello+1</div><div class="line">    */</div></pre></td></tr></table></figure>
<p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/mobicrackNDK.apk" target="_blank" rel="external">mobicrackNDK.apk</a></p>
<h1 id="init-array"><a href="#init-array" class="headerlink" title=".init_array"></a>.init_array</h1><p>根据 linker 源码, section 的执行顺序为 <code>.preinit_array</code> -&gt; <code>.init</code> -&gt; <code>.init_array</code> 。但 so 是不会执行 <code>.preinit_array</code> 的, 可以忽略。</p>
<p><code>.init_array</code> 是一个函数指针数组。编写代码时在函数声明时加上 <code>__attribute__((constructor))</code> 使之成为共享构造函数，即可使该函数出现在 <code>.init_array</code> section 中。</p>
<p>IDA 动态调试时 ‘ctrl+s’ 查看 section 信息即可定位这两个 setction，特别的，对于 <code>.init_array</code>，可通过搜索 <code>Calling %s @ %p for &#39;%s&#39;</code> 定位。</p>
<p><strong>部分源码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void soinfo::CallConstructors() &#123;</div><div class="line">    ...</div><div class="line">    // DT_INIT should be called before DT_INIT_ARRAY if both are present.</div><div class="line">    CallFunction(&quot;DT_INIT&quot;, init_func);</div><div class="line">    CallArray(&quot;DT_INIT_ARRAY&quot;, init_array, init_array_count, false);    // CallArray 中也会调用 CallFunction 函数</div><div class="line">&#125;</div><div class="line"></div><div class="line">void soinfo::CallFunction(const char* function_name UNUSED, linker_function_t function) &#123;</div><div class="line">  if (function == NULL || reinterpret_cast&lt;uintptr_t&gt;(function) == static_cast&lt;uintptr_t&gt;(-1)) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  TRACE(&quot;[ Calling %s @ %p for &apos;%s&apos; ]&quot;, function_name, function, name);</div><div class="line">  function();</div><div class="line">  TRACE(&quot;[ Done calling %s @ %p for &apos;%s&apos; ]&quot;, function_name, function, name);</div><div class="line"></div><div class="line">  // The function may have called dlopen(3) or dlclose(3), so we need to ensure our data structures</div><div class="line">  // are still writable. This happens with our debug malloc (see http://b/7941716).</div><div class="line">  set_soinfo_pool_protection(PROT_READ | PROT_WRITE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/mobicrackNDK.apk" target="_blank" rel="external">mobicrackNDK.apk</a></p>
<h1 id="dex-结构"><a href="#dex-结构" class="headerlink" title="dex 结构"></a>dex 结构</h1><h2 id="修复-dexHeader-amp-onCreate"><a href="#修复-dexHeader-amp-onCreate" class="headerlink" title="修复 dexHeader &amp; onCreate"></a>修复 dexHeader &amp; onCreate</h2><p>快速简记：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>单位结构体占字节</th>
<th>共计字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>DexHeader</td>
<td>-</td>
<td>0x70h</td>
</tr>
<tr>
<td>String Table</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>Type Table</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>Proto Table</td>
<td>12</td>
<td>-</td>
</tr>
<tr>
<td>Field Table</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td>Method Table</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td>Class Def Table</td>
<td>32</td>
<td>-</td>
</tr>
<tr>
<td>Data Section(含Map Section)</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/misc.apk" target="_blank" rel="external">misc.apk</a></p>
<h1 id="hook-系统函数"><a href="#hook-系统函数" class="headerlink" title="hook 系统函数"></a>hook 系统函数</h1><p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/EasyRe.apk" target="_blank" rel="external">EasyRe.apk</a></p>
<h1 id="dump-内存搜索-flag"><a href="#dump-内存搜索-flag" class="headerlink" title="dump 内存搜索 flag"></a>dump 内存搜索 flag</h1><h2 id="1-利用-ddms-的-dump-HPROF-file-功能-带箭头的油桶图标"><a href="#1-利用-ddms-的-dump-HPROF-file-功能-带箭头的油桶图标" class="headerlink" title="1. 利用 ddms 的 dump HPROF file 功能 (带箭头的油桶图标)"></a>1. 利用 ddms 的 <code>dump HPROF file</code> 功能 (带箭头的油桶图标)</h2><p>搜索：<code>strings easyre.sjl.gossip.easyre.hprof | grep 0ctf</code></p>
<h2 id="2-利用-gore"><a href="#2-利用-gore" class="headerlink" title="2. 利用 gore"></a>2. 利用 gore</h2><p>gdb 附加进程后直接执行 <code>gcore</code> dump，搜索：<code>strings core.7967 | grep 0ctf</code></p>
<p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/EasyRe.apk" target="_blank" rel="external">EasyRe.apk</a></p>
<h1 id="修改-smali-代码"><a href="#修改-smali-代码" class="headerlink" title="修改 smali 代码"></a>修改 smali 代码</h1><p>指令参考这里👉<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode" target="_blank" rel="external">dalvik bytecode</a></p>
<p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/Timer.apk" target="_blank" rel="external">Timer.apk</a></p>
<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><h2 id="ARM-的参数传递规则"><a href="#ARM-的参数传递规则" class="headerlink" title="ARM 的参数传递规则"></a>ARM 的参数传递规则</h2><p>R0、R1、R2、R3， 在调用函数时，用来存放前4个函数参数；如果函数的参数多于 4 个，则多余参数存放在堆栈当中；<br>低于32位的函数返回值存于 R0。</p>
<h2 id="ARM-的寄存器规则"><a href="#ARM-的寄存器规则" class="headerlink" title="ARM 的寄存器规则"></a>ARM 的寄存器规则</h2><table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0 ~ R3</td>
<td>调用函数时，用来存放前4个函数参数</td>
</tr>
<tr>
<td>R0</td>
<td>函数返回时，存放低于32位的函数返回值</td>
</tr>
<tr>
<td>R4 ~ R11</td>
<td>保存局部变量。进入函数时必须保存所用到的局部变量寄存器的值，在返回前必须恢复这些寄存器的值；对于函数中没有用到的寄存器则不必进行这些操作。<br>在Thumb中，通常只能使用寄存器 R4~R7来保存局部变量，<br>所以函数内部通用的入栈出栈代码可以为：<br>STMFD sp!,{r4-r11,lr}<br>// body of ASM code<br>LDMFD sp!,{r4-r11,pc}</td>
</tr>
<tr>
<td>R12</td>
<td>用作 IP，内部调用暂时寄存器</td>
</tr>
<tr>
<td>R13</td>
<td>用作 SP，栈指针，sp 中存放的值在退出被调用函数时必须与进入时的值相同。</td>
</tr>
<tr>
<td>R14</td>
<td>用作 LR，链接寄存器，保存函数的返回地址；如果在函数中保存了返回地址，寄存器R14 则可以用作其他用途</td>
</tr>
<tr>
<td>R15</td>
<td>用作 PC，程序计数器</td>
</tr>
<tr>
<td>R16</td>
<td>CPSR，状态寄存器</td>
</tr>
</tbody>
</table>
<p><strong>例：</strong><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/LoopAndLoop.apk" target="_blank" rel="external">LoopAndLoop.apk</a></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://github.com/toToCW/CTF-Mobile" target="_blank" rel="external">CTF-Mobile</a></p>
<p><a href="https://github.com/ctfs/write-ups-2015" target="_blank" rel="external">write-ups-2015</a></p>
]]></content>
      
        
        <tags>
            
            <tag> reversing </tag>
            
            <tag> CTF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gdb 调试 Android app]]></title>
      <url>/2017/06/21/android-gdb/</url>
      <content type="html"><![CDATA[<p>Android NDK 在 r11 之后去掉了 toolchain 中的 gdb 工具，无奈下载了 r10 的 arm-linux-androideabi-gdb 和 gdbserver。<a id="more"></a></p>
<p>把  arm-linux-androideabi-gdb 放在 ndk 的 <code>toolchains/arm-linux-androideabi-4.9/prebuilt/*platform*-x86_64/bin</code> 目录下，把 <code>gdbserver</code> push 到手机的 <code>system/bin</code> 下并添加执行权限。</p>
<blockquote>
<p>本次测试用 crackme 来自 0CTF 2015 Quals : <a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/simple.apk" target="_blank" rel="external">simple.apk</a></p>
</blockquote>
<p>在手机上打开 app 并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ps | grep easy</div><div class="line">gdbserver :1234 --attach 7967   // 1234 为端口，可随意指定；7967为 pid。</div></pre></td></tr></table></figure>
<p>在电脑端执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb forward tcp:1234 tcp:1234</div><div class="line">arm-linux-androideabi-gdb</div><div class="line">(gdb) target remote :1234</div></pre></td></tr></table></figure>
<p>此时调试算是已经开始了。</p>
<p><strong>扩展</strong>：</p>
<p>为了找到该 crackme 的 flag，我们可以接着执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) gcore</div></pre></td></tr></table></figure>
<p>等 gore dump 出内存后，在电脑端的当前目录下使用<code>strings</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strings core.7967 | grep 0CTF</div></pre></td></tr></table></figure>
<p>即可得到 flag ，省去了静态分析和动态调试的繁琐。</p>
]]></content>
      
        
        <tags>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[翻译 - 多种特征检测 Frida]]></title>
      <url>/2017/05/08/detect-frida/</url>
      <content type="html"><![CDATA[<p>Frida 在逆向工程狮中很受欢迎，你基本可以在运行时访问到你能想到的任何东西，内存地址、native 函数、Java 实例对象等。在 OWASP 的移动测试指南里就提到了 Frida。<a id="more"></a>但是啊，每出来个好用的注入工具，都会有反注入、反反注入、反反反注入、反…注入。这篇文章要介绍的是 Android APP 检测 Frida 的方法。</p>
<h2 id="检查-Frida-的痕迹"><a href="#检查-Frida-的痕迹" class="headerlink" title="检查 Frida 的痕迹"></a>检查 Frida 的痕迹</h2><p>一种简易方法是检测 Frida 的运行痕迹，也适用于同类工具的检测，比如包文件、二进制文件、库文件、进程、临时文件等等。本例中针对的对象是 fridaserver，它通过 TCP 对外与 frida 通信，此时可以用 Java 遍历运行的进程列表从而检查 fridaserver 是否在运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public boolean checkRunningProcesses() &#123;</div><div class="line"></div><div class="line">  boolean returnValue = false;</div><div class="line"></div><div class="line">  // Get currently running application processes</div><div class="line">  List&lt;RunningServiceInfo&gt; list = manager.getRunningServices(300);</div><div class="line"></div><div class="line">  if(list != null)&#123;</div><div class="line">    String tempName;</div><div class="line">    for(int i=0;i&lt;list.size();++i)&#123;</div><div class="line">      tempName = list.get(i).process;</div><div class="line"></div><div class="line">      if(tempName.contains(&quot;fridaserver&quot;)) &#123;</div><div class="line">        returnValue = true;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return returnValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若 Frida 运行在默认配置时此法有效，若是遇到个笨拙的脚本小子，在第一步就能绊倒他。绕过也是相当简单，只需重命名 fridaserver，我们得找个更好的方法。</p>
<p>fridaserver 默认的 TCP 端口是 27047，可以检查这个端口是否开放。native 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">boolean is_frida_server_listening() &#123;</div><div class="line">    struct sockaddr_in sa;</div><div class="line"></div><div class="line">    memset(&amp;sa, 0, sizeof(sa));</div><div class="line">    sa.sin_family = AF_INET;</div><div class="line">    sa.sin_port = htons(27047);</div><div class="line">    inet_aton(&quot;127.0.0.1&quot;, &amp;(sa.sin_addr));</div><div class="line"></div><div class="line">    int sock = socket(AF_INET , SOCK_STREAM , 0);</div><div class="line"></div><div class="line">    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123;</div><div class="line">      /* Frida server detected. Do something… */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，这也得要求 fridaserver 是默认配置运行，命令行指定参数就可以改变它的监听端口，绕过也太不麻烦了。不过我们可以用’ nmap -sV’ 找到开放端口来改善这个方法。因为 fridaserver 使用 D-Bus 协议通信，我们为每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Mini-portscan to detect frida-server on any local port.</div><div class="line"> */</div><div class="line"></div><div class="line">for(i = 0 ; i &lt;= 65535 ; i++) &#123;</div><div class="line"></div><div class="line">    sock = socket(AF_INET , SOCK_STREAM , 0);</div><div class="line">    sa.sin_port = htons(i);</div><div class="line"></div><div class="line">    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123;</div><div class="line"></div><div class="line">        __android_log_print(ANDROID_LOG_VERBOSE, APPNAME,  &quot;FRIDA DETECTION [1]: Open Port: %d&quot;, i);</div><div class="line"></div><div class="line">        memset(res, 0 , 7);</div><div class="line"></div><div class="line">        // send a D-Bus AUTH message. Expected answer is “REJECT&quot;</div><div class="line"></div><div class="line">        send(sock, &quot;\x00&quot;, 1, NULL);</div><div class="line">        send(sock, &quot;AUTH\r\n&quot;, 6, NULL);</div><div class="line"></div><div class="line">        usleep(100);</div><div class="line"></div><div class="line">        if (ret = recv(sock, res, 6, MSG_DONTWAIT) != -1) &#123;</div><div class="line"></div><div class="line">            if (strcmp(res, &quot;REJECT&quot;) == 0) &#123;</div><div class="line">               /* Frida server detected. Do something… */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    close(sock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在好像有了个非常好用的方法了呢，但是还存在问题。Frida 提供不需要 fridaserver 运行的模式！怎么检测？！</p>
<p>Frida 的各个模式都是用来注入的，我们可以利用的点就是 frida 运行时映射到内存的库。最直接的是挨个检查加载的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">char line[512];</div><div class="line">FILE* fp;</div><div class="line"></div><div class="line">fp = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;);</div><div class="line"></div><div class="line">if (fp) &#123;</div><div class="line">    while (fgets(line, 512, fp)) &#123;</div><div class="line">        if (strstr(line, &quot;frida&quot;)) &#123;</div><div class="line">            /* Evil library is loaded. Do something… */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">       /* Error opening /proc/self/maps. If this happens, something is off. */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码检测名字含有“frida”的库，表明上有用，实际上：</p>
<ul>
<li><p>还记得为什么检测名字是“fridaserver”的方法为什么不可靠吧？这里也是一样，稍微改一下 frida 就能重命名代理库名。</p>
</li>
<li><p>这段代码依赖的是标准库的<code>fopen()</code>和<code>strstr()</code>函数，可笑的是，我们竟想用能被 frida 轻而易举就 hook 的函数来检测 frida ！</p>
</li>
</ul>
<p>问题1可以用经典的病毒扫描法解决，在内存中扫描 frida 的库特征 “gadgets”。我选择字符串 “LIBFRIDA”，它在所有 frida-gadget 和 frida-agent 的版本中都有出现。下面的代码扫描了在 <code>/proc/sel/maps</code> 里找到的所有的可执行段，为了简洁我放了部分代码，完整的在 <a href="https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/native-lib.cpp" target="_blank" rel="external">https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/native-lib.cpp</a> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static char keyword[] = &quot;LIBFRIDA&quot;;</div><div class="line">num_found = 0;</div><div class="line"></div><div class="line">int scan_executable_segments(char * map) &#123;</div><div class="line">    char buf[512];</div><div class="line">    unsigned long start, end;</div><div class="line"></div><div class="line">    sscanf(map, &quot;%lx-%lx %s&quot;, &amp;start, &amp;end, buf);</div><div class="line"></div><div class="line">    if (buf[2] == &apos;x&apos;) &#123;</div><div class="line">        return (find_mem_string(start, end, (char*)keyword, 8) == 1);</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void scan() &#123;</div><div class="line"></div><div class="line">    if ((fd = my_openat(AT_FDCWD, &quot;/proc/self/maps&quot;, O_RDONLY, 0)) &gt;= 0) &#123;</div><div class="line"></div><div class="line">    while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123;</div><div class="line">        if (scan_executable_segments(map) == 1) &#123;</div><div class="line">            num_found++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (num_found &gt; 1) &#123;</div><div class="line"></div><div class="line">        /* Frida Detected */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 <code>my_openat()</code> 等函数，它们并非平常的 libc 库函数，是自定义实现的，但是功能和 libc 中的一样，设置了系统调用的参数，执行了软中断。因为直接调用公共 API 并不可靠，这样不容易被 hook。完整的实现在 <a href="https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/syscall.S" target="_blank" rel="external">https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/syscall.S</a> 。下面是 my_openat 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &quot;bionic_asm.h&quot;</div><div class="line"></div><div class="line">.text</div><div class="line">    .globl my_openat</div><div class="line">    .type my_openat,function</div><div class="line">my_openat:</div><div class="line">    .cfi_startproc</div><div class="line">    mov ip, r7</div><div class="line">    .cfi_register r7, ip</div><div class="line">    ldr r7, =__NR_openat</div><div class="line">    swi #0</div><div class="line">    mov r7, ip</div><div class="line">    .cfi_restore r7</div><div class="line">    cmn r0, #(4095 + 1)</div><div class="line">    bxls lr</div><div class="line">    neg r0, r0</div><div class="line">    b __set_errno_internal</div><div class="line">    .cfi_endproc</div><div class="line"></div><div class="line">    .size my_openat, .-my_openat;</div></pre></td></tr></table></figure>
<p>到这里总算是有效的方法了，只用 frida 的话也不容易绕过，加了混淆更难。即使这样，依然有很多办法可以绕过，直接能想到的就是打补丁、hook 系统调用。但是记住，逆向工程永远胜利！</p>
<p>想要试验，可以在这里 <a href="https://github.com/b-mueller/frida-detection-demo/" target="_blank" rel="external">https://github.com/b-mueller/frida-detection-demo/</a> 下载 Android studio 工程。frida 注入时的运行结果如下：</p>
<p><img src="https://vp-web.s3.amazonaws.com/uploads/ckeditor/pictures/73/content_fridadetection.jpg" alt=""></p>
<hr>
<p>原文链接：<a href="http://www.vantagepoint.sg/blog/90-the-jiu-jitsu-of-detecting-frida" target="_blank" rel="external">http://www.vantagepoint.sg/blog/90-the-jiu-jitsu-of-detecting-frida</a></p>
<p>本文首发于<a href="http://bbs.pediy.com/thread-217482.htm" target="_blank" rel="external">看雪</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> translation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[翻译 - 用 VirtualBox 调试 macOS 内核]]></title>
      <url>/2017/04/14/debug-macos-kernel/</url>
      <content type="html"><![CDATA[<p><strong>重大更新</strong>：awalton 在 Hacker News 上的讨论中提到：VMWare 里可以设置 CPUID 标志来禁用 SMAP，只需要在 vmx 文件中加上cpuid.7.ebx = “———–0——————–”.<a id="more"></a></p>
<hr>
<p>上年，我给我的老 MBP 升级了2016年的 Skylake Intel 处理器。我在调试一个内核漏洞时，发现我的 VMWare 开启了“SMAP”(防止超级用户访问)机制。我找不到怎么关闭 SMAP，还好 VirtualBox 目前好像不支持 SMAP？</p>
<p>这篇文章会手把手教你如何用 VirtualBox 进行 macOS 内核的源码级调试。虽然这些步骤都是在 VirtualBox上进行的，但在 VMWare 上也是通用的，甚至更简单。</p>
<h1 id="安装-VirtualBox-和-Sierra"><a href="#安装-VirtualBox-和-Sierra" class="headerlink" title="安装 VirtualBox 和 Sierra"></a>安装 VirtualBox 和 Sierra</h1><p>如果你还没在 VirtualBox 上安装 macOS 镜像，你可以复用 VMWare 的 vmdk，也可以装个新的。重新安装系统需要 ISO 镜像，下面的命令可以将从<a href="https://itunes.apple.com/us/app/macos-sierra/id1127487414?ls=1&amp;mt=12" target="_blank" rel="external">Mac app store</a>下载的 Sierra 转成 ISO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ hdiutil attach /Applications/Install\ macOS\ Sierra.app/Contents/SharedSupport/InstallESD.dmg -noverify -nobrowse -mountpoint /Volumes/installesd</div><div class="line">$ hdiutil create -o /tmp/Sierra -size 8g -type SPARSE -layout SPUD -fs HFS+J</div><div class="line">$ hdiutil attach /tmp/Sierra.sparseimage -noverify -nobrowse -mountpoint /Volumes/install</div><div class="line">$ asr restore -source /Volumes/installesd/BaseSystem.dmg -target /Volumes/install -noprompt -noverify -erase</div><div class="line">$ rm /Volumes/OS\ X\ Base\ System/System/Installation/Packages</div><div class="line">$ cp -rp /Volumes/installesd/Packages /Volumes/OS\ X\ Base\ System/System/Installation/</div><div class="line">$ cp -rp /Volumes/installesd/BaseSystem.dmg /Volumes/OS\ X\ Base\ System/BaseSystem.dmg</div><div class="line">$ cp -rp /Volumes/installesd/BaseSystem.chunklist /Volumes/OS\ X\ Base\ System/BaseSystem.chunklist</div><div class="line">$ hdiutil detach /Volumes/installesd</div><div class="line">$ hdiutil detach /Volumes/OS\ X\ Base\ System/</div><div class="line">$ hdiutil resize -sectors min /tmp/Sierra.sparseimage</div><div class="line">$ hdiutil convert /tmp/Sierra.sparseimage -format UDTO -o /tmp/Sierra</div><div class="line">$ rm /tmp/Sierra.sparseimage</div><div class="line">$ mv /tmp/Sierra.cdr /tmp/Sierra.iso</div></pre></td></tr></table></figure>
<h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>如果你用了桥接，可以跳过这部分。</p>
<p>如果用的是 NAT，需要为 KDP 开启端口转发。点击“网络”，选择“高级” -&gt; “端口转发”，将 localhost 41139/UDP 转发到虚拟机的 41139/UDP，就能够访问到虚拟机的 41139 端口了。</p>
<h1 id="安装-XCode"><a href="#安装-XCode" class="headerlink" title="安装 XCode"></a>安装 XCode</h1><p>在你的主机上安装 XCode，通过 App store 安装最简单。 可以直接打开 XCode，也可以执行 <code>sudo xcodebuild -license accept</code> 接受 XCode license。</p>
<h1 id="安装内核调试组件-KDK"><a href="#安装内核调试组件-KDK" class="headerlink" title="安装内核调试组件(KDK)"></a>安装内核调试组件(KDK)</h1><p>根据我们要调试的 macOS 版本从 Apple 开发者中心安装 KDK ，这里我的是10.12 build 16A323.</p>
<p>KDK 的安装目录是<code>/Library/Developer/KDKs</code>，提供的内核版本、符号、内核扩展都有 RELEASE、DEVELOPMENT、DEBUG 三种版本。不同之处在于 DEVELOPMENT 和 DEBUG 版比 RELEASE 版多了些断言和错误检查，DEBUG 版的最丰富。</p>
<p>注意：被调试的系统不需要安装 KDK。</p>
<h1 id="修改-nvram-boot-args"><a href="#修改-nvram-boot-args" class="headerlink" title="修改 nvram boot-args"></a>修改 nvram boot-args</h1><p>为了能够调试虚拟机，需要设置虚拟机上 nvram 中的 debug 项。除了 debug 的值外其他值也能被我们所用。下面是一些因垂斯挺的选项：</p>
<ul>
<li>-v：以 verbose 模式启动系统。</li>
<li>kcsuffix：填写后缀以指定启动的内核。</li>
<li>pmuflags：貌似大家都推荐把这项值设为1。然而 Apple’s Kernel Programming Guide 已经明确指出管理电源的看门狗定时器“只在台式机、笔记本的 G4 版本和台式机的 G5 版本及之前有作用”，其他的看门狗定时器“只在 OS X Server 中启用”。所以，虽然设置了也不影响，但这个选项真没什么卵用。</li>
<li>debug：允许远程内核调试。 Apple docs 里有列出可用的标志。我常用的是<code>DB_LOG_PI_SCRN | DB_ARP | DB_NMI</code>。另外，<code>control + option + command + shift + escape</code> 可以触发不可屏蔽中断（NMI），继而引发调试器中断，超级方便。这对组合键跟 host key 的组合键冲突的时候用起来很难受，所以我把 host key 重新绑定成<code>command + right</code>了。</li>
</ul>
<h2 id="修改-nvram"><a href="#修改-nvram" class="headerlink" title="修改 nvram"></a>修改 nvram</h2><p>在 VMware 里，可用这样修改 nvram：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo nvram boot-args=&quot;-v debug=0x144&quot;</div></pre></td></tr></table></figure></p>
<p>在 virtualbox 里没那么简单，因为一重启修改的值就没了。还好从 virtualbox 手册的 3.13.2 看到了希望：</p>
<blockquote>
<p>不能在运行的虚拟机内部操作 EFI 变量了（如：在Mac OS X 虚拟机里运行 nvram 来设置“boot-args”不管用了）。不过，可以通过给虚拟机发送附加数据”VBoxInternal2/EfiBootArgs” 来设置“boot-args”。…</p>
</blockquote>
<p>因此，我们需要关闭虚拟机，在主机上运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ VBoxManage list vms # 列出下条命令使用的 UUID</div><div class="line">&quot;macOS 10.12.0&quot; &#123;9ad936f8-9360-44a6-ba3e-c4d92b4243e8&#125;</div><div class="line">$ VBoxManage setextradata 9ad936f8-9360-44a6-ba3e-c4d92b4243e8 VBoxInternal2/EfiBootArgs &quot;-v debug=0x144&quot;</div></pre></td></tr></table></figure></p>
<h1 id="交换内核"><a href="#交换内核" class="headerlink" title="交换内核"></a>交换内核</h1><p>前面我提到可以指定<code>kcsuffix</code>选项以调试不同版本的内核。内核文件在虚拟机的<code>/System/Library/Kernels</code>目录，然而这个目录受“系统完整性保护”机制保护（SIP）。所以要想使用 KDK 或者自己编译的内核，必须启动进入 recovery，把目标内核拷进<code>/System/Library/Kernels</code>目录，使 kextcache 失效，然后重新启动。</p>
<h2 id="启动进入-recovery"><a href="#启动进入-recovery" class="headerlink" title="启动进入 recovery"></a>启动进入 recovery</h2><p>在 VMware 里，<code>cmd + R</code>就能进入 recovery 模式。virtualbox 要多几步。</p>
<p>启动虚拟机时，按住<code>F12</code>，然后选择<code>Boot Manager -&gt; EFI Internal Shell</code>，就会看到 EFI Shell 的欢迎界面。输入命令进入 recovery：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS2:\com.apple.recovery.boot\boot.efi</div></pre></td></tr></table></figure></p>
<p>进入 recovery 的界面，打开终端，操作目标内核，并将 kextcache 设置为无效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># mv /path/to/kernels/kernel.development /System/Library/Kernels</div><div class="line"># kextcache -invalidate /Volumes/Macintosh\ HD</div><div class="line"># reboot</div></pre></td></tr></table></figure></p>
<p>如果需要禁用 SIP，在重启之前执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># csrutil disable</div><div class="line">Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.</div></pre></td></tr></table></figure></p>
<h1 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h1><p>下载要调试的版本的 XNU 源码。调试时，LLDB 会去 <code>/Library/Caches/com.apple.xbs/Sources/xnu/xnu-...</code>目录寻找内核源码，所以可以把下载的源码放这个目录，也可以建一个符号链接指向源码目录。还有个方法是 设置 LLDB 的<code>target.source-map</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lldb&gt; settings set target.source-map /Library/Caches/com.apple.xbs/Sources/xnu/xnu-3789.1.32 /Users/kedy/Downloads/xnu-3789.1.32</div></pre></td></tr></table></figure>
<p>早一些的 macOS 版本比如 Yosemite 就只能把源码放在 <code>/SourceCache/xnu/</code>里。</p>
<h1 id="安装-LLDB"><a href="#安装-LLDB" class="headerlink" title="安装 LLDB"></a>安装 LLDB</h1><p>终于到调试器了。下面会举例用的是 RELEASE 内核。</p>
<p>为了在 Sierra KDK 里用 XNU LLDB 宏，执行<code>pip install macholib</code>安装<code>macholib</code>模块。粘贴执行加载内核文件时提示我们要执行的命令。（如下）</p>
<p>触发 NMI 后（或者等待设置了<code>DB_HALT</code>的调试器暂停启动进程时），执行<code>kdp-remote &lt;ip&gt;</code>连接到调试进程（若使用的是 NAT 端口转发，ip 是 localhost）。（如下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">$ lldb /Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel</div><div class="line">(lldb) target create &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel&quot;</div><div class="line">warning: &apos;kernel&apos; contains a debug script. To run this script in this debug session:</div><div class="line"></div><div class="line">    command script import &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/kernel.py&quot;</div><div class="line"></div><div class="line">To run all discovered debug scripts in this session:</div><div class="line"></div><div class="line">    settings set target.load-script-from-symbol-file true</div><div class="line"></div><div class="line">Current executable set to &apos;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel&apos; (x86_64).</div><div class="line">(lldb) command script import &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/kernel.py&quot;</div><div class="line">Loading kernel debugging from /Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/kernel.py</div><div class="line">LLDB version lldb-370.0.40</div><div class="line">  Swift-3.1</div><div class="line">settings set target.process.python-os-plugin-path &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/lldbmacros/core/operating_system.py&quot;</div><div class="line">settings set target.trap-handler-names hndl_allintrs hndl_alltraps trap_from_kernel hndl_double_fault hndl_machine_check _fleh_prefabt _ExceptionVectorsBase _ExceptionVectorsTable _fleh_undef _fleh_dataabt _fleh_irq _fleh_decirq _fleh_fiq_generic _fleh_dec</div><div class="line">command script import &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/lldbmacros/xnu.py&quot;</div><div class="line">xnu debug macros loaded successfully. Run showlldbtypesummaries to enable type summaries.</div><div class="line"></div><div class="line"></div><div class="line">(lldb) kdp-remote 192.168.149.184</div><div class="line">Version: Darwin Kernel Version 15.2.0: Fri Nov 13 19:56:56 PST 2015; root:xnu-3248.20.55~2/RELEASE_X86_64; UUID=17EA3101-D2E4-31BF-BDA9-931F51049F93; stext=0xffffff8007a00000</div><div class="line">Kernel UUID: 17EA3101-D2E4-31BF-BDA9-931F51049F93</div><div class="line">Load Address: 0xffffff8007a00000</div><div class="line">Kernel slid 0x7800000 in memory.</div><div class="line">Loaded kernel file /Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel</div><div class="line">Target arch: x86_64</div><div class="line">Instantiating threads completely from saved state in memory.</div><div class="line">Loading 82 kext modules warning: Can&apos;t find binary/dSYM for com.apple.kec.corecrypto (491718F5-B509-31DC-92B5-6BAC95E3F494)</div><div class="line">.warning: Can&apos;t find binary/dSYM for com.apple.kec.pthread (0888BA0A-49EE-394A-AEB1-1E5C6838A1F2)</div><div class="line"></div><div class="line">(omitted...)</div><div class="line"></div><div class="line">. done.</div><div class="line">kernel was compiled with optimization - stepping may behave oddly; variables may not be available.</div><div class="line">Process 1 stopped</div><div class="line">* thread #2, name = &apos;0xffffff800db8b000&apos;, queue = &apos;0x0&apos;, stop reason = signal SIGSTOP</div><div class="line">    frame #0: 0xffffff8007bd655e kernel`Debugger(message=&lt;unavailable&gt;) at model_dep.c:1020 [opt]</div><div class="line">   1017</div><div class="line">   1018		doprnt_hide_pointers = old_doprnt_hide_pointers;</div><div class="line">   1019		__asm__(&quot;int3&quot;);</div><div class="line">-&gt; 1020		hw_atomic_sub(&amp;debug_mode, 1);</div><div class="line">   1021	&#125;</div><div class="line">   1022</div><div class="line">   1023	char *</div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>瞧，macOS 内核源码调试这就开始了！</p>
<hr>
<p>原文链接: <a href="https://klue.github.io/blog/2017/04/macos_kernel_debugging_vbox/" target="_blank" rel="external">Securing Browsers Through Isolation Versus Mitigation</a></p>
<p>本文首发于<a href="http://bbs.pediy.com/thread-217023.htm" target="_blank" rel="external">看雪</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> translation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[翻译 - “隔离”与“缓解” - Chrome、Edge 在浏览器防护上的终极对决！]]></title>
      <url>/2017/03/10/chromeVSie/</url>
      <content type="html"><![CDATA[<p>昨天微软发布了一篇关于“<a href="https://blogs.windows.com/msedgedev/2017/02/23/mitigating-arbitrary-native-code-execution/" target="_blank" rel="external">新旧隔离机制</a>”的文章[<em>译者注</em>:隔离任意 native 代码的执行]，我个人非常赞同他们给 Edge 整上这个机制，但外面有些个反应简直夸张的不真实。<a id="more"></a>来看看 Dan Guido 的 Twitter (对不住了 Dan ~😉):</p>
<blockquote>
<p>毫无争议, Edge 一跃超过 Chrome 成为了最安全的浏览器！ <a href="https://t.co/JeE08LHBBv" target="_blank" rel="external">https://t.co/JeE08LHBBv</a> ——<a href="https://twitter.com/dguido/status/834846901191204864" target="_blank" rel="external">@dguido</a></p>
</blockquote>
<p>在这件事上，我认为对比 Chrome 来反观微软这次的动作，弄清楚浏览器的世界里发生了什么更为重要。当然，作为 Chrome 安全的工程指导我可能会偏心。但是，我的工作要求我客观的评价各种安全机制从而指导我的团队的努力方向，所以理论上我要作出的结论还是挺“清白”的。</p>
<p><img src="http://bmob-cdn-1754.b0.upaiyun.com/2017/03/10/801c119140181489806cb2d2ed2d8216.jpeg" alt="EvsC"></p>
<h2 id="缓解远程代码执行-RCE"><a href="#缓解远程代码执行-RCE" class="headerlink" title="缓解远程代码执行(RCE)"></a>缓解远程代码执行(RCE)</h2><p>对于前端的远程代码执行，微软可是下了大功夫。它试图通过防止攻击者获得可靠的代码而打破漏洞利用的第一环，如果成功的话就可以完全阻止攻击者。但最后仍然会演变成猫捉老鼠的游戏，缓解虽然可以消耗攻击者更多精力，却不能从根本上阻止漏洞利用。</p>
<p>个人来说，我认为微软此次的着眼点仅仅是放在了 IE 和 Edge 最常受到的攻击类型上，“让数据说话”也的确不失为一种合逻辑的策略。这样的话就有一大堆新的 RCE 缓解技术，连同着其与 chrome 类似技术的对比，我在下面列了写值得注意的几项:</p>
<ul>
<li><p>内存回收<br>通过回收 DOM 对象、在 free 操作时作缓解，内存回收降低了可利用的 use-after-free 漏洞出现的可能性。这能与 Chrome 的 <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/WebKit/Source/platform/heap/BlinkGCAPIReference.md" target="_blank" rel="external">use of Oilpan</a> 类似，通过回收 DOM 对象、分块分配内存，采用不同的缓解措施，来对抗发生中的 use-after-free 利用。总的来说，内存回收只是 Chrome 在这块儿的一个小特点，相对来说 Chrome 没有那么多可利用的漏洞，这局打平。</p>
</li>
<li><p>执行流保护(CFG)</p>
</li>
</ul>
<p>CFG 提供完整的执行流表，在“预防直接执行非法路径”上作了增强，Edge 在内部代码和系统库都用了 CFG。而Chrome 只在系统 DLL 用了 CFG， 另一方面不是 Chrome 内部而是用在了 Clang/LLVM  工具链上，使得我们可以使用 Clang 的 CFI 检查，非常好地契合了 Chrome 的需求。CFI/CFG 是未经过实际检验的技术，未来还可能出现重大的弱点和设计缺陷，总的来说是 Edge 占了上风。</p>
<ul>
<li>JavaScript JIT 加强</li>
</ul>
<p>微软在“防止漏洞利用时利用 JIT ”方面做了很多工作，其中最创新的莫过于将 JIT 移出进程，不让沙盒中的进程直接创建可执行页面。攻击者必须完整编译 RCE 成 ROP 链，这可要费大工夫了。无可否认，虽然 v8 要推出 JavaScript 解释器（ignition）和 JIT 的替代品（turbofan），Chrome 的性能会大幅提升，但是 Chrome 当前的 JIT 缓解措施还是比微软弱。这方面 Edge 遥遥领先了 Chrome。</p>
<h2 id="安全隔离机制"><a href="#安全隔离机制" class="headerlink" title="安全隔离机制"></a>安全隔离机制</h2><p>微软在 RCE 缓解方面比 Chrome 投入更多，Chrome 更专注于在浏览网页时定义和加强持续可用的隔离边界。像微软一样，Chrome 也是受暴露的漏洞类型驱动的。然而，两家是有不同的理念和实施约束的，通过长期观察，我们发现隔离机制反而是更有效的策略，跨平台也更方便。</p>
<p>首先，从安全机制的长期有效性来看，我们在 Chrome 上发现，随着时间的推移，底层 OS 平台倾向于提升安全隔离原语。比如说 Linux 的衍生系统会使用 <a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="external">seccomp-bpf 机制</a>，修改系统调用表，Windows 系统会使用<a href="https://msdn.microsoft.com/en-us/library/bb625957.aspx" target="_blank" rel="external">integrity level(IL)</a>， 锁定 win32k 上的进程缓解策略。在安全隔离方面，我们现在有能力利用这些操作系统作出的安全上的改进。</p>
<p>说到可移植性，拿微软最近的 JIT 加强来说，它依赖于 Windows 10 上 Edge 的新特性，并且受限于微软的签名文件。现在这种 OS 限制已经不常见，工程师们也可以找到替代方法解决，但是考虑到这项功能涉及修改主架构，必须确定这对其他平台是否友好，或者解释说是安全上作了重大改进，然而这两种说法都不现实。</p>
<blockquote>
<p>比起 Edge， Chrome 的渲染器处在更强有力的沙箱保护中。</p>
</blockquote>
<p>Chrome 在创建更强的隔离原语（如 Chrome 的渲染器比 Edge 处在更强的沙箱保护中）和扩展其应用方面（如 GPU 沙盒、网络沙盒）做出了更大努力。</p>
<p>这方面我们的王牌是今年推出的<a href="https://www.chromium.org/developers/design-documents/site-isolation" target="_blank" rel="external">站点隔离项目</a>，站点隔离是数十年的工程成果，为 web 源加上限制，从而阻止渲染器沙盒 RCE 操作其他 web 源。这比现今其他任何浏览器的安全保证都更强壮有力。</p>
<h2 id="这篇文章的点在哪？"><a href="#这篇文章的点在哪？" class="headerlink" title="这篇文章的点在哪？"></a>这篇文章的点在哪？</h2><p>浏览器安全是个复杂的话题。所以我想为 Chrome 现在的决策作一些说明，以及为什么我认为这些决策仍然可以捍卫 Chrome 在各个平台作为最安全浏览器的地位（事实证明）。</p>
<p>现在问题是有一些现象把安全研究降低成简单地划划清单，或者是互相比较安全特征/CVE 的游戏，这些东西对评估真实的安全没一点用处。浏览器的架构是软件里最复杂的，背后的决策对我们也是不透明的。我确实认为我们做了正确的决定，优先解决着 Chrome 最要紧的问题。我承认如果我负责的是 Edge 的安全，我会针对不同的用户拿出不同的数据，最后做出个不一样的结论。</p>
<h2 id="以我们的共同点结束如何？"><a href="#以我们的共同点结束如何？" class="headerlink" title="以我们的共同点结束如何？"></a>以我们的共同点结束如何？</h2><p>微软的博客里关于 Edge 如何防止第三方代码注入这点非常有意思，这也是所有浏览器大头的点。第三方应用使用不当操作插入代码不仅会造成稳定性问题和性能问题，也妨害着浏览器安全。我一直说我们为什么一直不能在 Chrome 沙盒里启用 Lowbox Token（App 容器安全限制）和 CSRSS 限制，因为那时第三方的反病毒程序会造成 Chrome 崩溃。</p>
<p>很高兴看到微软利落的切入了 Edge，为阻止第三方注入开了先河。Chrome 和 Firefox 今年也准备部署类似的方案，在这一点上为了最好的帮助用户我们达成了结盟。</p>
<p><img src="http://bmob-cdn-1754.b0.upaiyun.com/2017/03/10/6ed3e9394075934e805505708887b01b.jpeg" alt=""></p>
<hr>
<p>原文链接: <a href="https://medium.com/@justin.schuh/securing-browsers-through-isolation-versus-mitigation-15f0baced2c2#.l2srshz32" target="_blank" rel="external">Securing Browsers Through Isolation Versus Mitigation</a></p>
<p>本文首发于<a href="http://bbs.pediy.com/thread-216267.htm" target="_blank" rel="external">看雪</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> translation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译 lua 5.3.3 源码]]></title>
      <url>/2016/08/31/compile-lua-5-3-3/</url>
      <content type="html"><![CDATA[<p>lua 源码直接 <code>make platform</code> 编译没什么好说的，这里就说一下需要注意的地方。</p>
<a id="more"></a>
<h1 id="编译为so库"><a href="#编译为so库" class="headerlink" title="编译为so库"></a>编译为so库</h1><p>默认的编译只有 .a 库, so 库只能自己动手了.</p>
<h2 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h2><p>将根目录中的Makefile作如下修改:</p>
<p>将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TO_LIB= liblua.a</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TO_LIB= liblua.a liblua.so</div></pre></td></tr></table></figure></p>
<p>在src/Makefile中寻找合适的位置添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LUA_SO=liblua.so</div><div class="line"></div><div class="line">$(LUA_SO): $(CORE_O) $(LIB_O)</div><div class="line">    $(CC) -o $@ -shared $? -ldl -lm</div></pre></td></tr></table></figure></p>
<p>将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T) $(LUA_SO)</div></pre></td></tr></table></figure></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>编译完成后有两个主要的可执行文件<code>lua</code> 和 <code>luac</code> 和两个库 <code>liblua.a</code> 和 <code>liblua.so</code>.</p>
<p><code>lua</code> : 虚拟机，用来执行 lua 代码<br><code>luac</code> : 编译器，用来为 lua 代码做一些优化什么的 (并不是说脚本语言就不需要编译器了啊啊啊啊)<br><code>liblua.a</code> : 静态库<br><code>liblua.so</code> : 动态库</p>
<h1 id="为Android平台编译"><a href="#为Android平台编译" class="headerlink" title="为Android平台编译"></a>为Android平台编译</h1><p>新建 <code>liblua.mk</code> 和 <code>Android.mk</code>, 写入:</p>
<p><strong>liblua.mk</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">LIB_VERSION:=lua-5.3.3-src</div><div class="line">SRC_ROOT_PATH:= ../../$(LIB_VERSION)</div><div class="line"></div><div class="line">LOCAL_PATH:= $(call my-dir)</div><div class="line">include $(CLEAR_VARS)</div><div class="line"></div><div class="line">LOCAL_MODULE := liblua</div><div class="line">LOCAL_CFLAGS := -D&quot;lua_getlocaledecpoint() =&apos;.&apos;&quot; -DLUA_USE_C89</div><div class="line"></div><div class="line">LOCAL_SRC_FILES := \</div><div class="line"> $(SRC_ROOT_PATH)/src/lapi.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lauxlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lbaselib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lbitlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lcode.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lcorolib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lctype.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldblib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldebug.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldo.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldump.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lfunc.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lgc.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/linit.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/liolib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/llex.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lmathlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lmem.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/loadlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lobject.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lopcodes.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/loslib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lparser.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lstate.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lstring.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lstrlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ltable.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ltablib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ltm.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lua.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lundump.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lvm.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lzio.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lutf8lib.c\</div><div class="line"></div><div class="line">include $(BUILD_SHARED_LIBRARY)</div><div class="line">#include $(BUILD_STATIC_LIBRARY)</div><div class="line">#include $(BUILD_EXECUTABLE)</div></pre></td></tr></table></figure></p>
<p><strong>Android.mk</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH:= $(call my-dir)</div><div class="line">include $(LOCAL_PATH)/liblua.mk</div></pre></td></tr></table></figure></p>
<p>此时文件结构如图 (lua-5.5.5-src文件夹为下载的源码,其他是新建的):</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/30/1.png-styleOnlyWatermark" alt=""></p>
<p>进入<code>jni</code>文件夹执行<code>ndk-build</code>编译, 成功后的文件结构如图:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/30/2.png-styleOnlyWatermark" alt=""></p>
<h1 id="错误列表"><a href="#错误列表" class="headerlink" title="错误列表"></a>错误列表</h1><h2 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file not recognized: 不可识别的文件格式</div></pre></td></tr></table></figure>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make clean</div></pre></td></tr></table></figure></p>
<h2 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ld: lapi.o: relocation R_X86_64_32 against `luaO_nilobject_&apos; can not be used when making a shared object; recompile with -fPIC</div><div class="line">lapi.o: error adding symbols: 错误的值</div></pre></td></tr></table></figure>
<p>将src/Makefile文件中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) $(MYCFLAGS)</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) -fPIC $(MYCFLAGS)</div></pre></td></tr></table></figure></p>
<h2 id="错误3"><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: &apos;struct lconv&apos; has no member named &apos;decimal_point&apos;</div></pre></td></tr></table></figure>
<p>将<code>luaconf.h</code>中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define lua_getlocaledecpoint()		(localeconv()-&gt;decimal_point[0])</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define lua_getlocaledecpoint()		&apos;.&apos;</div></pre></td></tr></table></figure></p>
<p><strong>或者</strong> 在makefile加上选项 <code>-D&quot;lua_getlocaledecpoint() =&#39;.&#39;&quot;</code>. (完整makefile内容见上)</p>
<h2 id="错误4"><a href="#错误4" class="headerlink" title="错误4"></a>错误4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">undefined reference to &apos;log2&apos;</div></pre></td></tr></table></figure>
<p>在 <code>makefile</code> 加上选项 <code>-DLUA_USE_C89</code> . (完整makefile内容见上)</p>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> compile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 调试 smali 代码]]></title>
      <url>/2016/08/07/use-studio-debug-smali/</url>
      <content type="html"><![CDATA[<p>对于 java 层逆向来说，动态调试可比打 log 方便多了 :p</p>
<a id="more"></a>
<p>开始之前先供出一个大神（此处献上膝盖），smali、baksmali、smalidea 全套都可以在这里 -&gt; <a href="https://bitbucket.org/JesusFreke/smali/downloads" target="_blank" rel="external">下载</a>，今天用到的是 smalidea 插件，目前版本是 0.03 .</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><ul>
<li><strong>File -&gt; Settings</strong> 点击 <strong>Plugins</strong> :</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/1.png-styleOnlyWatermark" alt=""></p>
<h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><ul>
<li>使用 baksmali 将 dex 文件反编译为 smali .</li>
<li><strong>File -&gt; New -&gt; Import Project…</strong>，选中反编译过的 smali 目录。</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/2.png-styleOnlyWatermark" alt=""></p>
<p>之后一路 next 即可。</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><ul>
<li>右键源代码根目录 <strong>Mark Directory As -&gt; Sources Root</strong> </li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/5.png-styleOnlyWatermark" alt=""></p>
<ul>
<li><strong>File -&gt; Project Structure…</strong> 设置 jdk</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/3.png-styleOnlyWatermark" alt=""></p>
<ul>
<li><strong>Run -&gt; Edit Configurations…</strong> 新建一个 remote，设置端口为8700，命名为 smali</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/7.png-styleOnlyWatermark" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/8.png-styleOnlyWatermark" alt=""></p>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><ul>
<li>确保选择的 app 是可调试的/修改过设备环境</li>
<li><p>安装 apk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb install xxx.apk</div></pre></td></tr></table></figure>
</li>
<li><p>启动 Android Device Monitor （开启调试端口用）</p>
</li>
<li><p>启动 app</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -D -n package_name/main_activity_name</div></pre></td></tr></table></figure>
</li>
<li><p>下好断点</p>
</li>
<li>开始 Debug</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/9.png-styleOnlyWatermark" alt=""></p>
<ul>
<li>断下</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/6.png-styleOnlyWatermark" alt=""></p>
<hr>
<p>over~</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
            <tag> smali </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何重新编译 uiautomatorviewer]]></title>
      <url>/2016/08/06/recompile-uiautomatorviewer/</url>
      <content type="html"><![CDATA[<p>在使用uiautomatorviewer时可能会想用到其本身没有的功能，或者想修改一下它的逻辑，这时候就需要重新编译一个jar包了。</p>
<a id="more"></a>
<p>好在Android是开源的，所以不用反编译原来的jar包直接下载源代码就可以了，我是在这里clone了一份 -&gt; <a href="https://github.com/android-ia/platform_tools_swt" target="_blank" rel="external">链接</a> ~ 当然只需要用到其中的<a href="https://github.com/android-ia/platform_tools_swt/tree/master/uiautomatorviewer" target="_blank" rel="external">uiautomatorviewer</a>这一个源码文件夹就够了。</p>
<p>因为google使用eclipse rcp来开发这些个工具的，所以我们需要使用eclipse建立e4项目。</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/1.png-styleOnlyWatermark" alt=""></p>
<p>建立的过程中一直next就好。</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/2.png-styleOnlyWatermark" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/3.png-styleOnlyWatermark" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/4.png-styleOnlyWatermark" alt=""></p>
<p>将uiautomatorviewer的源码中src/main/java文件夹下的 <strong>com 和 image</strong> 文件夹复制到工程中的src中，下载 <strong>ddmlib.jar</strong> 和 <strong>common.jar</strong> 复制到 libs 文件夹下(没有就创建一个)，再将这两个 jar 包右键 <strong>“Build Path” -&gt; “Add to Build Path”</strong>。<br>附上 <a href="http://www.java2s.com/Code/JarDownload/ddmlib/ddmlib-22.2.0.jar.zip" target="_blank" rel="external">ddmlib.jar</a> 和 <a href="http://www.java2s.com/Code/JarDownload/common/common.jar.zip" target="_blank" rel="external">common.jar</a> 的下载地址。<br>这是完成的项目目录：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/5.png-styleOnlyWatermark" alt=""></p>
<p>根据自己的需求修改过代码后，在项目根节点右键 <strong>“export…”</strong>，选择 <strong>“JAR file”</strong>:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/6.png-styleOnlyWatermark" alt=""></p>
<p>选择导出要包括的项目文件，只选 <strong>src</strong> 即可，并填入导出路径:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/7.png-styleOnlyWatermark" alt=""></p>
<p>一直next，在最后一步记得填入 <strong>Main class</strong>:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/8.png-styleOnlyWatermark" alt=""></p>
<p><strong>finish</strong> 之后即可在导出路径下看到jar文件，替换掉sdk tools中的uiautomatorviewer.jar就可以使用我们自定义的工具了~</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> compile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[升级站长秘籍：使用flarum框架搭建一个有逼格的轻论坛]]></title>
      <url>/2016/04/14/install-flarum/</url>
      <content type="html"><![CDATA[<p>先来个成品图观赏观赏：</p>
<a id="more"></a>
<p>手机版：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/21/10/30-style1" alt=""></p>
<p>电脑版：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/21/05/53-style1" alt=""></p>
<hr>
<p>我的环境：ubuntu 14.06 x64 VPS</p>
<h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><p>依次安装 apache2、php5、mysql-server、php5-mysql .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install apache2</div><div class="line">sudo apt-get install php5</div><div class="line">sudo apt-get install mysql-server</div><div class="line">sudo apt-get install php5-mysql</div></pre></td></tr></table></figure>
<p>安装composer.(这一步直接在官网下载可执行文件加上可执行权限复制到/usr/local/bin中就行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">php -r &quot;readfile(&apos;https://getcomposer.org/installer&apos;);&quot; &gt; composer-setup.php</div><div class="line">php -r &quot;if (hash(&apos;SHA384&apos;, file_get_contents(&apos;composer-setup.php&apos;)) === &apos;7228c001f88bee97506740ef0888240bd8a760b046ee16db8f4095c0d8d525f2367663f22a46b48d072c816e7fe19959&apos;) &#123; echo &apos;Installer verified&apos;; &#125; else &#123; echo &apos;Installer corrupt&apos;; unlink(&apos;composer-setup.php&apos;); &#125; echo PHP_EOL;&quot;</div><div class="line">php composer-setup.php --install-dir=bin --filename=composer</div><div class="line">php -r &quot;unlink(&apos;composer-setup.php&apos;);&quot;</div></pre></td></tr></table></figure>
<h1 id="创建flarum工程"><a href="#创建flarum工程" class="headerlink" title="创建flarum工程"></a>创建flarum工程</h1><p>一定要在空目录里执行create-object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir V2NB_forum</div><div class="line">cd V2NB_forum/</div><div class="line">composer create-project flarum/flarum . --stability=beta</div></pre></td></tr></table></figure>
<p>安装过程中可能会出现错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Installing flarum/flarum (v0.1.0-beta.5)</div><div class="line">  - Installing flarum/flarum (v0.1.0-beta.5)</div><div class="line">    Downloading: 100%         </div><div class="line"></div><div class="line">Created project in .</div><div class="line">Loading composer repositories with package information</div><div class="line">Updating dependencies (including require-dev)</div><div class="line">Your requirements could not be resolved to an installable set of packages.</div><div class="line"></div><div class="line">  Problem 1</div><div class="line">    - flarum/flarum-ext-akismet v0.1.0-beta.3 requires tijsverkoyen/akismet ^1.1 -&gt; satisfiable by tijsverkoyen/akismet[1.1.0].</div><div class="line">    - flarum/flarum-ext-akismet v0.1.0-beta.5 requires tijsverkoyen/akismet ^1.1 -&gt; satisfiable by tijsverkoyen/akismet[1.1.0].</div><div class="line">    - tijsverkoyen/akismet 1.1.0 requires ext-curl * -&gt; the requested PHP extension curl is missing from your system.</div><div class="line">    - Installation request for flarum/flarum-ext-akismet ^0.1.0 -&gt; satisfiable by flarum/flarum-ext-akismet[v0.1.0-beta.3, v0.1.0-beta.5].</div><div class="line"></div><div class="line">  To enable extensions, verify that they are enabled in those .ini files:</div><div class="line">    - /etc/php5/cli/php.ini</div><div class="line">    - /etc/php5/cli/conf.d/05-opcache.ini</div><div class="line">    - /etc/php5/cli/conf.d/10-pdo.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-json.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-mysql.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-mysqli.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-pdo_mysql.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-readline.ini</div><div class="line">  You can also run `php --ini` inside terminal to see which files are used by PHP in CLI mode.</div></pre></td></tr></table></figure>
<p>这时需要安装php-curl后，删除目录中的所有文件(包括.开头的隐藏文件)再执行<code>composer create-project flarum/flarum . --stability=beta</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install php5-curl</div></pre></td></tr></table></figure>
<p>正常的安装日志应该好长好长。</p>
<p>这时工程目录中的文件如下：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/21/35/27-style1" alt=""></p>
<h1 id="一些修改和设置"><a href="#一些修改和设置" class="headerlink" title="一些修改和设置"></a>一些修改和设置</h1><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>将工程目录全部文件和文件夹的权限修改为777.<br>如我的是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod -R 777 /home/kiya/v2nb</div></pre></td></tr></table></figure>
<h2 id="开启rewrite"><a href="#开启rewrite" class="headerlink" title="开启rewrite"></a>开启rewrite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /etc/apache2/mods-enabled</div><div class="line">sudo ln -s ../mods-available/rewrite.load</div></pre></td></tr></table></figure>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>修改<code>/etc/apache2/sites-available/000-default.conf</code>文件中的DocumentRoot项为你的项目文件夹路径. 如<code>DocumentRoot /home/kiya/v2nb</code>.<br>并在该文件中的<code>VirtualHost</code>节点之间添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Directory /home/kiya/V2NB&gt;</div><div class="line">    AllowOverride All</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<p>在<code>/etc/apache2/apache2.conf</code>文件中找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Directory /&gt;</div><div class="line">        Options FollowSymLinks</div><div class="line">        AllowOverride None</div><div class="line">        Require all denied</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<p>将<code>Require all denied</code>改为<code>Require all granted</code>,将<code>AllowOverride None</code>改为<code>AllowOverride All</code>.</p>
<h2 id="修改host"><a href="#修改host" class="headerlink" title="修改host"></a>修改host</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/hosts</div></pre></td></tr></table></figure>
<p>打开hosts新增加一行<code>23.105.197.243 v2nb.today</code>. 这里的ip是vps的ip，域名随便写. 本机的话可以ip可以写成<code>127.0.0.1</code>.<br>如果这里不加在启动apache服务时会警告:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AH00558: apache2: Could not reliably determine the server&apos;s fully qualified domain name, using v2nb.today. Set the &apos;ServerName&apos; directive globally to suppress this message</div></pre></td></tr></table></figure>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>命令行创建一个论坛用的数据库,user和pass时安装mysql时填写的账号密码. 待会要用到.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql -u user -p</div><div class="line">pass</div><div class="line">create database v2nb;</div></pre></td></tr></table></figure>
<h1 id="安装flarum"><a href="#安装flarum" class="headerlink" title="安装flarum"></a>安装flarum</h1><p>重启apache服务.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure>
<p>用浏览器访问<code>23.105.197.243</code>. 如果是本地测试则访问<code>localhost</code>.</p>
<p>如果出现的是：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/23/39/41-style1" alt=""></p>
<p>则需要安装<code>gd</code>模块,执行<code>sudo apt-get install php5-gd</code>重启apache即可.</p>
<p>正确的话会出现下图页面用以填写信息：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/23/43/21-style1" alt=""></p>
<p>其中的<code>MySQL Database</code>是上面我们自己创建的数据库名字. 填好之后点击<code>Install Flarum</code>.</p>
<p>出现下图就安装好啦~</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/23/47/54-style1" alt=""></p>
<p>管理员界面:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/15/00/11/45-style1" alt=""></p>
<h1 id="访问oops"><a href="#访问oops" class="headerlink" title="访问oops"></a>访问oops</h1><p>在使用域名打开论坛时如果经常出现<code>Oops! Something went wrong. Please reload the page and try again</code>并且资源也加载不出,可能是说明请求的url和配置的url不一样.<br>需要修改工程目录下的<code>config.php</code>文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim config.php</div></pre></td></tr></table></figure>
<p>如将<code>&#39;url&#39; =&gt; &#39;23.105.197.243&#39;</code>改为<code>&#39;url&#39; =&gt; &#39;v2nb.today&#39;</code>.</p>
<h1 id="enjoy"><a href="#enjoy" class="headerlink" title="enjoy !"></a>enjoy !</h1><p>累煞我也.</p>
]]></content>
      
        <categories>
            
            <category> flarum </category>
            
        </categories>
        
        
        <tags>
            
            <tag> instruction </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu启动ida报错找不到libgthread-2.0.so.0]]></title>
      <url>/2016/03/20/install-ia32-libs/</url>
      <content type="html"><![CDATA[<p>换了电脑新装了ubuntu 15.04 64位，启动ida时报错“Error while loading shared libraries: libgthread-2.0.so.0”。<br>这是因为ida需要32位的库而我的系统是64位的，所以要安装32位的库。</p>
<a id="more"></a>
<p>说缺少libgthread-2.0.so.0那我就先安装libgthread-2.0.so.0呗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dpkg -S libgthread-2.0.so.0</div><div class="line">sudo apt-get install libglib2.0-0:i386</div></pre></td></tr></table></figure>
<p>完了启动ida又提示缺少另一个，再安又提示..<br>得了，直接把32位的库都安了吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install ia32-libs</div></pre></td></tr></table></figure>
<p>然而并没有成功，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">正在读取软件包列表...完成</div><div class="line">正在分析软件包的依赖关系树</div><div class="line">正在读取状态信息...完成</div><div class="line">现在没有可用的软件包 ia32-libs，但是它被其它的软件包引用了。</div><div class="line">这可能意味着这个缺失的软件包可能已经被废弃，</div><div class="line">或者只能在其他发布源中找到</div><div class="line">....</div></pre></td></tr></table></figure>
<p>最终：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dpkg --print-architecture</div><div class="line">dpkg --add-architecture i386</div><div class="line">apt-get update</div><div class="line">apt-get install iceweasel:i386</div></pre></td></tr></table></figure>
<p><strong>Reference</strong></p>
<p><a href="http://blog.tshine.me/ubuntu14-04-64%E4%BD%8D-%E5%AE%89%E8%A3%85-ia32-libs%E5%BA%93.html" target="_blank" rel="external">ubuntu14.04 64位 安装 ia32-libs库</a></p>
<p><a href="http://askubuntu.com/questions/427496/error-while-loading-shared-libraries-libgthread-2-0-so-0" target="_blank" rel="external">Error while loading shared libraries: libgthread-2.0.so.0</a></p>
<p><a href="http://blog.csdn.net/u011500307/article/details/11933739" target="_blank" rel="external">64位Ubuntu系统安装32位兼容库</a></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ida </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[某加固中的反调试]]></title>
      <url>/2016/01/12/anti-debug-in-jiagubao/</url>
      <content type="html"><![CDATA[<p>以某厨房为例.</p>
<a id="more"></a>
<h1 id="反调试函数"><a href="#反调试函数" class="headerlink" title="反调试函数"></a>反调试函数</h1><p>（jiagu.so基址5287d000）</p>
<p>在library load/unload断下,在mmap函数尾部下断点,断下后f8执行几句,可找到<code>libjiagu.so:528855E4 BL      loc_5288308C</code>,进入反调试.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/12/35/50" alt=""></p>
<p>往下执行的关键跳转有<br><strong>libjiagu.so:528830D0 BLX     LR     ; debug079:5287C000</strong><br><strong>debug079:5287C014 BLX     LR         ; loc_5288042C</strong><br><strong>debug079:5287C038 BLX     LR ; loc_52880614</strong></p>
<p><code>5287C000</code>是一个反调试模块的起始.</p>
<p><code>libjiagu.so:loc_5288042C</code>函数作用是打开status文件获得TracerPid,此函数地址不变 其中的 <strong>libjiagu.so:52880528 BL      open_0</strong> 是调用<code>open</code>打开<code>/proc/self/status</code>的.</p>
<p><code>loc_52880614</code>是第二种反调试.</p>
<hr>
<h1 id="具体的反调试过程"><a href="#具体的反调试过程" class="headerlink" title="具体的反调试过程"></a>具体的反调试过程</h1><h2 id="解析status文件"><a href="#解析status文件" class="headerlink" title="解析status文件"></a>解析status文件</h2><h3 id="找出-TracerPid"><a href="#找出-TracerPid" class="headerlink" title="找出 TracerPid"></a>找出 TracerPid</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/33/10-style1" alt=""></p>
<h3 id="转换-TracerPid"><a href="#转换-TracerPid" class="headerlink" title="转换 TracerPid"></a>转换 TracerPid</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/19/37/38-style1" alt=""></p>
<h3 id="比较-TracerPid"><a href="#比较-TracerPid" class="headerlink" title="比较 TracerPid"></a>比较 TracerPid</h3><p>如果<code>TracerPid</code>不为0,kill!</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/34/28-style1" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/34/47-style1" alt=""></p>
<h2 id="解析-proc-net-tcp文件"><a href="#解析-proc-net-tcp文件" class="headerlink" title="解析/proc/net/tcp文件"></a>解析/proc/net/tcp文件</h2><p>在比较过<code>tracerid</code>后,接着又解析了<code>tcp</code>文件.</p>
<h3 id="调用处"><a href="#调用处" class="headerlink" title="调用处"></a>调用处</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/35/12-style1" alt=""></p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/35/33-style1" alt=""></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/35/49-style1" alt=""></p>
<p>逐行比较是否含有<code>00000000:5D8A</code>,5d8a就是23946,<code>android_server</code>监听端口即为23946,0A状态表示监听.<br>这里r0会被赋为1，返回调用处时进程就会被kill.</p>
<p>如本机tcp文件中的内容为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode                                                     </div><div class="line"> 0: 00000000:5D8A 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 42138 1 00000000 100 0 0 10 -1                            </div><div class="line"> 1: 00000000:15B3 00000000:0000 0A 00000000:00000000 00:00000000 00000000  2000        0 20426 1 00000000 100 0 0 10 -1                            </div><div class="line"> 2: 0100007F:91AF 0100007F:5D8A 01 00000000:00000000 00:00000000 00000000  2000        0 43283 1 00000000 21 4 2 10 -1                             </div><div class="line"> 3: ED01A8C0:15B3 EE01A8C0:E1B6 01 00000018:00000000 01:00000018 00000000  2000        0 20427 2 00000000 24 4 28 8 6                              </div><div class="line"> 4: 0100007F:5D8A 0100007F:91AF 01 00000000:00000000 02:00083C35 00000000     0        0 42634 2 00000000 22 4 3 10 -1</div></pre></td></tr></table></figure>
<hr>
<h1 id="绕过反调试"><a href="#绕过反调试" class="headerlink" title="绕过反调试"></a>绕过反调试</h1><p>关键断点是:<code>libjiagu.so:loc_5288042C</code>,返回之后就是cmp.<br>第二种反调试<code>libjiagu.so:52880614</code>在cmp下面(若有).</p>
<p>断下之后在lr对应的地址下断点,f9，将两个反调试函数下面的比较的r0值修改就可以了.</p>
<hr>
<h1 id="反调试的patch"><a href="#反调试的patch" class="headerlink" title="反调试的patch"></a>反调试的patch</h1><p>但是不止一次反调试,每次的地址也不同,而且每个采用这种加固的app都要如此,这样也太不划算了吧.既然如此,为什么不patch一下呢?</p>
<p>将<code>libjiagu.so</code>作如下修改即可去掉反调试:(返回值r0改为0,mov r0,#0)<br>文件偏移<code>35EC</code>处 -&gt; <code>04 00 A0 E1</code>改为<code>00 00 A0 E3</code><br>文件偏移<code>3720</code>处 -&gt; <code>01 00 A0 E3</code>改为<code>00 00 A0 E3</code></p>
<hr>
<p>本文小白鼠: <a href="https://github.com/kiya-z/Android/blob/master/lab-mouse/com.xiachufang_138.apk" target="_blank" rel="external">here</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.52pojie.cn/thread-435746-1-1.html" target="_blank" rel="external">xxx加固 之 动态脱壳</a></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
            <category> 某加固 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> anti-debug </tag>
            
            <tag> enforce </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一个xposed模块中的“Class ref in pre-verified class resolved to unexpected implementation”错误原因]]></title>
      <url>/2016/01/03/xposed-class-ispreverified/</url>
      <content type="html"><![CDATA[<p>在我的<a href="http://kiya.space/2015/12/28/hello-xposed/" target="_blank" rel="external">第一个 Xposed 模块</a>中曾出现<code>Class ref in pre-verified class resolved to unexpected implementation</code>错误,Xposed log如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">01-03 19:42:03.974 134-134/? I/Xposed: Loading modules from /data/app/space.kiya.xposedtest-1.apk</div><div class="line">01-03 19:42:04.285 134-134/? I/Xposed:   Loading class space.kiya.xposedtest.ChangeStatusBar</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed: java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.DexFile.defineClass(Native Method)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.DexFile.loadClassBinaryName(DexFile.java:211)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.DexPathList.findClass(DexPathList.java:313)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:51)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at java.lang.ClassLoader.loadClass(ClassLoader.java:501)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at java.lang.ClassLoader.loadClass(ClassLoader.java:461)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at de.robv.android.xposed.XposedBridge.loadModule(XposedBridge.java:421)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at de.robv.android.xposed.XposedBridge.loadModules(XposedBridge.java:386)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:120)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.NativeStart.main(Native Method)</div></pre></td></tr></table></figure>
<p>从中可以看到,因为XposedBridge的main函数调用了loadModules,而loadModules又调用了loadModule,loadModule调用loadClass,这样一层一层下去最终导致了现在的错误.<br>我们就从案发现场<code>loadclass</code>和错误信息<code>Class ref in pre-verified class resolved to unexpected implementation</code>入手吧！</p>
<h1 id="案发现场-loadclass"><a href="#案发现场-loadclass" class="headerlink" title="案发现场 loadclass"></a>案发现场 loadclass</h1><p>把<a href="https://github.com/rovo89/XposedBridge" target="_blank" rel="external">XposedBridge的代码</a>clone下来,找到<code>de/robv/android/xposed/XposedBridge</code>文件.</p>
<p>我们知道<code>Xposed Installer</code>的界面有一个模块列表,在写Xposed模块时也需要新建文件<code>xposed_init</code>写入实现了Xposed接口的类名.</p>
<p>main函数的作用就是初始化Xposed框架和模块,模块是怎么初始化的呢?来看loadModules函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Try to load all modules defined in &lt;code&gt;BASE_DIR/conf/modules.list&lt;/code&gt;</div><div class="line"> */</div><div class="line">private static void loadModules() throws IOException &#123;</div><div class="line">	final String filename = BASE_DIR + &quot;conf/modules.list&quot;;</div><div class="line">	BaseService service = SELinuxHelper.getAppDataFileService();</div><div class="line">	if (!service.checkFileExists(filename)) &#123;</div><div class="line">		Log.e(TAG, &quot;Cannot load any modules because &quot; + filename + &quot; was not found&quot;);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	InputStream stream = service.getFileInputStream(filename);</div><div class="line">	BufferedReader apks = new BufferedReader(new InputStreamReader(stream));</div><div class="line">	String apk;</div><div class="line">	while ((apk = apks.readLine()) != null) &#123;</div><div class="line">		loadModule(apk);</div><div class="line">	&#125;</div><div class="line">	apks.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Xposed Installer</code>的安装目录<code>/data/data/de.robv.android.xposed.installer</code>下的<code>conf</code>文件夹下有一个<code>modules.list</code>文件,记录着每个xposed模块的apk的路径.<br><code>loadModules</code>对每行(一行对应一个apk路径)调用<code>loadModule</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Load a module from an APK by calling the init(String) method for all classes defined</div><div class="line"> * in &lt;code&gt;assets/xposed_init&lt;/code&gt;.</div><div class="line"> */</div><div class="line">@SuppressWarnings(&quot;deprecation&quot;)</div><div class="line">private static void loadModule(String apk) &#123;</div><div class="line">	log(&quot;Loading modules from &quot; + apk);</div><div class="line"></div><div class="line">	if (!new File(apk).exists()) &#123;</div><div class="line">		log(&quot;  File does not exist&quot;);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ClassLoader mcl = new PathClassLoader(apk, BOOTCLASSLOADER);</div><div class="line">	InputStream is = mcl.getResourceAsStream(&quot;assets/xposed_init&quot;);</div><div class="line">	if (is == null) &#123;</div><div class="line">		log(&quot;assets/xposed_init not found in the APK&quot;);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	BufferedReader moduleClassesReader = new BufferedReader(new InputStreamReader(is));</div><div class="line">	try &#123;</div><div class="line">		String moduleClassName;</div><div class="line">		while ((moduleClassName = moduleClassesReader.readLine()) != null) &#123;</div><div class="line">			moduleClassName = moduleClassName.trim();</div><div class="line">			if (moduleClassName.isEmpty() || moduleClassName.startsWith(&quot;#&quot;))</div><div class="line">				continue;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				log (&quot;  Loading class &quot; + moduleClassName);</div><div class="line">				Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</div><div class="line"></div><div class="line">				if (!IXposedMod.class.isAssignableFrom(moduleClass)) &#123;</div><div class="line">					log (&quot;    This class doesn&apos;t implement any sub-interface of IXposedMod, skipping it&quot;);</div><div class="line">					continue;</div><div class="line">				&#125; else if (disableResources &amp;&amp; IXposedHookInitPackageResources.class.isAssignableFrom(moduleClass)) &#123;</div><div class="line">					log (&quot;    This class requires resource-related hooks (which are disabled), skipping it.&quot;);</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				final Object moduleInstance = moduleClass.newInstance();</div><div class="line">				if (isZygote) &#123;</div><div class="line">					if (moduleInstance instanceof IXposedHookZygoteInit) &#123;</div><div class="line">						IXposedHookZygoteInit.StartupParam param = new IXposedHookZygoteInit.StartupParam();</div><div class="line">						param.modulePath = apk;</div><div class="line">						param.startsSystemServer = startsSystemServer;</div><div class="line">						((IXposedHookZygoteInit) moduleInstance).initZygote(param);</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					if (moduleInstance instanceof IXposedHookLoadPackage)</div><div class="line">						hookLoadPackage(new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance));</div><div class="line"></div><div class="line">					if (moduleInstance instanceof IXposedHookInitPackageResources)</div><div class="line">						hookInitPackageResources(new IXposedHookInitPackageResources.Wrapper((IXposedHookInitPackageResources) moduleInstance));</div><div class="line">				&#125; else &#123;</div><div class="line">					if (moduleInstance instanceof IXposedHookCmdInit) &#123;</div><div class="line">						IXposedHookCmdInit.StartupParam param = new IXposedHookCmdInit.StartupParam();</div><div class="line">						param.modulePath = apk;</div><div class="line">						param.startClassName = startClassName;</div><div class="line">						((IXposedHookCmdInit) moduleInstance).initCmdApp(param);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">				log(t);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; catch (IOException e) &#123;</div><div class="line">		log(e);</div><div class="line">	&#125; finally &#123;</div><div class="line">		try &#123;</div><div class="line">			is.close();</div><div class="line">		&#125; catch (IOException ignored) &#123;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loadModule</code>读取每个apk文件中的<code>assets/xposed_init</code>,使用<code>PathClassLoader</code>的<code>loadclass</code>方法加载每个注册的类,然后将类的实例作为相应xposed模块的回调.</p>
<p>那么<code>Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</code>这句代码是怎么会出错的呢?</p>
<h1 id="何方神圣-CLASS-ISPREVERIFIED"><a href="#何方神圣-CLASS-ISPREVERIFIED" class="headerlink" title="何方神圣 CLASS_ISPREVERIFIED"></a>何方神圣 CLASS_ISPREVERIFIED</h1><p><code>CLASS_ISPREVERIFIED</code>是虚拟机在对dex文件优化时的一个<code>ClassFlags</code>,表示某个类是否已经被预验证过.<br>也就是说当某个类中引用的方法全部来自所在的dex文件中时,这个类就会被打上这个标记.<br>若app有多个dex文件时,当引用了某个带有这个标记的类时,虚拟机不需要在全部的dex文件中查找,从而帮助提高dalvik虚拟机的性能.</p>
<p>关于如何验证的细节稍后分析.</p>
<p>我们写的<code>ChangeStatusBar</code>类实现了<code>IXposedHookLoadPackage</code>,同时jar包的引用方式为<code>compile</code>,所以也把XposedBridge.jar编译进dex了,因此在验证<code>ChangeStatusBar</code>类时在本dex中可以找到<code>IXposedHookLoadPackage</code>从而被标记了<code>CLASS_ISPREVERIFIED</code>.</p>
<p><strong>那么是在哪里检查是否有CLASS_ISPREVERIFIED标记的呢？</strong></p>
<p>源代码文件<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Resolve.cpp#119" target="_blank" rel="external">/dalvik/vm/oo/Resolve.cpp</a>的<code>dvmResolveClass</code>函数中:有这么一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (!fromUnverifiedConstant &amp;&amp; IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))</div><div class="line">&#123;</div><div class="line">    ClassObject* resClassCheck = resClass;</div><div class="line">    if (dvmIsArrayClass(resClassCheck))</div><div class="line">        resClassCheck = resClassCheck-&gt;elementClass;</div><div class="line"></div><div class="line">    if (referrer-&gt;pDvmDex != resClassCheck-&gt;pDvmDex &amp;&amp;</div><div class="line">        resClassCheck-&gt;classLoader != NULL)</div><div class="line">    &#123;</div><div class="line">        ALOGW(&quot;Class resolved by unexpected DEX:&quot;</div><div class="line">             &quot; %s(%p):%p ref [%s] %s(%p):%p&quot;,</div><div class="line">            referrer-&gt;descriptor, referrer-&gt;classLoader,</div><div class="line">            referrer-&gt;pDvmDex,</div><div class="line">            resClass-&gt;descriptor, resClassCheck-&gt;descriptor,</div><div class="line">            resClassCheck-&gt;classLoader, resClassCheck-&gt;pDvmDex);</div><div class="line">        ALOGW(&quot;(%s had used a different %s during pre-verification)&quot;,</div><div class="line">            referrer-&gt;descriptor, resClass-&gt;descriptor);</div><div class="line">        dvmThrowIllegalAccessError(</div><div class="line">            &quot;Class ref in pre-verified class resolved to unexpected &quot;</div><div class="line">            &quot;implementation&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当虚拟机找到需要引用的类时,如果引用者已经被预验证过,且引用者所在的dex和被引用者所在的dex不同时,抛出<code>Class ref in pre-verified class ...</code>异常!</p>
<p>而在我的<a href="http://kiya.space/2015/12/28/hello-xposed/" target="_blank" rel="external">第一个 Xposed 模块</a>出现错误时dalvik的log如下(经过剪切):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">01-04 20:11:03.463 134-134/? W/dalvikvm: Class resolved by unexpected DEX: Lspace/kiya/xposedtest/ChangeStatusBar;(0x40e59fc8):0x5028f000 ref [Lde/robv/android/xposed/IXposedHookLoadPackage;] Lde/robv/android/xposed/IXposedHookLoadPackage;(0x40da2fd0):0x4f2f8000</div><div class="line">01-04 20:14:06.184 134-134/? W/dalvikvm: (Lspace/kiya/xposedtest/ChangeStatusBar; had used a different Lde/robv/android/xposed/IXposedHookLoadPackage; during pre-verification)</div><div class="line"></div><div class="line">01-04 20:11:03.467 134-134/? W/dalvikvm: Class resolved by unexpected DEX: Lspace/kiya/xposedtest/GetQQPassword;(0x40e59fc8):0x5028f000 ref [Lde/robv/android/xposed/IXposedHookLoadPackage;] Lde/robv/android/xposed/IXposedHookLoadPackage;(0x40da2fd0):0x4f2f8000</div><div class="line">01-04 20:14:06.187 134-134/? W/dalvikvm: (Lspace/kiya/xposedtest/GetQQPassword; had used a different Lde/robv/android/xposed/IXposedHookLoadPackage; during pre-verification)</div></pre></td></tr></table></figure>
<p>这里可以看出在<code>loadclass</code>时的引用者是<code>Lspace/kiya/xposedtest/ChangeStatusBar</code>,被引用者是<code>Lde/robv/android/xposed/IXposedHookLoadPackage</code>.<br>(解析类的过程包括类的所有引用的检查,这里问题是出在模块类引用其他类时而非xposed加载模块类时,故引用者是被加载的模块类)</p>
<p>dalvik解析的时候发现<code>IXposedHookLoadPackage</code>和<code>ChangeStatusBar</code>不在一个dex文件内,但是<code>ChangeStatusBar</code>类已经被校验过了呀,里面所有的方法都在本dex内,现在又告诉我不在一起了,那肯定要报错了!</p>
<p>和上一小节的问题结合起来,必然是<code>loadclass</code>加载类的同时做了验证!是否是这样我们随后再验证.</p>
<p>现在的问题是明明<code>ChangeStatusBar</code>已经通过了校验,<code>IXposedHookLoadPackage</code>和<code>ChangeStatusBar</code>在同一个dex中,怎么加载时<code>IXposedHookLoadPackage</code>又不在这里了?</p>
<h1 id="罪魁祸首-PathClassLoader"><a href="#罪魁祸首-PathClassLoader" class="headerlink" title="罪魁祸首 PathClassLoader"></a>罪魁祸首 PathClassLoader</h1><p>这就要说说PathClassLoader了.</p>
<p><code>XposedBridge</code>源码中使用的类加载器就是PathClassLoader.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static final ClassLoader BOOTCLASSLOADER = ClassLoader.getSystemClassLoader();</div><div class="line">ClassLoader mcl = new PathClassLoader(apk, BOOTCLASSLOADER);</div></pre></td></tr></table></figure>
<p>其中apk是模块apk的路径;BOOTCLASSLOADER是系统类加载器的实例,从classpath中加载类.</p>
<blockquote>
<p>loadClass方法在加载一个类的实例的时候，<br>会先查询当前ClassLoader实例是否加载过此类，有就返回；<br>如果没有。查询Parent是否已经加载过此类，如果已经加载过，就直接返回Parent加载的类；<br>如果继承路线上的ClassLoader都没有加载，才由Child执行类的加载工作；</p>
</blockquote>
<p>也就是说我们的<code>apk</code>是最后一个被查找的路径.</p>
<p>而在<code>Xposed</code>源码中的<code>app_main.cpp</code>(被修改过的app_process)调用了<code>xposed::initialize(zygote, startSystemServer, className, argc, argv)</code>,<code>initialize</code>中又调用了<code>addJarToClasspath()</code>,功能就是将<code>XposedBridge.jar</code>添加到Java classpath!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#define XPOSED_JAR               &quot;/system/framework/XposedBridge.jar&quot;</div><div class="line">/** Add XposedBridge.jar to the Java classpath. */</div><div class="line">bool addJarToClasspath() &#123;</div><div class="line">    ALOGI(&quot;-----------------&quot;);</div><div class="line"></div><div class="line">    if (access(XPOSED_JAR, R_OK) == 0) &#123;</div><div class="line">        if (!addPathToEnv(&quot;CLASSPATH&quot;, XPOSED_JAR))</div><div class="line">            return false;</div><div class="line"></div><div class="line">        ALOGI(&quot;Added Xposed (%s) to CLASSPATH&quot;, XPOSED_JAR);</div><div class="line">        return true;</div><div class="line">    &#125; else &#123;</div><div class="line">        ALOGE(&quot;ERROR: Could not access Xposed jar &apos;%s&apos;&quot;, XPOSED_JAR);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以<code>loadclass</code>在检查<code>apk</code>路径之前系统类加载器就在系统类路径中的<code>XposedBridge.jar</code>中找到了<code>IXposedHookLoadPackage</code>,虽然我们的apk中也有这个函数,但是还没有等到加载就已经结束了.</p>
<p>到这里就可以理清错误为什么发生了:</p>
<ol>
<li>编写模块时我们把<code>XposedBridge.jar</code>编译进了dex文件中;</li>
<li>dalvik在优化dex时为模块类打上了<code>CLASS_ISPREVERIFIED</code>标记,表示没有引用的类全部来自本dex;</li>
<li>xposed框架修改后的app_process会在开机时将<code>/system/framework/XposedBridge.jar</code>加入类路径;</li>
<li>随后xposed要加载我们注册的模块类,在事先为其准备好的jar包中找到了引用的类;</li>
<li>但是模块类被打上标记了,xposed发现模块就没打算用自己准备好的类,反而要自给自足,这哪是框架和模块的关系!简直是造反!于是愤而报错.</li>
</ol>
<p>前面也提到解决方法就是不将<code>XposedBridge.jar</code>编译进dex即可,这样不会被打上标记,万事ok.<br>现在app的热修复原理也是这样.</p>
<h1 id="凌晨4点-startvm"><a href="#凌晨4点-startvm" class="headerlink" title="凌晨4点 startvm"></a>凌晨4点 startvm</h1><p>到了现在,如果不在意一些细节,本案已经被破!</p>
<p>之前说到,当类加载器调用<code>loadclass</code>加载类时发现<code>ChangeStatusBar</code>类已经被校验过…<br>等等!我们的XposedBridge加载模块类的代码是在app_process中呀,而校验是属于dexopt(dex优化)的步骤哇,难道dex优化比app_process这个启动代码还要早?</p>
<p>那么问题就清晰多了: <strong>app_process 和 dexopt 的关系</strong>.</p>
<p>一个app实质上就是一个app_process进程,app_process的作用如下:</p>
<ol>
<li>创建jvm</li>
<li>执行startClass的main方法</li>
</ol>
<p><code>app_main.cpp</code>中的部分添加代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define XPOSED_CLASS_DOTS_ZYGOTE &quot;de.robv.android.xposed.XposedBridge&quot;</div><div class="line">isXposedLoaded = xposed::initialize(zygote, startSystemServer, className, argc, argv);</div><div class="line">if (zygote) &#123;</div><div class="line">    runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : &quot;com.android.internal.os.ZygoteInit&quot;,</div><div class="line">            startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>initialize</code>在上面提到过,而<code>runtime.start</code>就是android源码<a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/jni/AndroidRuntime.cpp#805" target="_blank" rel="external">/frameworks/base/core/jni/AndroidRuntime.cpp</a>中的<code>AndroidRuntime::start</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Start the Android runtime.  This involves starting the virtual machine</div><div class="line"> * and calling the &quot;static void main(String[] args)&quot; method in the class</div><div class="line"> * named by &quot;className&quot;.</div><div class="line"> *</div><div class="line"> * Passes the main function two arguments, the class name and the specified</div><div class="line"> * options string.</div><div class="line"> */</div><div class="line">void AndroidRuntime::start(const char* className, const char* options)</div></pre></td></tr></table></figure>
<p><strong>此函数主要功能是:</strong> 启动虚拟机,执行传入类的main函数<br><strong>流程:</strong> AndroidRuntime::start -&gt; startvm -&gt; 执行传入的类的main函数<br>本案中传入的类是<code>de.robv.android.xposed.XposedBridge</code>.</p>
<p>而startvm中又执行了什么呢?<br>startvm -&gt; JNI_CreateJavaVM -&gt; dvmStartup -&gt; dvmClassStartup -&gt; … -&gt; 直到优化dex时验证class</p>
<p>====&gt; 因此当XposedBridge的main函数执行时,dex中的各个类已经被verify过了.我们的猜想是对哩.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://bugly.qq.com/blog/?p=781" target="_blank" rel="external">【新技能get】让App像Web一样发布新版本</a></p>
<p><a href="http://gold.xitu.io/entry/564ab7eb60b259caed3827f1" target="_blank" rel="external">Android 热补丁动态修复框架小结</a></p>
<p><a href="http://segmentfault.com/a/1190000004062880" target="_blank" rel="external">Android动态加载基础 ClassLoader工作机制</a></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Xposed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一个 Xposed 模块]]></title>
      <url>/2015/12/28/hello-xposed/</url>
      <content type="html"><![CDATA[<p>环境:<br>已root手机一枚(Android 4.4.4)<br>Android Studio一枚</p>
<a id="more"></a>
<p>官方文档参考<a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial-style1" target="_blank" rel="external">这里</a>.</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>我们需要事先下载一个<a href="http://dl-xda.xposed.info/modules/de.robv.android.xposed.installer_v33_36570c.apk-style1" target="_blank" rel="external">Xposed installer</a>安装在手机上,用来管理所有的模块.</p>
<p>安装完成后打开:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/53/02-style1" alt=""></p>
<p>点击<code>框架</code>,</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/53/32-style1" alt=""></p>
<p>点击<code>安装/更新</code>安装框架,</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/53/49-style1" alt=""></p>
<p>点击确定重启,框架界面是这样的:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/54/11-style1" alt=""></p>
<h1 id="编写新模块"><a href="#编写新模块" class="headerlink" title="编写新模块"></a>编写新模块</h1><p>打开android studio,新建工程,选择<code>Add no activity</code></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/54/35-style1" alt=""></p>
<p>新建完成后,找到<code>app</code>目录下的<code>build.gradle</code>文件,将<code>dependencies</code>中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div></pre></td></tr></table></figure>
<p>改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">provided fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div></pre></td></tr></table></figure>
<p>下载<a href="http://forum.xda-developers.com/attachment.php?attachmentid=2748878&amp;d=1400342298-style1" target="_blank" rel="external">XposedBridgeApi-54.jar</a>并放入app目录下的libs文件夹.</p>
<p>在<code>AndroidManifest.xml</code>文件的<code>application</code>中添加如下代码,其中的54是前面下载的文件中的号码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">    android:name=&quot;xposedmodule&quot;</div><div class="line">    android:value=&quot;true&quot; /&gt;</div><div class="line">&lt;meta-data</div><div class="line">    android:name=&quot;xposeddescription&quot;</div><div class="line">    android:value=&quot;kiya&apos;s test module&quot; /&gt;</div><div class="line">&lt;meta-data</div><div class="line">    android:name=&quot;xposedminversion&quot;</div><div class="line">    android:value=&quot;54&quot; /&gt;</div></pre></td></tr></table></figure>
<p>新建一个<code>Test</code>类,写入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package space.kiya.xposedtest;</div><div class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</div><div class="line">import de.robv.android.xposed.XposedBridge;</div><div class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</div><div class="line"></div><div class="line">public class Test implements IXposedHookLoadPackage&#123;</div><div class="line">    @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123;</div><div class="line">        XposedBridge.log(&quot;loaded: &quot; + loadPackageParam.packageName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建<code>assets</code>文件夹,在里面新建文件名为<code>xposed_init</code>,写入刚刚的类名,此处应为<code>space.kiya.xposedtest.Test</code>.</p>
<p>这时就可以编译安装了.</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>因为工程没有activity,所以在桌面上看不到该应用。<br>来到<code>xposed installer</code>的<code>模块</code>中,可以看到我们的模块出现在这里,现在勾选它:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/10/17/03-style1" alt=""></p>
<p>在重启使之生效之前,我们在logcat新建一个tag为<code>Xposed</code>的过滤器,这样就可以过滤出模块输出的log.<br>大概是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Loading Xposed v54(for Zygote)...</div><div class="line">Loading modules from /data/app/space.kiya.xposedtest-1.apk</div><div class="line">  Loading class space.kiya.xposedtest.Test</div><div class="line">Loaded: android</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样的日志在<code>xposed installer</code>的<code>日志</code>中也是可以看到的.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/10/16/42-style1" alt=""></p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><p>如果输出的log中出现了如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation</div></pre></td></tr></table></figure>
<p>说明是前面步骤中没有修改<code>build.gradle</code>导致的.</p>
<p>具体原因见<a href="http://kiya.space/2016/01/03/xposed-class-ispreverified/" target="_blank" rel="external">另一篇博客</a>.</p>
<h1 id="xposed怎样工作"><a href="#xposed怎样工作" class="headerlink" title="xposed怎样工作?"></a>xposed怎样工作?</h1><p>开机时,<code>./init.rc</code>脚本文件会启动<code>Zygote</code>进程,Zygote对应的具体程序是<code>/system/bin/app_process</code>,然后加载需要的类,调用初始化的方法,之后启动的每个应用都是Zygote的拷贝,所以Zygote进程是十分重要的.</p>
<p>通过在类路径中添加一个jar包,在<code>app_process</code>的特定位置调用jar包中的方法,Xposed框架实现了带扩展功能的<code>app_process</code>,然后将原有的<code>app_process</code>替换掉.<br>在<code>/data/data/de.robv.android.xposed.installer/bin/</code>目录下有一个<code>XposedBridge.jar</code>文件,它就是被引用的jar包,源码在<a href="https://github.com/rovo89/XposedBridge-style1" target="_blank" rel="external">github</a>,main函数在<code>/src/de/robv/android/xposed/XposedBridge.java</code>中,每个进程每次启动时都会被调用.加载模块的功能也是在这里实现.</p>
<p>Xposed真正强大的是它可以hook调用的方法.当你反编译修改apk时,你可以在里面插入xposed的命令,于是你就可以在方法调用前后注入自己的代码.</p>
<p>XposedBridge有一个私有的本地方法<code>hookMethodNative</code>,代码实现放在<code>app_process</code>中.在调用被hook的方法前会先调用此方法,<code>hookMethodNative</code>有一个<code>handleHookedMethod</code>方法,可以修改传递给被hook函数的参数,变量甚至是调用其他方法.</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>以上仅仅是证明了我们的xposed模块是可以工作的.现在来修改点什么,比如状态栏上的时间?</p>
<p>在安装源码下的<a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/Clock.java#42" target="_blank" rel="external">/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/Clock.java</a>文件中有一个<code>updateClock</code>函数用来更新时间.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final void updateClock() &#123;</div><div class="line">    if (mDemoMode) return;</div><div class="line">    mCalendar.setTimeInMillis(System.currentTimeMillis());</div><div class="line">    setText(getSmallTime());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码中使用<code>findAndHookMethod</code>函数找到这一函数,并在updateClock函数执行后将<code>TextView</code>的内容重新设置即可.注意在使用前需要这样将其导入:<code>import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</code>.<br>我们的效果是将时间后面加上一个笑脸,颜色设为红色.<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package space.kiya.xposedtest;</div><div class="line"></div><div class="line">import android.graphics.Color;</div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line">import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</div><div class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</div><div class="line">import de.robv.android.xposed.XC_MethodHook;</div><div class="line">import de.robv.android.xposed.XposedBridge;</div><div class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</div><div class="line"></div><div class="line">public class Test implements IXposedHookLoadPackage&#123;</div><div class="line">    @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123;</div><div class="line">        if(loadPackageParam.packageName.equals(&quot;com.android.systemui&quot;))&#123;</div><div class="line">            findAndHookMethod(&quot;com.android.systemui.statusbar.policy.Clock&quot;, loadPackageParam.classLoader, &quot;updateClock&quot;, new XC_MethodHook() &#123;</div><div class="line">                @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</div><div class="line">                    TextView tv = (TextView)param.thisObject;</div><div class="line">                    String text = tv.getText().toString();</div><div class="line">                    tv.setText(text + &quot;:)&quot;);</div><div class="line">                    tv.setTextColor(Color.RED);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/15/34/49-style1" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Xposed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hook - Android ARM下的的so注入]]></title>
      <url>/2015/12/23/hook-call-function-in-so/</url>
      <content type="html"><![CDATA[<p>本文是对<a href="http://www.weibo.com/zhengmin1989" target="_blank" rel="external">大犇蒸米spark</a>的<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a>的实践记录以及知识整理!原文请戳<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">链接</a>.</p>
<a id="more"></a>
<p><strong>被测试代码:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int count = 0;</div><div class="line"></div><div class="line">void print()</div><div class="line">&#123;</div><div class="line">	printf(&quot;hello,%d\n&quot;,count);</div><div class="line">        sleep(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">	while(1)&#123;</div><div class="line">		print();</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注入方法都是通过ptrace实现的.<br>本文代码在<a href="https://github.com/kiya-z/Android/tree/master/hook" target="_blank" rel="external">github</a>.</p>
<h1 id="调用系统so库中的函数"><a href="#调用系统so库中的函数" class="headerlink" title="调用系统so库中的函数"></a>调用系统so库中的函数</h1><p>目标函数是<code>libc.so</code>中的<code>sleep</code>函数.<br>正常情况是每输出一次暂停一秒,现在我们让它暂停10秒.</p>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><ul>
<li>获取目标进程sleep函数地址</li>
<li>在目标进程内执行sleep函数</li>
</ul>
<h2 id="如何获取函数地址"><a href="#如何获取函数地址" class="headerlink" title="如何获取函数地址"></a>如何获取函数地址</h2><ul>
<li><p><strong>已知条件</strong>: 本进程的基址、目标进程的基址、本进程中sleep函数的地址(当然,这些已知条件也是需要获得的 :p)<br><code>/proc/&lt;pid&gt;/maps</code>文件中存储的是进程内存映射详情,我们可以在这个文件中查询进程中so的基址;<br><code>sleep</code>函数在本进程中的地址直接可以获得(<code>void*</code>)</p>
</li>
<li><p><strong>求解</strong>: 目标进程中sleep函数地址</p>
</li>
<li><p><strong>计算</strong>: 本进程sleep地址 - 本进程基址 + 目标进程基址</p>
</li>
</ul>
<h3 id="获取so库的加载基址"><a href="#获取so库的加载基址" class="headerlink" title="获取so库的加载基址"></a>获取so库的加载基址</h3><p>打开<code>/proc/&lt;pid&gt;/maps</code>文件找到基址.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">void* get_module_base(int pid, const char* module_name)</div><div class="line">&#123;</div><div class="line">    FILE *f;		//文件指针</div><div class="line">    long addr = 0;	//模块地址</div><div class="line">    char filename[32];	//maps路径</div><div class="line">    char *pch;</div><div class="line">    char line[1024];	//每行</div><div class="line">    if(pid == 0)&#123;</div><div class="line">        snprintf(filename, sizeof(filename), &quot;/proc/self/maps&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        snprintf(filename, sizeof(filename), &quot;/proc/%d/maps&quot;, pid);</div><div class="line">    &#125;</div><div class="line">    f = fopen(filename, &quot;r&quot;);</div><div class="line">    if(f != NULL)&#123;</div><div class="line">        while(fgets(line,sizeof(line),f))&#123;</div><div class="line">           if(strstr(line, module_name)) &#123;  //找到该行是否含有module_name</div><div class="line">               pch = strtok(line,&quot;-&quot;);  //分割出基址字符串</div><div class="line">               addr = strtoul(pch,NULL,0x10); //转换为16进制数</div><div class="line">               if(addr == 0x8000)   //32位linux程序中默认的text加载地址为0x08408000,64位的改为0x00400000,此时计算base地址就没什么用了</div><div class="line">                   addr = 0;</div><div class="line">               break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fclose(f);</div><div class="line">    &#125;</div><div class="line">    return (void*)addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="计算目标进程中sleep函数地址"><a href="#计算目标进程中sleep函数地址" class="headerlink" title="计算目标进程中sleep函数地址"></a>计算目标进程中sleep函数地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">long get_remote_addr(int target_pid, const char* module_name, void* local_addr)</div><div class="line">&#123;</div><div class="line">    void* local_handle = get_module_base(0,module_name);</div><div class="line">    void* remote_handle = get_module_base(target_pid,module_name);</div><div class="line"></div><div class="line">    printf(&quot;local_handle:%p  remote_handle:%p\n&quot;, local_handle, remote_handle);</div><div class="line"></div><div class="line">    //计算公式</div><div class="line">    long remote_addr = (long)((uint32_t)local_addr - (uint32_t)local_handle + (uint32_t)remote_handle);</div><div class="line"></div><div class="line">    printf(&quot;remote_addr:%p\n&quot;, remote_addr);</div><div class="line">    return remote_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何执行sleep函数"><a href="#如何执行sleep函数" class="headerlink" title="如何执行sleep函数"></a>如何执行sleep函数</h2><ul>
<li>设置函数参数,如果参数个数小于等于4,参数按顺序放入R0~R4寄存器中;如果参数个数大于4,多余的部分需要入栈.</li>
<li>设置pc寄存器的值,设置当前指令集标志位.</li>
<li>应用以上寄存器的修改使之生效.</li>
<li>等待函数执行.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//目标进程id,参数地址,参数个数,寄存器地址</div><div class="line">int ptrace_call(int pid, long addr, long *params, uint32_t params_num, struct pt_regs* regs)</div><div class="line">&#123;</div><div class="line">    uint32_t i;</div><div class="line">    for (i = 0; i &lt; params_num &amp;&amp; i &lt; 4; i++) &#123;     //设置少于4个的参数</div><div class="line">        regs-&gt;uregs[i] = params[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //设置多于4个的参数</div><div class="line">    if (i &lt; params_num) &#123;</div><div class="line">        regs-&gt;ARM_sp -= (params_num - i) * long_size;    //抬高栈顶指针(分配空间)</div><div class="line">        writeData(pid, (long)regs-&gt;ARM_sp, (char*)&amp;params[i], (params_num - i) * long_size); //写入</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    regs-&gt;ARM_pc = addr;    //设置pc</div><div class="line">    if (regs-&gt;ARM_pc &amp; 1) &#123;     //判断是否是Thumb指令</div><div class="line">        regs-&gt;ARM_pc &amp;= (~1u);  //Thumb的pc最后一位总是0</div><div class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;  //T标志位为1</div><div class="line">    &#125; else &#123;    //arm</div><div class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;  //T标志位为0</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    regs-&gt;ARM_lr = 0;   //为了使sleep函数执行完毕后产生“内存访问错误”,这样我们就知道什么时候执行完了</div><div class="line"></div><div class="line">    if(ptrace_setregs(pid,regs)==-1 || ptrace_continue(pid)==-1)&#123;   //目标进程继续执行</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int stat = 0;                   //WUNTRACED表示如果pid进程进入暂停状态，那么waitpid函数立即返回</div><div class="line">    waitpid(pid,&amp;stat,WUNTRACED);   //等待sleep函数执行,等待过程中本进程暂停执行</div><div class="line">    printf(&quot;%d\n&quot;, stat);</div><div class="line">    while (stat != 0xb7f) &#123;     //0xb7f表示目标进程进入暂停状态</div><div class="line">        printf(&quot;%d\n&quot;, stat);</div><div class="line">        if (ptrace_continue(pid) == -1) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        waitpid(pid,&amp;stat,WUNTRACED);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何注入"><a href="#如何注入" class="headerlink" title="如何注入"></a>如何注入</h2><ul>
<li>保存寄存器的值</li>
<li>获得sleep函数地址</li>
<li>执行sleep函数</li>
<li>恢复寄存器的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void inject(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs old_regs,regs;</div><div class="line">    long sleep_addr;</div><div class="line">    //保存寄存器</div><div class="line">    ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs);</div><div class="line">    memcpy(&amp;regs, &amp;old_regs, sizeof(regs));</div><div class="line"></div><div class="line">    long parameters[1];</div><div class="line">    parameters[0] = 10;</div><div class="line">    sleep_addr = get_remote_addr(pid, &quot;libc.so&quot;, (void*)sleep);</div><div class="line">    ptrace_call(pid,sleep_addr,parameters,1,&amp;regs);</div><div class="line">    //恢复寄存器</div><div class="line">    ptrace(PTRACE_SETREGS, pid, NULL, &amp;old_regs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;string.h&gt;  // strstr,strtok</div><div class="line">#include&lt;stdlib.h&gt;  //strtoul</div><div class="line">#include&lt;stdint.h&gt;  //uint32_t</div><div class="line">#include&lt;unistd.h&gt;  //sleep</div><div class="line">#include&lt;sys/ptrace.h&gt;</div><div class="line">#include&lt;linux/wait.h&gt;    // WUNTRACED</div><div class="line">#include&lt;time.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    if(argc != 2)&#123;</div><div class="line">        printf(&quot;usage: %s &lt;pid to be traced&gt;\n&quot;,argv[0]);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    int pid = atoi(argv[1]);</div><div class="line"></div><div class="line">    if(0 != ptrace(PTRACE_ATTACH, pid, NULL, NULL))&#123;</div><div class="line">        printf(&quot;attach failed.&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    inject(pid);</div><div class="line"></div><div class="line">    ptrace(PTRACE_DETACH, pid, NULL, NULL);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><h2 id="proc-lt-pid-gt-文件夹"><a href="#proc-lt-pid-gt-文件夹" class="headerlink" title="/proc/&lt;pid&gt; 文件夹"></a>/proc/&lt;pid&gt; 文件夹</h2><table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmdline</td>
<td>命令行全名(加参数变量)和 ps 命令中的command 列结果一样</td>
</tr>
<tr>
<td>cwd</td>
<td>进程的工作目录 和 (pwdx PID) 结果相同</td>
</tr>
<tr>
<td>environ</td>
<td>进程的环境变量</td>
</tr>
<tr>
<td>exe</td>
<td>一般是/bin/ 的链接</td>
</tr>
<tr>
<td>fd</td>
<td>进程打开的文件描述fu .用ls -l 可以查看具体的文件 (可以用lsof -p PID)</td>
</tr>
<tr>
<td>status</td>
<td>进程的相关状态</td>
</tr>
<tr>
<td>task</td>
<td>该目录下是进程所包含的线程(note: ps 可以查看线程)</td>
</tr>
<tr>
<td>mounts</td>
<td>进程挂载点</td>
</tr>
<tr>
<td>maps</td>
<td>进程内存映射详情</td>
</tr>
</tbody>
</table>
<h2 id="关于pc寄存器"><a href="#关于pc寄存器" class="headerlink" title="关于pc寄存器"></a>关于pc寄存器</h2><p><a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf" target="_blank" rel="external">arm.pdf</a> 中的<strong>A2.4.3 Register 15 and the program counter</strong>有这样一段话:<br>是关于指令集在pc寄存器上的表现的.</p>
<blockquote>
<p>Reading the program counter<br>When an instruction reads the PC, the value read depends on which instruction set it comes from:<br>• For an ARM instruction, the value read is the address of the instruction plus 8 bytes. Bits [1:0] of this<br>value are always zero, because ARM instructions are always word-aligned.<br>• For a Thumb instruction, the value read is the address of the instruction plus 4 bytes. Bit [0] of this<br>value is always zero, because Thumb instructions are always halfword-aligned.</p>
</blockquote>
<h2 id="关于CPSR寄存器"><a href="#关于CPSR寄存器" class="headerlink" title="关于CPSR寄存器"></a>关于CPSR寄存器</h2><table>
<thead>
<tr>
<th>31</th>
<th>30</th>
<th>29</th>
<th>28</th>
<th>27</th>
<th>26  25</th>
<th>24</th>
<th>23 20</th>
<th>19 16</th>
<th>15 10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>Z</td>
<td>C</td>
<td>V</td>
<td>Q</td>
<td>Res</td>
<td>J</td>
<td>RESERVED</td>
<td>GE[3:0]</td>
<td>RESERVED</td>
<td>E</td>
<td>A</td>
<td>I</td>
<td>F</td>
<td>T</td>
<td>M[4:0]</td>
</tr>
</tbody>
</table>
<p>其中J和T标记位代表当前指令集:</p>
<table>
<thead>
<tr>
<th>J</th>
<th>T</th>
<th>Instruction set</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>ARM</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Thumb</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Jazelle</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>RESERVED</td>
</tr>
</tbody>
</table>
<h2 id="关于waitpid"><a href="#关于waitpid" class="headerlink" title="关于waitpid"></a>关于waitpid</h2><p>详细介绍可看<a href="https://support.sas.com/documentation/onlinedoc/sasc/doc/lr2/wait.htm" target="_blank" rel="external">官方文档</a>.</p>
<h3 id="参数status"><a href="#参数status" class="headerlink" title="参数status"></a>参数status</h3><p><code>wait</code>函数调用过后,<code>status</code>指针指向可以被宏解析的值,这些宏在ndk目录下<code>platforms/android-21/arch-arm/usr/include/sys/wait.h</code>文件中定义.</p>
<p>高2字节用于表示导致子进程的退出或暂停状态信号值(<code>WTERMSIG</code>)，低2字节表示子进程是退出(0x0)还是暂停(0x7f)状态(<code>WEXITSTATUS</code>)。<br>如:0xb7f就表示子进程为暂停状态，导致它暂停的信号量为11即<code>sigsegv</code>错误。<br>关于错误代码的文档可看<a href="https://support.sas.com/documentation/onlinedoc/sasc/doc/lr1/lrv1ch5.htm" target="_blank" rel="external">这里</a>,<br>定义在ndk目录下<code>platforms/android-21/arch-arm/usr/include/asm/signal.h</code>中.</p>
<blockquote>
<p>其中两个宏:<br>WEXITSTATUS(*statusPtr):<br>if the child process terminates normally, this macro evaluates to the lower 8 bits of the value passed to the exit or _exit function or returned from main.<br>WTERMSIG(*statusPtr)<br>if the child process ends by a signal that was not caught, this macro evaluates to the number of that signal.</p>
</blockquote>
<h3 id="参数options"><a href="#参数options" class="headerlink" title="参数options"></a>参数options</h3><p>指定了<code>waitpid</code>的额外行动.选项有:</p>
<p><strong>WNOHANG</strong>:<br>告诉<code>waitpid</code>不等程序中止立即返回<code>status</code>信息.<br>正常情况是当主进程对子进程使用了<code>waitpid</code>,主进程就会阻塞直到<code>waitpid</code>返回<code>status</code>信息;如果指定了<code>WNOHANG</code>选项,主进程就不会阻塞了.<br>如果还没有可用的<code>status</code>信息,<code>waitpid</code>返回0.</p>
<p><strong>WUNTRACED</strong>:<br>告诉<code>waitpid</code>，如果子进程进入暂停状态或者已经终止，那么就立即返回<code>status</code>信息,正常情况是紫禁城终止的时候才返回.<br>如果是被ptrace的子进程，那么即使不提供WUNTRACED参数，也会在子进程进入暂停状态的时候立即返回。<br>对于使用<code>ptrace_cont</code>运行的子进程，它会在3种情况下进入暂停状态：①下一次系统调用；②子进程退出；③子进程的执行发生错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>程序中的<code>0xb7f</code>就表示子进程进入了暂停状态，且发送的错误信号为11(SIGSEGV)，它表示试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。<br>当子进程执行完注入的函数后，由于我们在前面设置了regs-&gt;ARM_lr = 0，它就会返回到0地址处继续执行，这样就会产生SIGSEGV了.</p>
<h1 id="调用自定义so库中的函数"><a href="#调用自定义so库中的函数" class="headerlink" title="调用自定义so库中的函数"></a>调用自定义so库中的函数</h1><ul>
<li>保存当前寄存器的状态</li>
<li>获取目标程序的mmap, dlopen, dlsym, dlclose函数地址</li>
<li>调用mmap分配空间保存参数信息</li>
<li>调用dlopen加载so库</li>
<li>调用dlsym找到目标函数地址</li>
<li>执行目标函数</li>
<li>调用dlclose卸载so库</li>
<li>恢复寄存器的状态</li>
</ul>
<h2 id="保存当前寄存器的状态"><a href="#保存当前寄存器的状态" class="headerlink" title="保存当前寄存器的状态"></a>保存当前寄存器的状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct pt_regs old_regs,regs;</div><div class="line">ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs);</div><div class="line">memcpy(&amp;regs,&amp;old_regs,sizeof(regs));</div></pre></td></tr></table></figure>
<h2 id="获取目标程序的mmap-dlopen-dlsym-dlclose函数地址"><a href="#获取目标程序的mmap-dlopen-dlsym-dlclose函数地址" class="headerlink" title="获取目标程序的mmap, dlopen, dlsym, dlclose函数地址"></a>获取目标程序的mmap, dlopen, dlsym, dlclose函数地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">long mmap_addr,dlopen_addr,dlsym_addr,dlclose_addr;</div><div class="line">mmap_addr = get_remote_addr(pid, libc_path, (void*)mmap);</div><div class="line">dlopen_addr = get_remote_addr(pid, libc_path, (void*)dlopen);</div><div class="line">dlsym_addr = get_remote_addr(pid, libc_path, (void*)dlsym);</div><div class="line">dlclose_addr = get_remote_addr(pid, libc_path, (void*)dlclose);</div></pre></td></tr></table></figure>
<h2 id="调用mmap分配空间保存参数信息"><a href="#调用mmap分配空间保存参数信息" class="headerlink" title="调用mmap分配空间保存参数信息"></a>调用mmap分配空间保存参数信息</h2><p>mmap的原型如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>addr</td>
<td>映射的起始地址,为0表示由系统决定映射的起始地址</td>
</tr>
<tr>
<td>length</td>
<td>映射的长度</td>
</tr>
<tr>
<td>prot</td>
<td>映射的内存保存属性,不能与文件的打开模式冲突</td>
</tr>
<tr>
<td>flags</td>
<td>指定映射对象的类型,映射选项和映射页是否可以共享</td>
</tr>
<tr>
<td>fd</td>
<td>有效的文件描述符,一般是由open()函数返回;其值也可以设置为-1,此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射</td>
</tr>
<tr>
<td>offset</td>
<td>被映射对象内容的起点</td>
</tr>
</tbody>
</table>
<p>这里我们需要的调用语句是<code>mmap(0,0x4000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE,0,0)</code>,<br><code>PROT_EXEC</code>表示可执行.<br><code>PROT_READ</code>表示可读.<br><code>PROT_WRITE</code>表示可写.<br><code>MAP_PRIVATE</code>表示建.立一个写入时拷贝的私有映射.内存区域的写入不会影响到原文件.这个标志和以上标志是互斥的,只能使用其中一个.<br><code>MAP_ANONYMOUS</code>表示匿名映射,映射区不与任何文件关联.<br>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">long parameters[10];    </div><div class="line">parameters[0] = 0;  //构造参数</div><div class="line">parameters[1] = 0x4000;</div><div class="line">parameters[2] = PROT_READ | PROT_WRITE | PROT_EXEC;</div><div class="line">parameters[3] = MAP_ANONYMOUS | MAP_PRIVATE;</div><div class="line">parameters[4] = 0;</div><div class="line">parameters[5] = 0;</div><div class="line">ptrace_call(pid,mmap_addr,parameters,6,&amp;regs);</div><div class="line">//调用结束后获得r0中保存的返回值</div><div class="line">ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">long mapping_base = regs.ARM_r0;</div></pre></td></tr></table></figure>
<h2 id="调用dlopen加载so库"><a href="#调用dlopen加载so库" class="headerlink" title="调用dlopen加载so库"></a>调用dlopen加载so库</h2><p><strong>原型:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *dlopen(const char *filename, int flags);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>so库名</td>
</tr>
<tr>
<td>flags</td>
<td>打开方式</td>
</tr>
</tbody>
</table>
<p>这里我们需要的调用语句是<code>dlopen(so_path,RTLD_NOW | RTLD_GLOBAL)</code>,<br><code>RTLD_NOW</code>表示需要在dlopen返回前,解析出所有未定义符号,如果解析不出来在dlopen会返回NULL;<br><code>RTLD_GLOBAL</code>表示动态库中定义的符号可被其后打开的其它库解析.<br>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">writeData(pid, mapping_base, so_path, strlen(so_path)+1);   //将库名字符串放入目标进程空间</div><div class="line">parameters[0] = mapping_base;</div><div class="line">parameters[1] = RTLD_NOW | RTLD_GLOBAL;</div><div class="line">ptrace_call(pid, dlopen_addr, parameters, 2, &amp;regs);</div><div class="line">ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);  //调用结束后获得r0中保存的返回值</div><div class="line">long handle = regs.ARM_r0;</div></pre></td></tr></table></figure>
<h2 id="调用dlsym找到目标函数地址"><a href="#调用dlsym找到目标函数地址" class="headerlink" title="调用dlsym找到目标函数地址"></a>调用dlsym找到目标函数地址</h2><p>原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *dlsym(void *handle, const char *symbol);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>handle</td>
<td>so库的基址</td>
</tr>
<tr>
<td>symbol</td>
<td>函数名地址</td>
</tr>
</tbody>
</table>
<p>这里我们需要的调用语句是<code>dlsym(handle, function_name)</code>,则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">writeData(pid, mapping_base, function_name, strlen(function_name)+1);</div><div class="line">parameters[0] = handle;</div><div class="line">parameters[1] = mapping_base;</div><div class="line">ptrace_call(pid, dlsym_addr, parameters, 2, &amp;regs);</div><div class="line">ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);  //调用结束后获得r0中保存的返回值</div><div class="line">long function_addr = regs.ARM_r0;</div></pre></td></tr></table></figure>
<h2 id="执行目标函数"><a href="#执行目标函数" class="headerlink" title="执行目标函数"></a>执行目标函数</h2><p>先写段c程序编译为so文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">void hello(char *str)</div><div class="line">&#123;</div><div class="line">    printf(&quot;hello %s\n&quot;,str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">writeData(pid, mapping_base, function_parameters, strlen(function_parameters)+1);</div><div class="line">parameters[0] = mapping_base;</div><div class="line">ptrace_call(pid, function_addr, parameters, 1, &amp;regs);</div></pre></td></tr></table></figure>
<h2 id="调用dlclose卸载so库"><a href="#调用dlclose卸载so库" class="headerlink" title="调用dlclose卸载so库"></a>调用dlclose卸载so库</h2><p>原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int dlclose(void *handle);</div></pre></td></tr></table></figure>
<p>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parameters[0] = handle;</div><div class="line">ptrace_call(pid,dlclose_addr,parameters,1,&amp;regs);</div></pre></td></tr></table></figure>
<h2 id="恢复寄存器的状态"><a href="#恢复寄存器的状态" class="headerlink" title="恢复寄存器的状态"></a>恢复寄存器的状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptrace(PTRACE_SETREGS,pid,NULL,&amp;old_regs);</div></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a></p>
<p><a href="http://blog.csdn.net/jinzhuojun/article/details/9900105" target="_blank" rel="external">Android中的so注入(inject)和挂钩(hook) - For both x86 and arm</a></p>
<p><a href="http://www.cnblogs.com/wanyuanchun/p/4020756.html" target="_blank" rel="external">Android注入完全剖析</a></p>
<p><a href="http://segmentfault.com/a/1190000000606904" target="_blank" rel="external">http://segmentfault.com/a/1190000000606904</a></p>
<p><a href="http://www.sanwho.com/133.html" target="_blank" rel="external">Android下so注入汇总</a></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hook </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python爬虫 - 登录csdn]]></title>
      <url>/2015/12/22/csdn-login/</url>
      <content type="html"><![CDATA[<p>使用<code>urllib2</code>、<code>BeautifulSoup</code>和<code>CookieJar</code>实现登录.</p>
<a id="more"></a>
<p>使用charles抓包找到post的login网址: <code>https://passport.csdn.net/account/login</code></p>
<p>再来看看post的参数:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/22/16/26/16" alt=""></p>
<p>哎呀这里的密码竟然是明文..</p>
<p>username、password和_eventId好说,只是lt和execution在哪里获得呢?</p>
<p>我们来看一下紧挨着的GET请求返回的html代码,这里竟然还有注释哇哇:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/22/16/29/43" alt=""></p>
<p>好,那么现在总结一下 <strong>步骤</strong>:</p>
<ol>
<li>对<code>https://passport.csdn.net/account/login</code>进行get请求,在html代码中获得lt和execution;</li>
<li>表单创建</li>
<li>带上POST表单,进行POST请求</li>
</ol>
<p><strong>代码如下:</strong></p>
<p>获取 lt 和 execution:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cookie = cookielib.MozillaCookieJar(&apos;cookie.txt&apos;)   # MozillaCookieJar可保存cookie</div><div class="line">cookie_handler = urllib2.HTTPCookieProcessor(cookie)</div><div class="line">opener = urllib2.build_opener(cookie_handler)</div><div class="line"># prepare for login</div><div class="line">response = opener.open(&apos;https://passport.csdn.net/account/login&apos;)</div><div class="line">data = response.read()</div><div class="line">lt = &quot;&quot;</div><div class="line">execution = &quot;&quot;</div><div class="line">bs = BeautifulSoup(response.read(),&quot;lxml&quot;)</div><div class="line">for input in bs.form.find_all(&apos;input&apos;):</div><div class="line">    if input.get(&apos;name&apos;) == &apos;lt&apos;:</div><div class="line">        lt = input.get(&apos;value&apos;)</div><div class="line">    if input.get(&apos;name&apos;) == &apos;execution&apos;:</div><div class="line">        execution = input.get(&apos;value&apos;)</div></pre></td></tr></table></figure>
<p><strong>表单</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">post_data = urllib.urlencode(&#123;</div><div class="line">    &apos;username&apos; : &apos;xxxx&apos;,</div><div class="line">    &apos;password&apos; : &apos;xxxx&apos;,</div><div class="line">    &apos;lt&apos; : lt,</div><div class="line">    &apos;execution&apos; : execution,</div><div class="line">    &apos;_eventId&apos; : &apos;submit&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>POST地址</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">login_url = &apos;https://passport.csdn.net/account/login&apos;</div></pre></td></tr></table></figure>
<p><strong>POST</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request = urllib2.Request(url = login_url,data=post_data)</div><div class="line">try:</div><div class="line">    response = opener.open(request)</div><div class="line">except urllib2.HTTPError as e:</div><div class="line">    print e.read()</div></pre></td></tr></table></figure>
<p><strong>GET其他网址验证</strong>:</p>
<p>注意这里的request请求需要带上headers,否则会报<code>403 forbidden</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">headers_data = &#123;</div><div class="line">    &apos;User-Agent&apos; :	&apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:42.0) Gecko/20100101 Firefox/42.0&apos;</div><div class="line">&#125;</div><div class="line">request = urllib2.Request(url = &apos;http://blog.csdn.net/attach_114&apos;,headers=headers_data)</div><div class="line">print opener.open(request).read()</div></pre></td></tr></table></figure>
<p><strong>完整代码:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">#coding:utf-8</div><div class="line">import urllib</div><div class="line">import urllib2</div><div class="line">import cookielib</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">from pass_csdn import username,password</div><div class="line">cookie = cookielib.MozillaCookieJar(&apos;cookie.txt&apos;)</div><div class="line">cookie_handler = urllib2.HTTPCookieProcessor(cookie)</div><div class="line">opener = urllib2.build_opener(cookie_handler)</div><div class="line">def login():</div><div class="line">    # prepare for login</div><div class="line">    response = opener.open(&apos;https://passport.csdn.net/account/login&apos;)</div><div class="line">    lt = &quot;&quot;</div><div class="line">    execution = &quot;&quot;</div><div class="line">    bs = BeautifulSoup(response.read(),&quot;lxml&quot;)</div><div class="line">    for input in bs.form.find_all(&apos;input&apos;):</div><div class="line">        if input.get(&apos;name&apos;) == &apos;lt&apos;:</div><div class="line">            lt = input.get(&apos;value&apos;)</div><div class="line">        if input.get(&apos;name&apos;) == &apos;execution&apos;:</div><div class="line">            execution = input.get(&apos;value&apos;)</div><div class="line">    post_data = urllib.urlencode(&#123;</div><div class="line">        &apos;username&apos; : username,</div><div class="line">        &apos;password&apos; : password,</div><div class="line">        &apos;lt&apos; : lt,</div><div class="line">        &apos;execution&apos; : execution,</div><div class="line">        &apos;_eventId&apos; : &apos;submit&apos;</div><div class="line">    &#125;)</div><div class="line">    headers_data = &#123;</div><div class="line">        &apos;User-Agent&apos; :	&apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:42.0) Gecko/20100101 Firefox/42.0&apos;</div><div class="line">    &#125;</div><div class="line">    login_url_with_jsession = &apos;https://passport.csdn.net/account/login&apos;</div><div class="line">    request = urllib2.Request(url = login_url_with_jsession,data=post_data)</div><div class="line">    try:</div><div class="line">        response = opener.open(request)</div><div class="line">    except urllib2.HTTPError as e:</div><div class="line">        print e.read()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    login()</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hook - 拦截系统调用]]></title>
      <url>/2015/12/21/hook-syscall/</url>
      <content type="html"><![CDATA[<p>本文是对<a href="http://www.weibo.com/zhengmin1989" target="_blank" rel="external">大犇蒸米spark</a>的<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a>的实践记录以及知识整理!原文请戳<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">链接</a>.</p>
<a id="more"></a>
<p>实现hook就离不开<a href="http://kiya.space/2015/12/18/ptrace-basis/" target="_blank" rel="external">ptrace</a>.</p>
<h1 id="ARM上的系统调用"><a href="#ARM上的系统调用" class="headerlink" title="ARM上的系统调用"></a>ARM上的系统调用</h1><p>系统调用由SWI实现,即软件中断(Software Interrupt),在请求系统服务时造成的中断,由SWI指令造成异常从而切入特权模式,从而允许非特权模式访问特权模式的函数.</p>
<p>ARM中有两种系统调用方式: OABI(old application binary interface)和EABI(extended application binary interface).见(内核源码arch/arm/kernel/entry-common.S文件).</p>
<p>对于OABI: 通过跟随在swi指令后的调用号来进行. <code>1101 1111 vvvv vvvv -- SWI immed_8</code> (Thumb指令)格式)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swi (#num | 0x900000) (0x900000是个magic值)</div></pre></td></tr></table></figure></p>
<p>对于EABI: 调用号存放在r7中. <code>1110 1111 0000 0000 -- SWI 0</code> (Thumb指令格式)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov r7, #num</div><div class="line">swi 0x0</div></pre></td></tr></table></figure></p>
<p>在 <a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf" target="_blank" rel="external">arm.pdf</a>的 <strong>A4.1.107 SWI</strong> 和 <strong>A7.1.69 SWI</strong> 分别是对ARM和Thumb中SWI的描述.</p>
<p>所有的系统调用号在<code>arch/arm/include/asm/unistd.h</code>文件.</p>
<p>所以在得到一条SWI指令时,要解析出系统调用号得分两种情况:<br>这里的源程序直接按ARM指令集处理了,没有做判断thumb的处理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if(ins == 0xef000000)&#123;      //直接和指令比较</div><div class="line">    return regs-&gt;ARM_r7;</div><div class="line">&#125;else&#123;</div><div class="line">    if((ins &amp; 0x0ff00000) != 0x0f900000)&#123;   //和magic值比较,这里我认为前面两位0f改成别的值也是可以的,重要的是magic值</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    return ins &amp;= 0x000fffff;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="拦截系统调用"><a href="#拦截系统调用" class="headerlink" title="拦截系统调用"></a>拦截系统调用</h1><p><strong>整个思路是:</strong></p>
<p>使被调试程序在下次次调用系统函数前后停下(SYSCALL),这时调试程序对被调试进行操作(PTRACE_PEEKTEXT/PTRACE_GETREGS…),随后使被调试程序继续运行(SYSCALL),调试程序等待(wait).</p>
<p><strong>被调试程序:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">int count = 0;</div><div class="line">void print()</div><div class="line">&#123;</div><div class="line">	printf(&quot;hello,%d\n&quot;,count);</div><div class="line">        sleep(1);</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">	while(1)&#123;</div><div class="line">		print();</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>调试程序:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;sys/ptrace.h&gt;  //头文件路径根据ndk目录下/platforms/android-21/arch-arm/usr/include</div><div class="line">#include&lt;asm/unistd.h&gt;</div><div class="line">long getSystemCallNumber(int pid, struct pt_regs *regs)</div><div class="line">&#123;</div><div class="line">    long ins = 0;</div><div class="line">    ins = ptrace(PTRACE_PEEKTEXT, pid, (void *)(regs-&gt;ARM_pc - 4), NULL);   //r15-4</div><div class="line">    if(ins == 0)&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if(ins == 0xef000000)&#123;      //EABI</div><div class="line">        return regs-&gt;ARM_r7;</div><div class="line">    &#125;else&#123;</div><div class="line">        if((ins &amp; 0x0ff00000) != 0x0f900000)&#123;   //OABI</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        return ins &amp;= 0x000fffff;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void doSthBefore(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs regs;</div><div class="line">    int sysCallNumber = 0;</div><div class="line">    ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">    sysCallNumber = getSystemCallNumber(pid,&amp;regs);</div><div class="line">    printf(&quot;before syscallno: %d\n&quot;, sysCallNumber);</div><div class="line">    if(sysCallNumber == __NR_write)&#123;    //得到参数</div><div class="line">        printf(&quot;__NR_write &lt;&lt; %ld, %p, %ld\n&quot;,regs.ARM_r0, (void*)regs.ARM_r1, regs.ARM_r2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void doSthAfter(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs regs;</div><div class="line">    int sysCallNumber = 0;</div><div class="line">    ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">    sysCallNumber = getSystemCallNumber(pid,&amp;regs);</div><div class="line">    printf(&quot;after syscallno: %d\n&quot;, sysCallNumber);</div><div class="line">    if(sysCallNumber == __NR_write)&#123;</div><div class="line">        printf(&quot;__NR_write &gt;&gt; %ld\n&quot;,regs.ARM_r0);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    if(argc != 2)&#123;</div><div class="line">        printf(&quot;usage: %s &lt;pid to be traced&gt;\n&quot;,argv[0]);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    int pid = atoi(argv[1]);</div><div class="line">    if(0 != ptrace(PTRACE_ATTACH, pid, NULL, NULL))&#123;</div><div class="line">        printf(&quot;attach failed.&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);    //使之在系统调用前后停下</div><div class="line">    int status;</div><div class="line">    while(1)&#123;</div><div class="line">        wait(&amp;status);</div><div class="line">        doSthBefore(pid);</div><div class="line">        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);</div><div class="line">        wait(&amp;status);</div><div class="line">        doSthAfter(pid);</div><div class="line">        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);</div><div class="line">    &#125;</div><div class="line">    ptrace(PTRACE_DETACH, pid, NULL, NULL);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结果:</strong></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/19/16/20/25" alt=""></p>
<h1 id="修改函数参数"><a href="#修改函数参数" class="headerlink" title="修改函数参数"></a>修改函数参数</h1><p>修改printf的参数:字符串及其长度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">#define long_size 4</div><div class="line">void readData(int pid, long addr, char *str, int len)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    char *laddr;</div><div class="line">    union u&#123;</div><div class="line">        long val;</div><div class="line">        char chars[long_size];</div><div class="line">    &#125;data;</div><div class="line">    i = 0;</div><div class="line">    j = len / long_size;</div><div class="line">    laddr = str;</div><div class="line">    while (i &lt; j) &#123;</div><div class="line">        data.val = ptrace(PTRACE_PEEKDATA, pid, addr+i*4, NULL);    //PEEKDATA一次读一个字</div><div class="line">        memcpy(laddr,data.chars,long_size);</div><div class="line">        laddr += long_size;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    j = len % long_size;</div><div class="line">    if (j != 0) &#123;</div><div class="line">        data.val = ptrace(PTRACE_PEEKDATA, pid, addr+i*4, NULL);    //PEEKDATA一次读一个字</div><div class="line">        memcpy(laddr,data.chars,long_size);</div><div class="line">    &#125;</div><div class="line">    str[len] = &apos;\0&apos;;</div><div class="line">&#125;</div><div class="line">void writeData(int pid, long addr, char *str, int len)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    char *laddr;</div><div class="line">    union u&#123;</div><div class="line">        long val;</div><div class="line">        char chars[long_size];</div><div class="line">    &#125;data;</div><div class="line">    i = 0;</div><div class="line">    j = len / long_size;</div><div class="line">    laddr = str;</div><div class="line">    while (i &lt; j) &#123;</div><div class="line">        memcpy(data.chars,laddr,long_size);</div><div class="line">        ptrace(PTRACE_POKEDATA, pid, addr+i*4, data.val);    //PEEKDATA一次写一个字</div><div class="line">        laddr += long_size;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    j = len % long_size;</div><div class="line">    if (j != 0) &#123;</div><div class="line">        memcpy(data.chars,laddr,j);</div><div class="line">        ptrace(PTRACE_POKEDATA, pid, addr+i*4, data.val);    //POKEDATA一次写一个字</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void strrev(char *p)</div><div class="line">&#123;</div><div class="line">  char *q = p;</div><div class="line">  while(q &amp;&amp; *q) ++q;</div><div class="line">  for(--q; p &lt; q; ++p, --q)</div><div class="line">    *p = *p ^ *q,</div><div class="line">    *q = *p ^ *q,</div><div class="line">    *p = *p ^ *q;</div><div class="line">&#125;</div><div class="line">void modifyString(int pid,long addr,long len)</div><div class="line">&#123;</div><div class="line">    char *str;</div><div class="line">    str = (char*)calloc(sizeof(char)*(len+1),1);</div><div class="line">    readData(pid,addr,str,len);</div><div class="line">    strrev(str);</div><div class="line">    writeData(pid,addr,str,len);</div><div class="line">&#125;</div><div class="line">void doSthBefore(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs regs;</div><div class="line">    int sysCallNumber = 0;</div><div class="line">    ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">    sysCallNumber = getSystemCallNumber(pid,&amp;regs);</div><div class="line">    printf(&quot;before syscallno: %d\n&quot;, sysCallNumber);</div><div class="line">    if(sysCallNumber == __NR_write)&#123;</div><div class="line">        printf(&quot;__NR_write &lt;&lt; %ld, %p, %ld\n&quot;,regs.ARM_r0, (void*)regs.ARM_r1, regs.ARM_r2);</div><div class="line">        modifyString(pid,regs.ARM_r1,regs.ARM_r2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a></p>
<p><a href="http://www.xuebuyuan.com/706076.html" target="_blank" rel="external">Android ptrace简介</a></p>
<p><a href="http://blog.csdn.net/ce123/article/details/6925375" target="_blank" rel="external">浅谈EABI和OABI</a></p>
<p><a href="http://blog.csdn.net/myarrow/article/details/7036266" target="_blank" rel="external">Arm Linux系统调用流程详细解析-SWI</a></p>
<p><a href="http://bbs.pediy.com/showthread.php?t=196435" target="_blank" rel="external">linux arm 系统调用</a></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hook </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[反调试方法二 - 抢占ptrace]]></title>
      <url>/2015/12/18/ptrace-basis/</url>
      <content type="html"><![CDATA[<blockquote>
<p>The ptrace() system call provides a means by which one process (the”tracer”) may observe and control the execution of another process(the “tracee”), and examine and change the tracee’s memory andregisters.  It is primarily used to implement breakpoint debugging and system call tracing.</p>
</blockquote>
<p>帮助文档<a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="external">online</a>.</p>
<a id="more"></a>
<h1 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h1><p><code>ptrace</code>可以让一个进程监视和控制另一个进程的执行,并且修改被监视进程的内存、寄存器等,主要应用于断点调试和系统调用跟踪.</p>
<p>函数原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long ptrace(int request, pid_t pid, void * addr, void * data)</div></pre></td></tr></table></figure></p>
<p>其中,request代表请求类型,pid代表被调试进程的pid.</p>
<blockquote>
<p>ptrace建立跟踪关系的两种方式:</p>
<ol>
<li>fork:<br>利用fork+execve执行被测试的程序，子进程在执行execve之前调用ptrace(PTRACE_TRACEME)，建立了与父进程(debugger)的跟踪关系。</li>
<li>attach: debugger可以调用ptrace(PTRACE_ATTACH，pid,…)，建立自己与进程号为pid的进程间的跟踪关系。<br>即利用PTRACE_ATTACH，使自己变成被调试程序的父进程(用ps可以看到)。用attach建立起来的跟踪关系，可以调用ptrace(PTRACE_DETACH，pid,…)来解除。注意attach进程时的权限问题，如一个非root权限的进程是不能attach到一个root进程上的。</li>
</ol>
</blockquote>
<p>有信号发生时,被调试进程就会暂停下来,并且通知调试进程.调试进程可以调用waitpid()获得被调试进程暂停位置的相关信息.<br>在被调试进程暂停的期间,调试进程可以各种ptrace request来对被调试进程进行操作,查看、修改、使之继续运行、忽略该信号甚至发送信号.</p>
<h1 id="部分ptrace-request"><a href="#部分ptrace-request" class="headerlink" title="部分ptrace request"></a>部分ptrace request</h1><h2 id="PTRACE-TRACEME"><a href="#PTRACE-TRACEME" class="headerlink" title="PTRACE_TRACEME"></a>PTRACE_TRACEME</h2><p>将当前进程切换到停止状态。它通常总是与 fork/exec 一起使用。对于每一个进程，PTRACE_TRACEME 只能被调用一次。</p>
<h2 id="PTRACE-ATTACH"><a href="#PTRACE-ATTACH" class="headerlink" title="PTRACE_ATTACH"></a>PTRACE_ATTACH</h2><p>根据pid将被调试进程附加到调试进程上,PTRACE_ATTACH向被调试进程发送SIGSTOP信号使之停下.<br>但是在<code>ptrace(PTRACE_ATTACH,pid,0,0)</code>执行完毕时被调试进程可能还没有暂停,可以使用<code>waitpid()</code>等待其停下.</p>
<h2 id="PTRACE-DETACH"><a href="#PTRACE-DETACH" class="headerlink" title="PTRACE_DETACH"></a>PTRACE_DETACH</h2><p>将被调试进程与调试进程分离,使被调试进程正常运行.</p>
<h2 id="PTRACE-SYSCALL"><a href="#PTRACE-SYSCALL" class="headerlink" title="PTRACE_SYSCALL"></a>PTRACE_SYSCALL</h2><p>使被调试进程继续运行,但是在下一个系统调用的入口处或出口处停下,或者是执行完一条指令后停下.<br>例如,调试进程可以监视被调试进程系统调用入口处的参数,接着再使用SYSCALL,监视系统调用的返回值.</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait函数会延迟父进程的执行，直到被调试的进程切换为停止状态或者终止为止.</p>
<h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><p>ptrace被广泛用于反调试,因为一个进程只能被ptrace一次,如果事先调用了ptrace方法,那就可以防止别人调试我们的程序.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;sys/ptrace.h&gt;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    ptrace(PTRACE_TRACEME);</div><div class="line">    while(1)&#123;</div><div class="line">        printf(&quot;Hello Ptrace!\n&quot;);</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译:<code>gcc -g -o hello-ptrace hello-ptrace.c</code></p>
<p>运行:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/18/16/07/45" alt=""></p>
<p>另开命令行调试:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/18/15/59/52" alt=""></p>
<h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;sys/ptrace.h&gt;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    if(-1 == ptrace(PTRACE_TRACEME))</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Debugger!\n&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;Hello Ptrace!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="反反调试"><a href="#反反调试" class="headerlink" title="反反调试"></a>反反调试</h1><p><code>ptrace</code>用户态源码(位于bionic/libc/bionic/ptrace.c):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">long ptrace(int request, pid_t pid, void * addr, void * data)</div><div class="line">&#123;</div><div class="line">    switch (request) &#123;</div><div class="line">        case PTRACE_PEEKUSR:</div><div class="line">        case PTRACE_PEEKTEXT:</div><div class="line">        case PTRACE_PEEKDATA:</div><div class="line">        &#123;</div><div class="line">            long word;</div><div class="line">            long ret;</div><div class="line">            ret = __ptrace(request, pid, addr, &amp;word);</div><div class="line">            if (ret == 0) &#123;</div><div class="line">                return word;</div><div class="line">            &#125; else &#123;</div><div class="line">                // __ptrace will set errno for us</div><div class="line">                return -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        default:</div><div class="line">             return __ptrace(request, pid, addr, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0表示成功,-1表示错误.</p>
<ul>
<li><p>单个应用可在ptrace下断点.</p>
</li>
<li><p>定制ROM,可以将ptrace源代码修改为<code>如果是自己的pid调用ptrace,返回-1;否则返回0</code>.</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.xuebuyuan.com/706076.html" target="_blank" rel="external">Android ptrace简介</a></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> anti-debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[脱壳基础 dvmDexFileOpenPartial]]></title>
      <url>/2015/12/16/unshell-basic/</url>
      <content type="html"><![CDATA[<p>栗子<a href="https://github.com/kiya-z/Android/blob/master/lab-mouse/shell-protect-1.apk" target="_blank" rel="external">在此</a></p>
<a id="more"></a>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><a href="http://kiya.space/2015/12/11/ida-dynamic-debug-dex/" target="_blank" rel="external">附加进程</a>后,在<code>libdvm.so</code>中的<code>dvmDexFileOpenPartial</code>函数下断点.</p>
<p>dvmDexFileOpenPartial的函数原型为(位于/dalvik/vm/DvmDex.cpp):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * @addr: 传入参数, dex文件的起始地址</div><div class="line"> * @len: 传出参数, dex文件的大小</div><div class="line"> * @ppDvmDex: 传出参数,指向 DvmDex 结构的地址</div><div class="line">*/</div><div class="line">int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)</div></pre></td></tr></table></figure></p>
<p>运行后断下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/16/13/39/27" alt=""></p>
<p>得R0为addr,R1为len.</p>
<p>执行脚本:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/16/13/39/41" alt=""></p>
<p>现在就可以使用baksmali处理dex文件继续分析了.</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>dalvik虚拟机会把dex文件优化为odex文件,而优化的源代码为<code>/dalvik/dexopt/OptMain.cpp</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Main entry point.  Decide where to go.</div><div class="line"> */</div><div class="line">int main(int argc, char* const argv[])</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    if (argc &gt; 1) &#123;</div><div class="line">        if (strcmp(argv[1], &quot;--zip&quot;) == 0)</div><div class="line">            return fromZip(argc, argv);</div><div class="line">        else if (strcmp(argv[1], &quot;--dex&quot;) == 0)</div><div class="line">            return fromDex(argc, argv);</div><div class="line">        else if (strcmp(argv[1], &quot;--preopt&quot;) == 0)</div><div class="line">            return preopt(argc, argv);</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>fromzip</code>和<code>preopt</code>都会调用<code>processZipFile</code>先将dex文件提取出来,<code>fromDex</code>则直接调用<code>dvmContinueOptimization</code>优化.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Common functionality for normal device-side processing as well as</div><div class="line"> * preoptimization.</div><div class="line"> */</div><div class="line">static int processZipFile(int zipFd, int cacheFd, const char* zipName,</div><div class="line">        const char *dexoptFlags)</div><div class="line">&#123;</div><div class="line">   	...</div><div class="line">    int result = extractAndProcessZip(zipFd, cacheFd, zipName, isBootstrap,</div><div class="line">            bcp, dexoptFlags);</div><div class="line">    free(bcpCopy);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>extractAndProcessZip</code>中处理zip文件并将dex提取出来,随后调用优化函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Extract &quot;classes.dex&quot; from zipFd into &quot;cacheFd&quot;, leaving a little space</div><div class="line"> * up front for the DEX optimization header.</div><div class="line"> */</div><div class="line">static int extractAndProcessZip(int zipFd, int cacheFd,</div><div class="line">    const char* debugFileName, bool isBootstrap, const char* bootClassPath,</div><div class="line">    const char* dexoptFlagStr)</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    /*</div><div class="line">     * Open the zip archive, find the DEX entry.</div><div class="line">     */</div><div class="line">    if (dexZipPrepArchive(zipFd, debugFileName, &amp;zippy) != 0) &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: unable to open zip archive &apos;%s&apos;&quot;, debugFileName);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    zipEntry = dexZipFindEntry(&amp;zippy, kClassesDex);</div><div class="line">    if (zipEntry == NULL) &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: zip archive &apos;%s&apos; does not include %s&quot;,</div><div class="line">            debugFileName, kClassesDex);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * Extract some info about the zip entry.</div><div class="line">     */</div><div class="line">    if (dexZipGetEntryInfo(&amp;zippy, zipEntry, NULL, &amp;uncompLen, NULL, NULL,</div><div class="line">            &amp;modWhen, &amp;crc32) != 0)</div><div class="line">    &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: zip archive GetEntryInfo failed on %s&quot;, debugFileName);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    uncompLen = uncompLen;</div><div class="line">    modWhen = modWhen;</div><div class="line">    crc32 = crc32;</div><div class="line">    /*</div><div class="line">     * Extract the DEX data into the cache file at the current offset.</div><div class="line">     */</div><div class="line">    if (dexZipExtractEntryToFile(&amp;zippy, zipEntry, cacheFd) != 0) &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: extraction of %s from %s failed&quot;,</div><div class="line">            kClassesDex, debugFileName);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">   	...</div><div class="line">    /*</div><div class="line">     * Prep the VM and perform the optimization.</div><div class="line">     */</div><div class="line">    if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode,</div><div class="line">            dexoptFlags) != 0)</div><div class="line">    &#123;</div><div class="line">        ALOGE(&quot;DexOptZ: VM init failed&quot;);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    //vmStarted = 1;</div><div class="line">    /* do the optimization */</div><div class="line">    if (!dvmContinueOptimization(cacheFd, dexOffset, uncompLen, debugFileName,</div><div class="line">            modWhen, crc32, isBootstrap))</div><div class="line">    &#123;</div><div class="line">        ALOGE(&quot;Optimization failed&quot;);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dvmContinueOptimization</code>函数位于/dalvik/vm/analysis/DexPrepare.cpp文件,其中调用了<code>dvmDexFileOpenPartial</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Do the actual optimization.  This is executed in the dexopt process.</div><div class="line"> *</div><div class="line"> * For best use of disk/memory, we want to extract once and perform</div><div class="line"> * optimizations in place.  If the file has to expand or contract</div><div class="line"> * to match local structure padding/alignment expectations, we want</div><div class="line"> * to do the rewrite as part of the extract, rather than extracting</div><div class="line"> * into a temp file and slurping it back out.  (The structure alignment</div><div class="line"> * is currently correct for all platforms, and this isn&apos;t expected to</div><div class="line"> * change, so we should be okay with having it already extracted.)</div><div class="line"> *</div><div class="line"> * Returns &quot;true&quot; on success.</div><div class="line"> */</div><div class="line">bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,</div><div class="line">    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)</div><div class="line">&#123;</div><div class="line">   ...</div><div class="line">		success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,</div><div class="line">                    doVerify, doOpt, &amp;pClassLookup, NULL);</div><div class="line">        if (success) &#123;</div><div class="line">            DvmDex* pDvmDex = NULL;</div><div class="line">            u1* dexAddr = ((u1*) mapAddr) + dexOffset;</div><div class="line">            if (dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex) != 0) &#123;</div><div class="line">                ALOGE(&quot;Unable to create DexFile&quot;);</div><div class="line">                success = false;</div><div class="line">            &#125; else &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dvmDexFileOpenPartial</code>调用了<code>dexFileParse</code>,用来解析内存中优化过或未优化过的dex文件,返回dexFile结构.<br>所以此时dex文件已经被加载进内存,就可以dump出来了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Create a DexFile structure for a &quot;partial&quot; DEX.  This is one that is in</div><div class="line"> * the process of being optimized.  The optimization header isn&apos;t finished</div><div class="line"> * and we won&apos;t have any of the auxillary data tables, so we have to do</div><div class="line"> * the initialization slightly differently.</div><div class="line"> *</div><div class="line"> * Returns nonzero on error.</div><div class="line"> */</div><div class="line">int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)</div><div class="line">&#123;</div><div class="line">    DvmDex* pDvmDex;</div><div class="line">    DexFile* pDexFile;</div><div class="line">    int parseFlags = kDexParseDefault;</div><div class="line">    int result = -1;</div><div class="line">    /* -- file is incomplete, new checksum has not yet been calculated</div><div class="line">    if (gDvm.verifyDexChecksum)</div><div class="line">        parseFlags |= kDexParseVerifyChecksum;</div><div class="line">    */</div><div class="line">    pDexFile = dexFileParse((u1*)addr, len, parseFlags);</div><div class="line">    if (pDexFile == NULL) &#123;</div><div class="line">        ALOGE(&quot;DEX parse failed&quot;);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MSC </tag>
            
            <tag> enforce </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[反调试方法一 - 读取进程status文件]]></title>
      <url>/2015/12/14/android-anti-debug-read-status/</url>
      <content type="html"><![CDATA[<p>栗子:<a href="https://github.com/kiya-z/Android/blob/master/lab-mouse/AliCrackme_2.apk" target="_blank" rel="external">阿里移动安全挑战赛第二题</a></p>
<a id="more"></a>
<blockquote>
<p>本栗反调试方法:<br>用fopen打开<code>/proc/&lt;pid&gt;/status</code>文件读取其中的<code>TracerPid</code>值来检测自己的进程是否被attach，<br>TracerPid如果为0说明没有别的进程在调试这个进程，如果不为0说明有程序在调试。</p>
</blockquote>
<p>使用ida附加进程,关键函数下断点F9之后,进程退出,ida退出.<br>调试过后发现JNI_OnLoad中有反调试方法(实际上是前辈的结论 :p).</p>
<p>根据<a href="http://kiya.space/2015/12/11/ida-dynamic-debug-so/" target="_blank" rel="external">使用ida调试so文件</a>的步骤在<code>library load</code>处断下.</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>打开Debugger windows -&gt; Module list,找到<code>/data/app-lib/com.yaotong.crackme-1/libcrackme.so</code>,为其中的JNI_OnLoad方法右键<code>Add breakpoint</code>.这里我们也可以得到libcrackme.so的基址为0x520AE000.<br>(当然如果反调试方法是在.initarray中,其地址需要手动计算.)</p>
<p>一步一步F8发现在执行这一句之后程序退出.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/14/22" alt=""></p>
<p>F7进去,发现是<code>pthread_create</code>函数.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/14/57" alt=""></p>
<p>所以上上图中的<code>unk_520AF6A4</code>函数就是线程回调函数咯.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/15/23" alt=""></p>
<p>先不去分析(其实是水平达不到 :( ),所以我们要用守株待兔的方法.<br>在module list中找到<code>libc.so</code>,在fopen函数下断点,以此检验程序是否打开了某些文件检测状态值.<br>同时打开一个hex view(View -&gt; Open subviews -&gt; Hex dump),设置数据与R0同步.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/15/46" alt=""></p>
<p>F9运行到fopen函数处(有时并不能一次就断在fopen,注意看注释).</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/06" alt=""></p>
<p>所以程序确实是读取了status文件. :P<br>这是需要找到是谁调用了fopen函数,然后修改读取status的返回值为0(不然就露馅了).<br>一直摁F8直到fopen函数返回,于是我们来到了这里.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/21" alt=""></p>
<p>一边是数据一边是代码,完全找不到函数开始的地方哇.<br>但是我们知道此处地址为<code>520AF420</code>,减去我们之前记下的libcrackme.so的基址520AE000,得到相对地址为<code>1420</code><br>另开一个ida,摁G键跳至此地址,F5发现是函数<code>sub_130c</code>.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/38" alt=""></p>
<p>将<code>sub_130c</code>的文件偏移转换为绝对地址:130c+520AE000=520AF30C.<br>p键将此处数据视为代码变成这样:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/21/02" alt=""></p>
<p>程序随后会用fgets()和strstr()来获取TracerId的值，于是我们在strstr()处下个断点，然后让hex view的数据与R0同步.<br>一直F9,直到R0的值变为这样:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/21/31" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/21/48" alt=""></p>
<p>F2修改为这样:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/22/34" alt=""></p>
<p>但是过一会程序又要获取,我们得一直不停的改,所以我们需要将这段代码nop掉,世界才安静.</p>
<h1 id="patch-so"><a href="#patch-so" class="headerlink" title="patch so"></a>patch so</h1><p>如果静态分析时找到JNI_OnLoad中关键的那句代码:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/59" alt=""></p>
<p>进入线程的回调函数,发现竟然是这样子的!</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/17/15" alt=""></p>
<p>回调函数<code>sub_16a4</code>中调用了<code>sub_130c</code>!<br>跟我们在动态调试时看到的完全不一样嘛.<br>现在将回调函数中的这一句nop掉就好了呗.<br>右键选择<code>copy to assembly</code></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/17/31" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/17/48" alt=""></p>
<p>我们的目标是<code>BL sub_130C</code>. arm中没有nop语句,所以将<code>movs r0,r0</code>作为NOP,对应的机器码为<code>00 00 A0 E1</code>.</p>
<p>右键进入hex view.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/18/02" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/18/17" alt=""></p>
<p>摁F2将<code>13 FF FF EB</code>改为<code>00 00 A0 E1</code>,再摁F2应用.<br>点击<code>Edit -&gt; Patch program -&gt; Apply patches to input file...</code>保存即可.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/18/34" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/20/31" alt=""></p>
<p>将原apk中的so文件替换为此so文件,重新打包签名安装,现在直接打开app调试就不会退出了. Success!</p>
<hr>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>ida中按三下D，将数据格式从字符转化为指针形式.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://drops.wooyun.org/tips/6840" target="_blank" rel="external">安卓动态调试七种武器之孔雀翎 – Ida Pro</a></p>
]]></content>
      
        <categories>
            
            <category> Android Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> anti-debug </tag>
            
            <tag> MSC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用ida调试so文件]]></title>
      <url>/2015/12/11/ida-dynamic-debug-so/</url>
      <content type="html"><![CDATA[<p>保护代码通常放在so文件中.</p>
<a id="more"></a>
<h1 id="正常的应用"><a href="#正常的应用" class="headerlink" title="正常的应用"></a>正常的应用</h1><h2 id="android机的准备工作"><a href="#android机的准备工作" class="headerlink" title="android机的准备工作"></a>android机的准备工作</h2><p>找到<code>ida</code>目录下的<code>/dbgsrv/android_server</code>文件,push进android机,启动<code>android_server</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">adb push android_server /data/local/tmp/</div><div class="line">adb shell</div><div class="line">su</div><div class="line">cd data/local/tmp</div><div class="line">chmod 755 android_server</div><div class="line">./android_server</div></pre></td></tr></table></figure>
<p>出现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@android:/data/local/tmp # ./android_server</div><div class="line">IDA Android 32-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015</div><div class="line">Listening on port #23946...</div></pre></td></tr></table></figure>
<p>另开命令行进行tcp端口转发：<br><code>adb forward tcp:23946 tcp:23946</code></p>
<p>[<strong>注意事项</strong>]</p>
<ol>
<li>此android_server需和ida是配套的</li>
<li>出现<code>bind: Address already in use</code>错误<br>这是因为手机中可能已经在运行android_server,使用<code>ps | grep android_server</code>看一下,有的话杀掉.<br>如下:(14061是pid)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@android:/ # ps | grep android_server</div><div class="line">root      14061 13574 11180  9504  ffffffff 40183da0 S /data/local/tmp/android_server</div><div class="line">127|root@android:/ # kill -s 9 14061</div></pre></td></tr></table></figure>
<h2 id="ida-的准备"><a href="#ida-的准备" class="headerlink" title="ida 的准备"></a>ida 的准备</h2><p>打开ida，打开so文件,记录so文件中感兴趣的函数的文件偏移.</p>
<p>手机打开app.</p>
<p>另开一个ida,菜单栏设置<code>Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger</code>如下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/46/45" alt=""></p>
<p>点击ok,弹出进程列表,例如:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/49/17" alt=""></p>
<blockquote>
<p><strong>注意</strong><br>如果此时进程列表中只有一两个进程,可能是因为上一步启动<code>android_server</code>时你使用了这样的命令:<br><code>adb shell /data/local/tmp/android_server</code><br>只要先进入<code>adb shell</code>再执行就没问题了.</p>
</blockquote>
<p>选择要调试的进程,等待分析完毕.</p>
<p><code>ctrl+s</code>打开segment列表,找到要调试的so文件,选择class属性为CODE的那个就ok了.记得记下so的基址(start属性).<br>基址加上刚刚记录的函数的文件偏移即得函数的地址,按快捷键G输入地址跳转,下断点运行即可.</p>
<h1 id="不正常的应用"><a href="#不正常的应用" class="headerlink" title="不正常的应用"></a>不正常的应用</h1><p>(此步骤也适用于给系统函数下断点)<br>so文件在被加载的时候会首先执行.init_array中的函数，然后再执行JNI_OnLoad()函数。如果在这中间加了反调试代码,那么我们一旦开始调试app可能就会退出.所以我们需要在so文件被加载之前就断下来.</p>
<h2 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h2><p>使用am start命令启动app:<br><code>adb shell am start -D -n com.yaotong.crackme/com.yaotong.crackme.MainActivity</code><br><strong>com.yaotong.crackme</strong> 为包名,<strong>com.yaotong.crackme.MainActivity</strong> 为主activity名.</p>
<p>此时手机上会弹出:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/12/13/35/08" alt=""></p>
<h2 id="ida准备"><a href="#ida准备" class="headerlink" title="ida准备"></a>ida准备</h2><p>同样是设置<code>Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger</code>再选择进程.<br>之后需要设置调试器调试选项为:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/12/13/35/31" alt=""></p>
<p>F9运行.<br>在控制台使用jdb恢复进程运行:<br><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></p>
<p>正常情况会出现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">设置未捕获的java.lang.Throwable</div><div class="line">设置延迟的未捕获的java.lang.Throwable</div><div class="line">正在初始化jdb...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">java.net.ConnectException: Connection refused: connect</div><div class="line">        at java.net.DualStackPlainSocketImpl.connect0(Native Method)</div><div class="line">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:79)</div><div class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:345)</div><div class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</div><div class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</div><div class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)</div><div class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</div><div class="line">        at java.net.Socket.connect(Socket.java:589)</div><div class="line">        at com.sun.tools.jdi.SocketTransportService.attach(SocketTransportService.java:222)</div><div class="line">        at com.sun.tools.jdi.GenericAttachingConnector.attach(GenericAttachingConnector.java:116)</div><div class="line">        at com.sun.tools.jdi.SocketAttachingConnector.attach(SocketAttachingConnector.java:90)</div><div class="line">        at com.sun.tools.example.debug.tty.VMConnection.attachTarget(VMConnection.java:519)</div><div class="line">        at com.sun.tools.example.debug.tty.VMConnection.open(VMConnection.java:328)</div><div class="line">        at com.sun.tools.example.debug.tty.Env.init(Env.java:63)</div><div class="line">        at com.sun.tools.example.debug.tty.TTY.main(TTY.java:1066)</div><div class="line">致命错误:</div><div class="line">无法附加到目标 VM。</div></pre></td></tr></table></figure>
<ul>
<li>打开ddms尝试.</li>
<li>检查调试的app配置文件中是否有<code>android:debuggable=&quot;true&quot;</code>，导致不能调试。<br>若无则在清单文件的application中加上,重新打包即可.</li>
</ul>
<p>接下来就可以在.initarray和JNI_OnLoad下断点了.</p>
<hr>
<blockquote>
<p>番外</p>
</blockquote>
<h1 id="initarray"><a href="#initarray" class="headerlink" title=".initarray"></a>.initarray</h1><p>静态分析so文件时,按<code>ctrl+s</code>出现segment列表,进入<code>.initarray</code>即可看到列表.</p>
<h1 id="如何dump-so文件"><a href="#如何dump-so文件" class="headerlink" title="如何dump so文件"></a>如何dump so文件</h1><p>dump时务必确保so文件已经加载.<br>python脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import idaapi</div><div class="line">data = idaapi.dbg_read_memory(start_addr,file_len)</div><div class="line">f = open(r&apos;C:\Users\...\Desktop\dump.so&apos;,&apos;wb&apos;)</div><div class="line">f.write(data)</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>ida的api函数地址:<a href="https://www.hex-rays.com/products/ida/support/idapython_docs/idaapi-module.html" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/idapython_docs/idaapi-module.html</a></p>
<p>以上.</p>
]]></content>
      
        <categories>
            
            <category> 逆向 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MSC </tag>
            
            <tag> debug </tag>
            
            <tag> ida </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用ida调试dex文件]]></title>
      <url>/2015/12/11/ida-dynamic-debug-dex/</url>
      <content type="html"><![CDATA[<h2 id="反编译apk文件"><a href="#反编译apk文件" class="headerlink" title="反编译apk文件"></a>反编译apk文件</h2><a id="more"></a>
<h2 id="dex文件拖入ida-等待分析完毕"><a href="#dex文件拖入ida-等待分析完毕" class="headerlink" title="dex文件拖入ida,等待分析完毕"></a>dex文件拖入ida,等待分析完毕</h2><h2 id="设置调试选项"><a href="#设置调试选项" class="headerlink" title="设置调试选项"></a>设置调试选项</h2><h3 id="菜单栏-Debugger-gt-Debugger-options…"><a href="#菜单栏-Debugger-gt-Debugger-options…" class="headerlink" title="菜单栏 Debugger -&gt; Debugger options…"></a>菜单栏 Debugger -&gt; Debugger options…</h3><p>勾选如下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/22/02" alt=""></p>
<p>点击<code>Set specific options</code>,填入包名和启动activity:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/23/22" alt=""></p>
<p>包名和主activity名在<code>Androidmanifest.xml</code>文件中.</p>
<h3 id="菜单栏-Debugger-gt-Process-options"><a href="#菜单栏-Debugger-gt-Process-options" class="headerlink" title="菜单栏 Debugger -&gt; Process options"></a>菜单栏 Debugger -&gt; Process options</h3><p>修改端口为8700</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/25/01" alt=""></p>
<p>8700在<code>ddms</code>中可以看到：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/26/05" alt=""></p>
<h2 id="根据需要下断点"><a href="#根据需要下断点" class="headerlink" title="根据需要下断点"></a>根据需要下断点</h2><h2 id="点绿色三角，启动调试"><a href="#点绿色三角，启动调试" class="headerlink" title="点绿色三角，启动调试"></a>点绿色三角，启动调试</h2><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/28/39" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/29/06" alt=""></p>
<p>这时候可能出现错误：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/27/46" alt=""></p>
<p>这是因为8700端口和<code>monitor</code>的冲突了,关掉<code>ddms</code>即可.</p>
<p>可能出现:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/16/13/38/13" alt=""></p>
<p>这是因为<code>AndroidManifest.xml</code>中没有<code>android:debuggable=&quot;true&quot;</code>选项,加上重新编译即可.</p>
<h2 id="触发断点"><a href="#触发断点" class="headerlink" title="触发断点"></a>触发断点</h2><p>在app上操作以触发断点,断下之后勾选菜单栏中 <strong>Debugger -&gt; Use source-level debugging</strong>.</p>
<p>这时候就可以开始调试咯。</p>
]]></content>
      
        <categories>
            
            <category> 逆向 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
            <tag> ida </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[arm指令练习篇章一]]></title>
      <url>/2015/12/07/arm-instruction-exercises-1/</url>
      <content type="html"><![CDATA[<p><strong>口号</strong>:为了熟悉arm指令而奋斗!</p>
<a id="more"></a>
<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><h2 id="C-code"><a href="#C-code" class="headerlink" title="C code"></a>C code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int test_for()</div><div class="line">&#123;</div><div class="line">    int i,sum = 0;</div><div class="line">    for(i = 0; i &lt; 100; i++)</div><div class="line">        sum += i;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    printf(&quot;sum:%d\n&quot;,test_for());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="arm-code"><a href="#arm-code" class="headerlink" title="arm code"></a>arm code</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">00008370 &lt;main&gt;:</div><div class="line">    8370:	e92d4800 	push	&#123;fp, lr&#125;</div><div class="line">    8374:	e28db004 	add	fp, sp, #4</div><div class="line">    8378:	e24dd008 	sub	sp, sp, #8</div><div class="line">    837c:	e50b0008 	str	r0, [fp, #-8]</div><div class="line">    8380:	e50b100c 	str	r1, [fp, #-12]</div><div class="line">    8384:	ebffffe2 	bl	8314 &lt;test_for&gt;</div><div class="line">    8388:	e1a02000 	mov	r2, r0</div><div class="line">    838c:	e59f3018 	ldr	r3, [pc, #24]	; 83ac &lt;main+0x3c&gt;</div><div class="line">    8390:	e08f3003 	add	r3, pc, r3</div><div class="line">    8394:	e1a00003 	mov	r0, r3</div><div class="line">    8398:	e1a01002 	mov	r1, r2</div><div class="line">    839c:	ebffffad 	bl	8258 &lt;printf@plt&gt;</div><div class="line">    83a0:	e1a00003 	mov	r0, r3</div><div class="line">    83a4:	e24bd004 	sub	sp, fp, #4</div><div class="line">    83a8:	e8bd8800 	pop	&#123;fp, pc&#125;</div><div class="line">    83ac:	00000030 	.word	0x00000030</div></pre></td></tr></table></figure>
<p><strong>push    {fp, lr}</strong></p>
<p><code>{}</code>: 其中包含多个值;<br><code>fp</code>(frame pointer): 帧指针,每个栈帧由fp和sp界定,fp相当于x86中的ebp,sp相当于x86中的esp;<br><code>lr</code>(link register): 链接寄存器,在程序中调用其他函数时,存放子程序的返回地址(即调用指令的下一条指令);</p>
<p>本指令相当于<code>stmfd sp!,{fp,lr}</code>(!表示更新寄存器的值),将调用者的fp和lr寄存的值压入堆栈(顺序:编号小的寄存器的值存入低地址,编号大的寄存器的值存入高地址),<br>保护调用者程序的环境,子程序执行完毕后恢复环境.</p>
<p><strong>add    fp, sp, #4</strong></p>
<p>将被调用者的fp(栈底)指向存放调用者fp的地址.</p>
<p><strong>sub    sp, sp, #8</strong></p>
<p>抬高栈顶指针,开辟栈空间(8字节).</p>
<p><strong>str    r0, [fp, #-8]</strong></p>
<p>将r0的值(参数1)存储到fp-8所在的地址.</p>
<p><strong>str    r1, [fp, #-12]</strong></p>
<p>将r1的值(参数2)存储到fp-12所在的地址.<br>现在子程序的栈结构如下:<br>高地址   -&gt;   低地址<br>返回地址(fp) 参数1 参数2(sp)</p>
<p><strong>bl    8314 <test_for></test_for></strong></p>
<p>调用8314处的test_for函数.bl指令同时会将返回地址存储在r14(lr)中.</p>
<p><strong>mov    r2, r0</strong></p>
<p>r0存储的是test_for的返回值,赋给r2.</p>
<p><strong>ldr    r3, [pc, #24]    ; 83ac <main+0x3c></main+0x3c></strong></p>
<p>加载pc+24地址处的一个字的数据(.word    0x00000030)放入r3.r3=0x30.</p>
<p><strong>add    r3, pc, r3</strong></p>
<p>r3+=pc,即取”sum:%d”字符串的地址.(PC的值为当前执行指令地址+8字节)</p>
<p><strong>mov    r0, r3</strong></p>
<p>r0为第一个参数(format字符串).</p>
<p><strong>mov    r1, r2</strong></p>
<p>r2为第二个参数(test_for返回值).(当参数少于4个时保存在通用寄存器中,多余4个的保存在栈中)</p>
<p><strong>bl    8258 <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x70;&#x72;&#x69;&#x6e;&#x74;&#x66;&#64;&#112;&#x6c;&#x74;">&#x70;&#x72;&#x69;&#x6e;&#x74;&#x66;&#64;&#112;&#x6c;&#x74;</a></strong></p>
<p>调用printf函数.</p>
<p><strong>sub    sp, fp, #4</strong></p>
<p>与开辟栈空间相对应.</p>
<p><strong>pop    {fp, pc}</strong></p>
<p>将栈顶数据分别弹出至fp,pc,恢复调用者程序的环境(顺序:低地址的值放入编号小的寄存器,高地址的值放入编号大的寄存器).</p>
<h3 id="test-for"><a href="#test-for" class="headerlink" title="test_for"></a>test_for</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">00008314 &lt;test_for&gt;:</div><div class="line">    8314:	e52db004 	push	&#123;fp&#125;		; (str fp, [sp, #-4]!)   @没有用到lr寄存器,无需保存</div><div class="line">    8318:	e28db000 	add	fp, sp, #0</div><div class="line">    831c:	e24dd00c 	sub	sp, sp, #12     @开辟栈空间</div><div class="line">    8320:	e3a03000 	mov	r3, #0     </div><div class="line">    8324:	e50b300c 	str	r3, [fp, #-12]  @sum</div><div class="line">    8328:	e3a03000 	mov	r3, #0</div><div class="line">    832c:	e50b3008 	str	r3, [fp, #-8]   @i</div><div class="line">    8330:	ea000006 	b	8350 &lt;test_for+0x3c&gt; @b指令直接按地址跳转,不保存返回地址</div><div class="line">    8334:	e51b200c 	ldr	r2, [fp, #-12]</div><div class="line">    8338:	e51b3008 	ldr	r3, [fp, #-8]</div><div class="line">    833c:	e0823003 	add	r3, r2, r3      @取i和sum相加</div><div class="line">    8340:	e50b300c 	str	r3, [fp, #-12]</div><div class="line">    8344:	e51b3008 	ldr	r3, [fp, #-8]   @取i值加1</div><div class="line">    8348:	e2833001 	add	r3, r3, #1</div><div class="line">    834c:	e50b3008 	str	r3, [fp, #-8]</div><div class="line">    8350:	e51b3008 	ldr	r3, [fp, #-8]   @取i值</div><div class="line">    8354:	e3530063 	cmp	r3, #99	; 0x63</div><div class="line">    8358:	dafffff5 	ble	8334 &lt;test_for+0x20&gt;    @小于等于99继续</div><div class="line">    835c:	e51b300c 	ldr	r3, [fp, #-12]</div><div class="line">    8360:	e1a00003 	mov	r0, r3          @sum值放入r0返回</div><div class="line">    8364:	e24bd000 	sub	sp, fp, #0</div><div class="line">    8368:	e49db004 	pop	&#123;fp&#125;		; (ldr fp, [sp], #4)</div><div class="line">    836c:	e12fff1e 	bx	lr   @转到返回地址</div></pre></td></tr></table></figure>
<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><h2 id="c-code"><a href="#c-code" class="headerlink" title="c code"></a>c code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int global_v = 5;</div><div class="line">int test_switch()</div><div class="line">&#123;</div><div class="line">    switch(global_v)&#123;</div><div class="line">        case 1: printf(&quot;1&quot;);</div><div class="line">        case 5: printf(&quot;5&quot;);</div><div class="line">        case 7: printf(&quot;7&quot;);</div><div class="line">        default: printf(&quot;fail&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    test_switch();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="arm-code-1"><a href="#arm-code-1" class="headerlink" title="arm code"></a>arm code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">00008344 &lt;test_switch&gt;:</div><div class="line">    8344:	e92d4800 	push	&#123;fp, lr&#125;   @保存环境</div><div class="line">    8348:	e28db004 	add	fp, sp, #4     @调整当前栈帧的栈底指针</div><div class="line">    834c:	e59f2054 	ldr	r2, [pc, #84]	; 83a8 &lt;test_switch+0x64&gt;</div><div class="line">    8350:	e08f2002 	add	r2, pc, r2</div><div class="line">    8354:	e59f3050 	ldr	r3, [pc, #80]	; 83ac &lt;test_switch+0x68&gt; @这里可见全局变量是通过地址存取的</div><div class="line">    8358:	e7923003 	ldr	r3, [r2, r3]</div><div class="line">    835c:	e5933000 	ldr	r3, [r3]</div><div class="line">    8360:	e3530005 	cmp	r3, #5  @由此可见采用了二分查找</div><div class="line">    8364:	0a000006 	beq	8384 &lt;test_switch+0x40&gt;</div><div class="line">    8368:	e3530007 	cmp	r3, #7</div><div class="line">    836c:	0a000007 	beq	8390 &lt;test_switch+0x4c&gt;</div><div class="line">    8370:	e3530001 	cmp	r3, #1</div><div class="line">    8374:	1a000008 	bne	839c &lt;test_switch+0x58&gt;</div><div class="line">    8378:	e3a00031 	mov	r0, #49	; 0x31</div><div class="line">    837c:	ebffffbe 	bl	827c &lt;putchar@plt&gt;       @单个字符的printf变成了putchar</div><div class="line">    8380:	ea000009 	b	83ac &lt;test_switch+0x68&gt;</div><div class="line">    8384:	e3a00035 	mov	r0, #53	; 0x35</div><div class="line">    8388:	ebffffbb 	bl	827c &lt;putchar@plt&gt;</div><div class="line">    838c:	ea000006 	b	83ac &lt;test_switch+0x68&gt;   @返回</div><div class="line">    8390:	e3a00037 	mov	r0, #55	; 0x37</div><div class="line">    8394:	ebffffb8 	bl	827c &lt;putchar@plt&gt;</div><div class="line">    8398:	ea000003 	b	83ac &lt;test_switch+0x68&gt;</div><div class="line">    839c:	e59f3018 	ldr	r3, [pc, #24]	; 83bc &lt;test_switch+0x78&gt;</div><div class="line">    83a0:	e08f3003 	add	r3, pc, r3</div><div class="line">    83a4:	e1a00003 	mov	r0, r3</div><div class="line">    83a8:	ebffffb6 	bl	8288 &lt;printf@plt&gt;</div><div class="line">    83ac:	e1a00003 	mov	r0, r3      @返回值</div><div class="line">    83b0:	e8bd8800 	pop	&#123;fp, pc&#125;    @恢复环境</div><div class="line">    83b4:	00001c8c 	.word	0x00001c8c</div><div class="line">    83b8:	fffffffc 	.word	0xfffffffc</div><div class="line">    83bc:	00000054 	.word	0x00000054</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> arm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Arm 架构简介]]></title>
      <url>/2015/12/05/arm-introduction/</url>
      <content type="html"><![CDATA[<p>原书链接: <a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf" target="_blank" rel="external">https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf</a></p>
<p>本文原文: “A1.1 About the ARM architecture”</p>
<a id="more"></a>
<h1 id="A1-1-关于ARM-架构"><a href="#A1-1-关于ARM-架构" class="headerlink" title="A1.1 关于ARM 架构"></a>A1.1 关于ARM 架构</h1><p>ARM 架构已经可以支持高低各种性能的实现. 超过20亿设备装备了ARM,确立了其在市场上统治意义的地位. ARM 处理器的简单架构可以实现各种小功能同时电量消耗低. 在 ARM 架构的发展中,实现难度,性能,电量消耗低都是不可或缺的关键因素.</p>
<p>ARM 是精简指令集,典型特征如下:</p>
<ul>
<li>统一样式的寄存器文件</li>
<li>load/store 架构,数据处理指令只能处理寄存器中的内容,不能直接处理内存中的内容</li>
<li>简单的寻址模式,load/store的地址只由寄存器内容和指令字段决定</li>
<li>统一固定长度的指令字段,可简化指令解析</li>
</ul>
<p>除此之外,ARM架构还提供:</p>
<ul>
<li>大多数数据处理指令都可以控制ALU和移位器,这样可以最大化利用ALU和移位器</li>
<li>自增自减寻址模式,优化循环</li>
<li>load/store多条指令合一,增加数据吞吐量</li>
<li>所有指令的条件执行,增加执行吞吐量</li>
</ul>
<p>这些对于RISC的增强功能使得ARM处理器在高性能,代码少,低消耗和芯片面积小之间达到了良好的平衡.</p>
<h1 id="A1-1-1-ARM-寄存器"><a href="#A1-1-1-ARM-寄存器" class="headerlink" title="A1.1.1  ARM 寄存器"></a>A1.1.1  ARM 寄存器</h1><p>ARM有31个32位通用寄存器,任何时候其中16个都是可见的,其他寄存器是用来加速异常处理的.<br>非特权代码使用着这16个寄存器,也就是处于用户模式的代码.<br>用户模式的特点如下:</p>
<ul>
<li>用户模式只能产生异常切换到另一个进程中.在编程层面由SWI指令实现这一功能.</li>
<li>相对于特权模式,用户模式能访问到的内存和协处理器功能是有限的.</li>
</ul>
<p>在这16个寄存器当中,有三个是特殊寄存器:<br><strong>Stack pointer</strong>: R13是栈顶指针(SP). 在T变种指令集中R13被PUSH和POP使用,从ARMv6之后被SRS和RFE指令使用.</p>
<p><strong>Link register</strong>: R14是链接寄存器(LR),在执行BL和BLX指令时,存放下一条指令的地址(即子程序的返回地址). 在异常模式的入口处页作为返回地址使用. 其余情况作为通用寄存器使用.</p>
<p><strong>Program counter</strong>: R15是程序计数器(PC). 指向当前正在执行指令的下一条的下一条指令的地址. 在ARM中,所有的指令都是4字节长(一个32位字),并且以一个字长对齐. 这就意味着PC的后两位总是0,也就是只有30位是有用的. 有些架构版本给剩余的两位赋予了含义. T变种和J变种的Jazelle状态支持Thumb指令集,此时PC大小为16位,以1字节对齐.</p>
<p>其余的13个寄存器没有特殊的硬件指定的用途,只会被软件指定使用.</p>
<h1 id="A1-1-2-异常"><a href="#A1-1-2-异常" class="headerlink" title="A1.1.2 异常"></a>A1.1.2 异常</h1><p>ARM支持7种类型的异常,每种异常都可进入特权处理模式.<br>这7种异常是:</p>
<ul>
<li>重置</li>
<li>试图执行未定义指令</li>
<li>软件中断指令(SWI),可以用来调用操作系统</li>
<li>预取中止,中止读内存指令</li>
<li>数据中止,数据访问权限中止</li>
<li>IRQ,正常中断</li>
<li>FIQ,快速中断</li>
</ul>
<p>异常发生时,一些标准寄存器将被异常模式征用. 所有的异常都有R13,R14的替代寄存器,快速中断异常模式还有其他的替代寄存器.</p>
<p>进入异常的handler时,R14存放异常处理的返回地址,用来返回到造成异常的代码.</p>
<p>在整个异常处理过程中,R13是每个handler的独立的stack pointer. 快速中断模式会将R8-R12的值存起来,这样中断处理程序在开始之前就不用存储或者恢复这些寄存器了.</p>
<p>第六特权处理模式-系统模式,可以使用用户模式的寄存器. 此功能用来运行需要内存或协处理器高级权限的任务,并且没有对异常发生的限制.</p>
<p>除了上面这些,reset和SWIs共享同等特权模式.</p>
<h2 id="异常处理过程"><a href="#异常处理过程" class="headerlink" title="异常处理过程"></a>异常处理过程</h2><p>异常发生时, ARM 处理器以一种预定义的方式暂停执行, 开始执行内存中某一固定地址处的异常向量代码. 包括reset在内每个异常都有一个异常向量地址. 正常运行的系统和调试事件对应的行为都是定义好的.</p>
<p>操作系统在初始化时为每个异常分配一个handler, 有权限的系统任务运行在系统模式下可以让操作系统内不带状态损失的发生异常.</p>
<h1 id="A1-1-3-状态寄存器"><a href="#A1-1-3-状态寄存器" class="headerlink" title="A1.1.3 状态寄存器"></a>A1.1.3 状态寄存器</h1><p>除了通用寄存器的内容之外,所有的处理器状态保存在状态寄存器中. 当前的操作系统状态保存在CPSR寄存器中(Current Program Status Register). 内容如下:</p>
<ul>
<li>4个条件标记位(负数,0,进位,溢出)</li>
<li>1个sticky(Q)标记位(ARMv5及以上),标记饱和算数指令是否已经达到饱和,或者在累加乘法中指令是否有符号溢出.</li>
<li>4个GE(大于等于)标记位(ARMv6及以上),用来标记一下情况:<br>(1) 有符号运算的结果是非负的<br>(2) 无符号运算是否产生进位或借位</li>
<li>2个中断标记位,一个是中断的类型(2个是在ARMv5版本及以下).</li>
<li>1个不确切中断标记位(ARMv6之后)</li>
<li>5个当前处理器所在模式标记位</li>
<li>2个指令集标记位,标记当前执行的是指令集是ARM,Thumb还是Jazelle</li>
<li>1个load/store操作的字节顺序标记位</li>
</ul>
<p>每个异常模式有一个SPSR寄存器(Saved Program Status Register),进入异常前保存任务的CPSR值.这两个寄存器以特殊的指令存取.</p>
<p><strong>Table A1-1 Status register summary</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
<th>Architecture</th>
</tr>
</thead>
<tbody>
<tr>
<td>N Z C V</td>
<td>Condition code flags</td>
<td>All</td>
</tr>
<tr>
<td>J</td>
<td>Jazelle state flag</td>
<td>5TEJ and above</td>
</tr>
<tr>
<td>GE[3:0]</td>
<td>SIMD condition</td>
<td>flags 6</td>
</tr>
<tr>
<td>E</td>
<td>Endian Load/Store</td>
<td>6</td>
</tr>
<tr>
<td>A</td>
<td>Imprecise Abort Mask</td>
<td>6</td>
</tr>
<tr>
<td>I</td>
<td>IRQ Interrupt Mask</td>
<td>All</td>
</tr>
<tr>
<td>F</td>
<td>FIQ Interrupt Mask</td>
<td>All</td>
</tr>
<tr>
<td>T</td>
<td>Thumb state flag</td>
<td>4T and above</td>
</tr>
<tr>
<td>Mode[4:0]</td>
<td>Processor mode</td>
<td>All</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> ARM </category>
            
            <category> 译文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> arm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在android手机上运行C程序 - hello arm!]]></title>
      <url>/2015/12/02/run-first-c-program-on-android-phone/</url>
      <content type="html"><![CDATA[<p>为了学习arm指令集，当然要先写段 hello arm 试验咯。</p>
<a id="more"></a>
<h1 id="写段-hello-arm"><a href="#写段-hello-arm" class="headerlink" title="写段 hello arm"></a>写段 hello arm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">        printf(&quot;hello arm!\n&quot;);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h1><p>这里有两种手动编译方式：gcc和ndk-build.</p>
<h2 id="使用gcc"><a href="#使用gcc" class="headerlink" title="使用gcc"></a>使用gcc</h2><h3 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h3><p>因为我们要编译出在android手机上运行的程序，必须要为gcc提供android的平台文件和指令集。<br>而ndk中自带了gcc等一系列工具，所以现在直接调用即可。没有ndk的话需要先行下载。<br>为<code>～/.bashrc</code>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#android-ndk-gcc</div><div class="line">export NDKROOT=/media/d/android-sdk-linux/android-sdk-linux/ndk-bundle</div><div class="line">export SYSROOT=$NDKROOT/platforms/android-21/arch-arm</div><div class="line">export NDKTOOL=$NDKROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin</div><div class="line">alias ndk-gcc=&apos;$NDKTOOL/arm-linux-androideabi-gcc-4.9 --sysroot=$SYSROOT&apos;</div><div class="line">alias ndk-objdump=&apos;$NDKTOOL/arm-linux-androideabi-objdump&apos;</div></pre></td></tr></table></figure>
<p>其中<br><code>NDKROOT</code>是ndk的主目录;<br><code>SYSROOT</code>是所选的指令集,这里是arm;<br><code>NDKTOOL</code>是ndk的工具链目录;<br><code>ndk-gcc</code>是为后面一串命令起的别名，这样使用时就不用一遍一遍的输参数了;<br><code>ndk-objdump</code>是可以反汇编arm程序的工具,与ndk-gcc在ndk的同一目录下.</p>
<p>配置完成后可执行<code>source ~./bashrc</code>使立即生效,<code>echo $ndk-gcc</code>查看是否设置成功。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>执行<code>ndk-gcc -o hello-arm hello-arm.c</code>直接生成可执行文件。<br>执行<code>ndk-gcc -S hello-arm.s hello-arm.c</code>生成arm汇编文件。<br>其他选项执行<code>ndk-gcc --help</code>查看帮助。</p>
<h2 id="使用ndk-build"><a href="#使用ndk-build" class="headerlink" title="使用ndk-build"></a>使用ndk-build</h2><h3 id="配置ndk-build环境"><a href="#配置ndk-build环境" class="headerlink" title="配置ndk-build环境"></a>配置ndk-build环境</h3><p>如果是单独下的ndk,这时候系统找不到ndk-build命令,需要将其路径加入path中.<br>ndk-build在ndk根目录下。</p>
<h3 id="新建Android工程"><a href="#新建Android工程" class="headerlink" title="新建Android工程"></a>新建Android工程</h3><p>执行<code>android list</code>查看已安装的sdk版本;<br>执行<code>android create project -t 1 -p ~/Desktop/helloarm -a MainActivity</code>在桌面创建一个新工程.<br>其中:<br><code>-t</code>表示新工程目标sdk;<br><code>-p</code>表示工程的路径;<br><code>-a</code>表示默认activity的名称.<br>其他选项可执行<code>android create project -h</code>查看.</p>
<h3 id="配置jni目录"><a href="#配置jni目录" class="headerlink" title="配置jni目录"></a>配置jni目录</h3><p>在工程根目录下新建一个<code>jni</code>目录,将<code>hello-arm.c</code>拷贝至此目录.<br>新建脚本文件名为<code>Android.mk</code>,这是ndk-build需要的工程编译脚本,描述了编译程序的各种选项和依赖.<br>内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)</div><div class="line">include $(CLEAR_VARS)</div><div class="line">LOCAL_ARM_MODE := arm</div><div class="line">LOCAL_MODULE := hello-arm</div><div class="line">LOCAL_SRC_FILES := hello-arm.c</div><div class="line">include $(BUILD_EXECUTABLE)</div></pre></td></tr></table></figure>
<p>其中:<br><code>LOCAL_PATH</code>表示本工程源码的路径, <code>my-dir</code>表示Android.mk的路径;<br><code>CLEAR_VARS</code>让编译器清除已经定义过的宏,避免在编译多个模块时发生错误,因为这些宏是全局的,必须重新设置;<br><code>LOCAL_ARM_MODE</code>指定程序使用的ARM指令模式;<br><code>LOCAL_MODULE</code>指定生成的模块名,如果生成的是共享库,模块名会变为libhello-arm.so;<br><code>LOCAL_SRC_FILES</code>指定源文件列表;<br><code>BUILD_EXECUTABLE</code>表示生成的文件是可执行的,其他选项有<code>BUILD_SHARED_LIBRARY</code>(生成动态库),<code>BUILD_STATIC_LIBRARY</code>(生成静态库).</p>
<h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>在工程根目录下执行<code>ndk-build</code>,编译完成后的文件在<code>libs/armeabi</code>目录下.</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>执行<code>adb push hello-arm /data/local</code>push到手机上(我用的是genymotion虚拟机),</p>
<p>执行<code>/data/local/hello-arm</code></p>
<h2 id="出现第一个错误"><a href="#出现第一个错误" class="headerlink" title="出现第一个错误"></a>出现第一个错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh: ./hello arm: not executable: magic 7F45</div></pre></td></tr></table></figure>
<p>这是因为程序指令集和手机指令集不一致造成的。</p>
<p>写一段java代码编译成dex,看看手机是什么架构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class GetCPU</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        String arch = System.getProperty(&quot;os.arch&quot;);</div><div class="line">        System.out.println(arch);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行<code>javac GetCPU.java</code> 和 <code>dx --dex --output=GetCPU.dex GetCPU.class</code> 编译成dex文件,<br>push到手机上的 /data/local/目录, 执行<code>dalvikvm -cp /data/local/GetCPU.dex GetCPU</code>:<br>果然是intel的..</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@vbox86p:/data/local #dalvikvm -cp /data/local/GetCPU.dex GetCPU  </div><div class="line">i686</div></pre></td></tr></table></figure>
<p>换了一个arm架构的手机(真机):<br>先执行了GetCPU.dex确认指令集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@aio_otfp:/data/local # dalvikvm -cp /data/local/GetCPU.dex GetCPU         </div><div class="line">aarch64</div></pre></td></tr></table></figure>
<p>现在可以执行 <code>/data/local/hello-arm</code>了.</p>
<h2 id="出现第二个错误！"><a href="#出现第二个错误！" class="headerlink" title="出现第二个错误！"></a>出现第二个错误！</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh: ./hello-arm: can&apos;t execute: Permission denied</div></pre></td></tr></table></figure>
<p>这是因为没有执行权限，加上执行权限！777！再次执行！</p>
<h2 id="出现第三个错误！"><a href="#出现第三个错误！" class="headerlink" title="出现第三个错误！"></a>出现第三个错误！</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: only position independent executables (PIE) are supported.</div></pre></td></tr></table></figure>
<p>这次是因为没有静态编译，重新编译，加上静态选项：</p>
<p><code>ndk-gcc --static hello-world.c -o hello-arm</code></p>
<p>颤颤巍巍的再次执行…<br>终于出现了 ——————— hello arm!</p>
<h1 id="Refernece"><a href="#Refernece" class="headerlink" title="Refernece"></a>Refernece</h1><p><a href="http://ticktick.blog.51cto.com/823160/1692489" target="_blank" rel="external">如何在命令行下使用Android NDK交叉编译工具</a></p>
<p><a href="http://blog.csdn.net/smfwuxiao/article/details/6587709" target="_blank" rel="external">Android NDK 工具链的使用方法（Standalone Toolchain）</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ndk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 14.04编译运行android 4.4.4_r2源码]]></title>
      <url>/2015/12/02/compile-android-sourcecode-4-4-4-r2/</url>
      <content type="html"><![CDATA[<h1 id="下载-repo"><a href="#下载-repo" class="headerlink" title="下载 repo"></a>下载 repo</h1><p>使用的是<a href="https://mirrors.tuna.tsinghua.edu.cn/help/#AOSP" target="_blank" rel="external">清华镜像</a>，按步骤来下载即可。<br><a id="more"></a><br>具体参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/#AOSP" target="_blank" rel="external">Android 镜像使用帮助</a><br>这种方法下载比较慢，下了有50+G，大部分都是git文件。<br>所以准备的硬盘空间要大一些!大一些!再大一些!<br>我编译完成后占用的总空间有101G！其中编译后的out目录26G, .repo目录66G, 也就是源码只有9G…</p>
<h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><p>我之前安装的jdk是1.7的，android4.4.4需要安装1.5的版本。</p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>这里一定要确保全部安装了。<br>下面的命令是针对ubuntu14.04来说的，其余系统参考<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">官网</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential \</div><div class="line">  zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \</div><div class="line">  lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</div><div class="line">  libgl1-mesa-dev libxml2-utils xsltproc unzip</div></pre></td></tr></table></figure>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>源码根目录下执行make。<br>出现了！错误！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;../build/scripts/make_css_property_names.py&quot;, line 255, in &lt;module&gt;</div><div class="line">    in_generator.Maker(CSSPropertiesWriter).main(sys.argv)</div><div class="line">  File &quot;/media/mobiledisk/source-code/repo-android/external/chromium_org/third_party/WebKit/Source/build/scripts/in_generator.py&quot;, line 99, in main</div><div class="line">    writer.write_files(options.output_dir)</div><div class="line">  File &quot;/media/mobiledisk/source-code/repo-android/external/chromium_org/third_party/WebKit/Source/build/scripts/in_generator.py&quot;, line 79, in write_files</div><div class="line">    self._write_file(output_dir, generator(), file_name)</div><div class="line">  File &quot;../build/scripts/make_css_property_names.py&quot;, line 250, in generate_implementation</div><div class="line">    gperf = subprocess.Popen(gperf_args, stdin=subprocess.PIPE, stdout=subprocess.PIPE)</div><div class="line">  File &quot;/usr/lib/python2.7/subprocess.py&quot;, line 710, in __init__</div><div class="line">    errread, errwrite)</div><div class="line">  File &quot;/usr/lib/python2.7/subprocess.py&quot;, line 1327, in _execute_child</div><div class="line">    raise child_exception</div><div class="line">OSError: [Errno 2] No such file or directory</div></pre></td></tr></table></figure>
<p>这种情况就是某个依赖没有安装…</p>
<h1 id="运行编译好的系统"><a href="#运行编译好的系统" class="headerlink" title="运行编译好的系统"></a>运行编译好的系统</h1><p>源码根目录下执行一下命令:</p>
<p><code>source build/envsetup.sh</code><br><code>lunch full-eng</code><br><code>emulator</code></p>
<p>就会启动自带的模拟器了，里面就是刚刚编译好的系统。</p>
<hr>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>源码根目录下关于avd的操作：</p>
<p><code>android list avd</code>: 列出模拟器列表<br><code>android create avd -t 1 -n myavd</code>: 创建一个名为myavd的模拟器,-t为指定id.具体可通过-h查看.<br><code>emulator -avd myavd</code>: 启动模拟器</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> compile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dex及其类的加载过程]]></title>
      <url>/2015/11/28/dex-loading-flow/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。</p>
</blockquote>
<a id="more"></a>
<p>每个android应用程序都是运行在虚拟机实例上的，而其中dex的加载就比如离开不了虚拟机的初始化。</p>
<h1 id="JNI-CreateJavaVM"><a href="#JNI-CreateJavaVM" class="headerlink" title="JNI_CreateJavaVM"></a>JNI_CreateJavaVM</h1><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/Jni.cpp#3524" target="_blank" rel="external">/dalvik/vm/Jni.cpp</a>.<br>创建了一个虚拟机之后调用 dvmStartup 初始化虚拟机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">std::string status = dvmStartup(argc, argv.get(), args-&gt;ignoreUnrecognized, (JNIEnv*)pEnv);</div></pre></td></tr></table></figure>
<h1 id="dvmStartup"><a href="#dvmStartup" class="headerlink" title="dvmStartup"></a>dvmStartup</h1><p>位于<a href="(http://androidxref.com/4.4.4_r1/xref/dalvik/vm/Init.cpp#1382">/dalvik/vm/Init.cpp</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">std::string dvmStartup(int argc, const char* const argv[],</div><div class="line">        bool ignoreUnrecognized, JNIEnv* pEnv)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    if (!dvmClassStartup()) &#123;   //初始化文件的结构体引用</div><div class="line">        return &quot;dvmClassStartup failed&quot;;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    if (!dvmFindRequiredClassesAndMembers()) &#123;  //初始化成员、类的引用</div><div class="line">        return &quot;dvmFindRequiredClassesAndMembers failed&quot;;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="dvmClassStartup"><a href="#dvmClassStartup" class="headerlink" title="dvmClassStartup"></a>dvmClassStartup</h2><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#409" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a><br>处理启动类路径，打开特定的dex/jar文件，可能会进行一些优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bool dvmClassStartup()</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    processClassPath(gDvm.bootClassPathStr, true);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="processClassPath"><a href="#processClassPath" class="headerlink" title="processClassPath"></a>processClassPath</h3><p>将一些文件路径转化为ClassPathEntry结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">static ClassPathEntry* processClassPath(const char* pathStr, bool isBootstrap)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    cp = mangle;</div><div class="line">    idx = 0;</div><div class="line">    while (cp &lt; end) &#123;  //循环遍历pathStr</div><div class="line">        ...</div><div class="line">            ClassPathEntry tmp;</div><div class="line">            tmp.kind = kCpeUnknown;</div><div class="line">            tmp.fileName = strdup(cp);</div><div class="line">            tmp.ptr = NULL;</div><div class="line">            cpe[idx].kind = kCpeLastEntry;</div><div class="line">            cpe[idx].fileName = NULL;</div><div class="line">            cpe[idx].ptr = NULL;</div><div class="line">            //为每个文件准备一个cpe</div><div class="line">            if (!prepareCpe(&amp;tmp, isBootstrap)) &#123;</div><div class="line">                /* drop from list and continue on */</div><div class="line">                free(tmp.fileName);</div><div class="line">            &#125; else &#123;</div><div class="line">                /* copy over, pointers and all */</div><div class="line">                cpe[idx] = tmp;</div><div class="line">                idx++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cp += strlen(cp) +1;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    return cpe;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="prepareCpe"><a href="#prepareCpe" class="headerlink" title="prepareCpe"></a>prepareCpe</h3><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#603" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a>.<br>根据传进的文件名判断这是一个什么样的文件，提取出有用的信息，存入ClassPathEntry结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static bool prepareCpe(ClassPathEntry* cpe, bool isBootstrap)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    char suffix[10];</div><div class="line">    getFileNameSuffix(cpe-&gt;fileName, suffix, sizeof(suffix));</div><div class="line">    //根据后缀名判断文件类型</div><div class="line">    if ((strcmp(suffix, &quot;jar&quot;) == 0) || (strcmp(suffix, &quot;zip&quot;) == 0) ||</div><div class="line">            (strcmp(suffix, &quot;apk&quot;) == 0)) &#123;</div><div class="line">        JarFile* pJarFile = NULL;</div><div class="line">        if (dvmJarFileOpen(cpe-&gt;fileName, NULL, &amp;pJarFile, isBootstrap) == 0) &#123;</div><div class="line">            cpe-&gt;kind = kCpeJar;</div><div class="line">            cpe-&gt;ptr = pJarFile;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (strcmp(suffix, &quot;dex&quot;) == 0) &#123;</div><div class="line">        RawDexFile* pRawDexFile = NULL;</div><div class="line">        if (dvmRawDexFileOpen(cpe-&gt;fileName, NULL, &amp;pRawDexFile, isBootstrap) == 0) &#123;</div><div class="line">            cpe-&gt;kind = kCpeDex;</div><div class="line">            cpe-&gt;ptr = pRawDexFile;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        ALOGE(&quot;Unknown type suffix &apos;%s&apos;&quot;, suffix);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="dvmRawDexFileOpen"><a href="#dvmRawDexFileOpen" class="headerlink" title="dvmRawDexFileOpen"></a>dvmRawDexFileOpen</h3><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/RawDexFile.cpp#109" target="_blank" rel="external">/dalvik/vm/RawDexFile.cpp</a>.<br>打开一个原生dex文件，优化，加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName,</div><div class="line">     RawDexFile** ppRawDexFile, bool isBootstrap)</div><div class="line"> &#123;</div><div class="line">    ...</div><div class="line">     dexFd = open(fileName, O_RDONLY);  //打开文件</div><div class="line">     if (dexFd &lt; 0) goto bail;</div><div class="line">     if (odexOutputName == NULL) &#123;  //构造一个dex cache name</div><div class="line">         cachedName = dexOptGenerateCacheFileName(fileName, NULL);</div><div class="line">         if (cachedName == NULL)</div><div class="line">             goto bail;</div><div class="line">     &#125;</div><div class="line">    ...</div><div class="line">    //打开cache中的文件，如果没有会新建一个，填充头部，验证dependencies</div><div class="line">     optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,</div><div class="line">         adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true);</div><div class="line">    //新生成一个优化的dex</div><div class="line">     if (newFile) &#123;</div><div class="line">         ...</div><div class="line">         if (result) &#123;     //内部执行了system/bin目录下的dexopt文件</div><div class="line">             result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,</div><div class="line">                 fileName, modTime, adler32, isBootstrap);</div><div class="line">         &#125;</div><div class="line">         ...</div><div class="line">     &#125;</div><div class="line">     if (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != 0) &#123;</div><div class="line">         ALOGI(&quot;Unable to map cached %s&quot;, fileName);</div><div class="line">         goto bail;</div><div class="line">     &#125;</div><div class="line">     ...</div><div class="line">     *ppRawDexFile = (RawDexFile*) calloc(1, sizeof(RawDexFile));</div><div class="line">     (*ppRawDexFile)-&gt;cacheFileName = cachedName;</div><div class="line">     (*ppRawDexFile)-&gt;pDvmDex = pDvmDex;    //新文件的指针</div><div class="line">     cachedName = NULL;      // don&apos;t free it below</div><div class="line">     result = 0;</div><div class="line">...</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="dvmFindRequiredClassesAndMembers"><a href="#dvmFindRequiredClassesAndMembers" class="headerlink" title="dvmFindRequiredClassesAndMembers"></a>dvmFindRequiredClassesAndMembers</h2><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/InitRefs.cpp#481" target="_blank" rel="external">/dalvik/vm/InitRefs.cpp</a> .<br>遍历类列表和成员列表，将他们的引用存入全局遍历gDvm中以便日后引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Look up the set of classes and members used directly by the VM,</div><div class="line"> * storing references to them into the globals instance. See</div><div class="line"> * Globals.h. This function is exposed so that dex optimization may</div><div class="line"> * call it (while avoiding doing other unnecessary VM initialization).</div><div class="line"> *</div><div class="line"> * The function returns a success flag (true == success).</div><div class="line"> */</div><div class="line">bool dvmFindRequiredClassesAndMembers() &#123;</div><div class="line">    /*</div><div class="line">     * Note: Under normal VM use, this is called by dvmStartup()</div><div class="line">     * in Init.c. For dex optimization, this is called as well, but in</div><div class="line">     * that case, the call is made from DexPrepare.c.</div><div class="line">     */</div><div class="line">    return initClassReferences()</div><div class="line">        &amp;&amp; initFieldOffsets()</div><div class="line">        &amp;&amp; initConstructorReferences()</div><div class="line">        &amp;&amp; initDirectMethodReferences()</div><div class="line">        &amp;&amp; initVirtualMethodOffsets()</div><div class="line">        &amp;&amp; initFinalizerReference()</div><div class="line">        &amp;&amp; verifyStringOffsets();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仅以initClassReferences为例。</p>
<h3 id="initClassReferences"><a href="#initClassReferences" class="headerlink" title="initClassReferences"></a>initClassReferences</h3><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/InitRefs.cpp#initClassReferences" target="_blank" rel="external">/dalvik/vm/InitRefs.cpp</a> .<br>初始化一下核心类、数组类、异常类的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static bool initClassReferences() &#123;</div><div class="line">    ...</div><div class="line">    int i;      //初始化类的引用</div><div class="line">    for (i = 0; classes[i].ref != NULL; i++) &#123;</div><div class="line">        if (!initClassReference(classes[i].ref, classes[i].name)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="initClassReference"><a href="#initClassReference" class="headerlink" title="initClassReference"></a>initClassReference</h4><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/InitRefs.cpp#24" target="_blank" rel="external">/dalvik/vm/InitRefs.cpp</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static bool initClassReference(ClassObject** pClass, const char* name) &#123;</div><div class="line">    ClassObject* result;</div><div class="line">    assert(*pClass == NULL);</div><div class="line">    if (name[0] == &apos;[&apos;) &#123;   //基本类类型的数组</div><div class="line">        result = dvmFindArrayClass(name, NULL);</div><div class="line">    &#125; else &#123;    //系统类的引用</div><div class="line">        result = dvmFindSystemClassNoInit(name);</div><div class="line">    &#125;</div><div class="line">    if (result == NULL) &#123;</div><div class="line">        ALOGE(&quot;Could not find essential class %s&quot;, name);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    *pClass = result;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dvmFindSystemClassNoInit"><a href="#dvmFindSystemClassNoInit" class="headerlink" title="dvmFindSystemClassNoInit"></a>dvmFindSystemClassNoInit</h4><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#1454" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Find the named class (by descriptor), searching for it in the</div><div class="line"> * bootclasspath.</div><div class="line"> *</div><div class="line"> * On failure, this returns NULL with an exception raised.</div><div class="line"> */</div><div class="line">ClassObject* dvmFindSystemClassNoInit(const char* descriptor)</div><div class="line">&#123;</div><div class="line">    return findClassNoInit(descriptor, NULL, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="findClassNoInit"><a href="#findClassNoInit" class="headerlink" title="findClassNoInit"></a>findClassNoInit</h3><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#1473" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a><br>通过文件描述符找到相应的类，如果类没有加载，我们就去加载并链接，但是不会执行<clinit>.<br>这里会返回一个是通过加载得到的类还是用的已有的类定义的标识，以防在同一个class loader中被加载两次。</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static ClassObject* findClassNoInit(const char* descriptor, Object* loader,</div><div class="line">    DvmDex* pDvmDex)</div><div class="line">&#123;</div><div class="line">    //在已经加载的类列表中查找（hash）</div><div class="line">    clazz = dvmLookupClass(descriptor, loader, true);</div><div class="line">    if (clazz == NULL) &#123;    //如果没有找到相应的类切没有传进dex文件的参数，就在dex列表中查找，找到之后加载dex文件中的类</div><div class="line">        const DexClassDef* pClassDef;</div><div class="line">        ...</div><div class="line">        if (pDvmDex == NULL) &#123;</div><div class="line">            assert(loader == NULL);     /* shouldn&apos;t be here otherwise */</div><div class="line">            pDvmDex = searchBootPathForClass(descriptor, &amp;pClassDef); //在dex列表中查找</div><div class="line">        &#125; else &#123;    //在提供的dex文件中查找</div><div class="line">            pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        /* found a match, try to load it */</div><div class="line">        clazz = loadClassFromDex(pDvmDex, pClassDef, loader);   //加载dex！</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="loadClassFromDex"><a href="#loadClassFromDex" class="headerlink" title="loadClassFromDex"></a>loadClassFromDex</h3><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#1953" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a>.<br>从指定的dex文件中加载指定的类。此函数相当于loadClass()+defineClass().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Try to load the indicated class from the specified DEX file.</div><div class="line"> *</div><div class="line"> * This is effectively loadClass()+defineClass() for a DexClassDef.  The</div><div class="line"> * loading was largely done when we crunched through the DEX.</div><div class="line"> *</div><div class="line"> * Returns NULL on failure.  If we locate the class but encounter an error</div><div class="line"> * while processing it, an appropriate exception is thrown.</div><div class="line"> */</div><div class="line">static ClassObject* loadClassFromDex(DvmDex* pDvmDex,</div><div class="line">    const DexClassDef* pClassDef, Object* classLoader)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    pDexFile = pDvmDex-&gt;pDexFile;</div><div class="line">    //通过pClassDef得到class_data_item指针</div><div class="line">    pEncodedData = dexGetClassData(pDexFile, pClassDef);</div><div class="line">    if (pEncodedData != NULL) &#123;</div><div class="line">        dexReadClassDataHeader(&amp;pEncodedData, &amp;header);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Provide an all-zeroes header for the rest of the loading.</div><div class="line">        memset(&amp;header, 0, sizeof(header));</div><div class="line">    &#125;</div><div class="line">    //通过头部数据和class_data_item得到其他的数据</div><div class="line">    result = loadClassFromDex0(pDvmDex, pClassDef, &amp;header, pEncodedData,</div><div class="line">            classLoader);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="loadClassFromDex0"><a href="#loadClassFromDex0" class="headerlink" title="loadClassFromDex0"></a>loadClassFromDex0</h3><p>位于<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#1727" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a>.<br>通过头部数据和class_data_item，返回一个class的全部数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static ClassObject* loadClassFromDex0(DvmDex* pDvmDex,</div><div class="line">    const DexClassDef* pClassDef, const DexClassDataHeader* pHeader,</div><div class="line">    const u1* pEncodedData, Object* classLoader)</div><div class="line">&#123;</div><div class="line">    ClassObject* newClass = NULL;</div><div class="line">    descriptor = dexGetClassDescriptor(pDexFile, pClassDef);</div><div class="line">    newClass-&gt;descriptor = descriptor; //描述符</div><div class="line">    SET_CLASS_FLAG(newClass, pClassDef-&gt;accessFlags);   //权限标识</div><div class="line">    newClass-&gt;pDvmDex = pDvmDex;</div><div class="line">    newClass-&gt;primitiveType = PRIM_NOT;</div><div class="line">    newClass-&gt;status = CLASS_IDX;</div><div class="line">    ...</div><div class="line">    newClass-&gt;super = (ClassObject*) pClassDef-&gt;superclassIdx;  //父类</div><div class="line">    ....</div><div class="line">    ....</div><div class="line">    newClass-&gt;sourceFile = dexGetSourceFile(pDexFile, pClassDef);   //源文件</div><div class="line">    /* caller must call dvmReleaseTrackedAlloc */</div><div class="line">    return newClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虚拟机创建后开始初始化，其中一步就是初始化类的引用，类成员的引用。</p>
<p>在初始化文件结构体的引用时，虚拟机根据全局变量gDvm中的启动类路径来为每个类生成一个ClassPathEntry的结构体引用，处理的过程中为压缩文件/dex调用了不同的函数，<br>处理dex文件时顺便对齐进行了优化，生成了odex文件。(当然4.4之后由于采用了ART代替dalvik，优化后的文件格式应为elf)。</p>
<p>在初始化类中数据的引用时，先是在已经加载的类列表中查找，如果没有的话再逐个的对dex进行解剖查找，找到相应的dex后，加载这个dex文件解析全部数据。</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://androidxref.com/4.4.4_r1/" target="_blank" rel="external">Android在线源码</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8885792" target="_blank" rel="external">Dalvik虚拟机的启动过程分析</a><br><a href="http://www.cnblogs.com/jacobchen/p/3599483.html" target="_blank" rel="external">Dalvik的BOOTCLASSPATH和dexopt流程</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
            <tag> dalvik </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[smali 语法 - 内部类和注解类]]></title>
      <url>/2015/11/27/smali-grammar-special-classes/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文环境<br><code>java version &quot;1.7.0_75&quot;</code><br><code>dx version 1.11</code><br><code>baksmali 2.1.0</code></p>
</blockquote>
<a id="more"></a>
<h1 id="知识预备"><a href="#知识预备" class="headerlink" title="知识预备"></a>知识预备</h1><h2 id="系统注解"><a href="#系统注解" class="headerlink" title="系统注解"></a>系统注解</h2><p>系统注解用来表示java反射相关的信息，是由编译器生成的。<br>存在于 .dex 文件annotation部分，只在运行时系统可见。<br>源码在 /libcore/dalvik/src/main/java/dalvik/annotation/ 目录下.</p>
<h3 id="AnnotationDefault"><a href="#AnnotationDefault" class="headerlink" title="AnnotationDefault"></a>AnnotationDefault</h3><p>注解类的默认注解类，如果指定了默认值，此注解类就会出现。</p>
<h3 id="EnclosingClass"><a href="#EnclosingClass" class="headerlink" title="EnclosingClass"></a>EnclosingClass</h3><p>出现在内部类中，指定该 内部类/匿名内部类 所在的最近的外部类，此注解类必须和InnerClass注解类一同出现,不能和EnclosingMethod一同出现。</p>
<h3 id="EnclosingMethod"><a href="#EnclosingMethod" class="headerlink" title="EnclosingMethod"></a>EnclosingMethod</h3><p>出现在内部类中，指定该内部类所在的最近的外部函数，此注解类必须和InnerClass注解类一同出现,不能和EnclosingClass一同出现。</p>
<h3 id="InnerClass"><a href="#InnerClass" class="headerlink" title="InnerClass"></a>InnerClass</h3><p>出现在内部类中，提供内部类的名字(不包括包名,匿名内部类值为null)和访问权限(同类的访问权限)。<br>该注解类需和EnclosingMethod或EnclosingClass之一一同出现。</p>
<h3 id="MemberClasses"><a href="#MemberClasses" class="headerlink" title="MemberClasses"></a>MemberClasses</h3><p>出现在具有内部类的类中，提供直接内部类(不包含嵌套)的类名列表。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>出现由更复杂的类型定义的类、字段或者方法中，dex文件不定义signature的格式，此注解类只是指定<code>源语言能够实现其语义</code>的相应的signature。<br>因此，signature并不能被解析或这验证，只能被高一级的API或者工具(如调试器)接管。<br>signature以字符串数组的形式存在，使用的时候拼接。只有编译工具才能将一个完整的signature分成几个字符串。</p>
<h3 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a>Throws</h3><p>以数组形式指定某个方法抛出的异常类型。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>java 在编译的时候会为每个类生成一个class文件，内部类的格式为 <code>[外部类]$[内部类].class</code>.</p>
<h2 id="java-代码"><a href="#java-代码" class="headerlink" title="java 代码"></a>java 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class HeyInnerclass</div><div class="line">&#123;</div><div class="line">    class Inner1&#123;</div><div class="line">        class Inner1_1&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    class Inner2&#123;&#125;</div><div class="line">    private void func()&#123;</div><div class="line">        class InnerFun&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="smali-代码"><a href="#smali-代码" class="headerlink" title="smali 代码"></a>smali 代码</h2><p>以下仅为部分相关代码。</p>
<h3 id="HeyInnerclass"><a href="#HeyInnerclass" class="headerlink" title="HeyInnerclass"></a>HeyInnerclass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># annotations   //注解类MemberClasses</div><div class="line">.annotation system Ldalvik/annotation/MemberClasses;</div><div class="line">    value = &#123;</div><div class="line">        LHeyInnerclass$Inner2;,</div><div class="line">        LHeyInnerclass$Inner1;</div><div class="line">    &#125;</div><div class="line">.end annotation</div><div class="line">.method private func()V</div><div class="line">    .registers 1</div><div class="line">    .prologue</div><div class="line">    .line 18</div><div class="line">    return-void</div><div class="line">.end method</div></pre></td></tr></table></figure>
<p>HeyInnerclass 中有 HeyInnerclass$Inner2 和 HeyInnerclass$Inner1 两个类！<br>func 方法中并没有任何实现还是占用了一个寄存器，这个寄存器表示自身(this)的引用。</p>
<h3 id="Inner1"><a href="#Inner1" class="headerlink" title="Inner1"></a>Inner1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># annotations   //注解类 EnclosingClass</div><div class="line">.annotation system Ldalvik/annotation/EnclosingClass;</div><div class="line">    value = LHeyInnerclass;</div><div class="line">.end annotation</div><div class="line">//注解类 InnerClass</div><div class="line">.annotation system Ldalvik/annotation/InnerClass;</div><div class="line">    accessFlags = 0x0</div><div class="line">    name = &quot;Inner1&quot;</div><div class="line">.end annotation</div><div class="line">//注解类 MemberClasses</div><div class="line">.annotation system Ldalvik/annotation/MemberClasses;</div><div class="line">    value = &#123;</div><div class="line">        LHeyInnerclass$Inner1$Inner1_1;</div><div class="line">    &#125;</div><div class="line">.end annotation</div><div class="line"># instance fields   //声明字段this$0</div><div class="line">.field final synthetic this$0:LHeyInnerclass;</div><div class="line"># direct methods</div><div class="line">.method constructor &lt;init&gt;(LHeyInnerclass;)V</div><div class="line">    .registers 2</div><div class="line">    .prologue</div><div class="line">    .line 3     //初始化字段 this$0</div><div class="line">    iput-object p1, p0, LHeyInnerclass$Inner1;-&gt;this$0:LHeyInnerclass;</div><div class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</div><div class="line">    .line 5</div><div class="line">    return-void</div><div class="line">.end method</div></pre></td></tr></table></figure>
<p>Inner1 中有一个内部类 HeyInnerclass$Inner1$Inner1_1，所在的外部类是 HeyInnerclass，名字是 Inner1，访问权限 0x0.<br><code>this$0</code> 是 HeyInnerclass 类型的，是内部类的保留的对所在的外部类的引用，this表示父类的引用，0表示引用的层数。<br><code>synthetic</code>表示这是合成的，由编译器生成的，不是写出来的。</p>
<p>Inner2 与 Inner1 除了没有字节的内部类外其余基本一致，代码就不贴了。</p>
<h3 id="Inner1-1"><a href="#Inner1-1" class="headerlink" title="Inner1_1"></a>Inner1_1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># annotations   #注解类</div><div class="line">.annotation system Ldalvik/annotation/EnclosingClass;</div><div class="line">    value = LHeyInnerclass$Inner1;</div><div class="line">.end annotation</div><div class="line">.annotation system Ldalvik/annotation/InnerClass;   #注解类</div><div class="line">    accessFlags = 0x0</div><div class="line">    name = &quot;Inner1_1&quot;</div><div class="line">.end annotation</div><div class="line"># instance fields</div><div class="line">.field final synthetic this$1:LHeyInnerclass$Inner1;</div><div class="line"># direct methods</div><div class="line">.method constructor &lt;init&gt;(LHeyInnerclass$Inner1;)V</div><div class="line">    .registers 2</div><div class="line">    .prologue</div><div class="line">    .line 5</div><div class="line">    iput-object p1, p0, LHeyInnerclass$Inner1$Inner1_1;-&gt;this$1:LHeyInnerclass$Inner1;</div><div class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</div><div class="line">    return-void</div><div class="line">.end method</div></pre></td></tr></table></figure>
<p>Inner1_1 名字是 Inner1_1,访问权限为0x0,所在的外部类是HeyInnerclass$Inner1,<br>对外部类的的引用是 this$1，类型是 HeyInnerclass$Inner1，1表示引用层数深了一层。</p>
<h3 id="InnerFun"><a href="#InnerFun" class="headerlink" title="InnerFun"></a>InnerFun</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># annotations   #注解类</div><div class="line">.annotation system Ldalvik/annotation/EnclosingMethod;</div><div class="line">    value = LHeyInnerclass;-&gt;func()V</div><div class="line">.end annotation</div><div class="line">.annotation system Ldalvik/annotation/InnerClass;   #注解类</div><div class="line">    accessFlags = 0x0</div><div class="line">    name = &quot;InnerFun&quot;</div><div class="line">.end annotation</div><div class="line"># instance fields   #引用字段</div><div class="line">.field final synthetic this$0:LHeyInnerclass;</div><div class="line"># direct methods</div><div class="line">.method constructor &lt;init&gt;(LHeyInnerclass;)V</div><div class="line">    .registers 2</div><div class="line">    .prologue</div><div class="line">    .line 17</div><div class="line">    iput-object p1, p0, LHeyInnerclass$1InnerFun;-&gt;this$0:LHeyInnerclass;</div><div class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</div><div class="line">    return-void</div><div class="line">.end method</div></pre></td></tr></table></figure>
<p>InnerFun的名字是InnerFun,访问权限是0x0，所在的方法是 LHeyInnerclass;-&gt;func()V .<br>对外部类的引用是 this$0,类型是 HeyInnerclass,引用层数为0.</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> smali </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[smali 语法 - iterator & switch-case & try-catch]]></title>
      <url>/2015/11/26/smali-grammar-iterator-switch/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文环境<br><code>java version &quot;1.7.0_75&quot;</code><br><code>dx version 1.11</code><br><code>baksmali 2.1.0</code></p>
</blockquote>
<a id="more"></a>
<h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>（for 和 while-do 两种形式）</p>
<h2 id="java-代码"><a href="#java-代码" class="headerlink" title="java 代码"></a>java 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">class HeyIterator</div><div class="line">&#123;</div><div class="line">    static void iter_for()</div><div class="line">    &#123;</div><div class="line">        ArrayList al = new ArrayList();</div><div class="line">        al.add(&quot;C&quot;);</div><div class="line">        for( Iterator itr = al.iterator(); itr.hasNext(); )&#123;</div><div class="line">            System.out.print(itr.next());</div><div class="line">        &#125;</div><div class="line">        Iterator itr2 = al.iterator();</div><div class="line">        while(itr2.hasNext()) &#123;</div><div class="line">            System.out.print(itr2.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="smali-代码"><a href="#smali-代码" class="headerlink" title="smali 代码"></a>smali 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">.class LHeyIterator;</div><div class="line">.super Ljava/lang/Object;</div><div class="line">.source &quot;HeyIterator.java&quot;</div><div class="line"># direct methods</div><div class="line">.method constructor &lt;init&gt;()V</div><div class="line">    .registers 1</div><div class="line">    .prologue</div><div class="line">    .line 3</div><div class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</div><div class="line">    return-void</div><div class="line">.end method</div><div class="line">.method static iter_for()V</div><div class="line">    .registers 4</div><div class="line">    .prologue</div><div class="line">    .line 7</div><div class="line">    new-instance v0, Ljava/util/ArrayList;</div><div class="line">    invoke-direct &#123;v0&#125;, Ljava/util/ArrayList;-&gt;&lt;init&gt;()V</div><div class="line">    .line 8</div><div class="line">    const-string v1, &quot;C&quot;</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/util/ArrayList;-&gt;add(Ljava/lang/Object;)Z</div><div class="line">    .line 10    //得到迭代器</div><div class="line">    invoke-virtual &#123;v0&#125;, Ljava/util/ArrayList;-&gt;iterator()Ljava/util/Iterator;</div><div class="line">    move-result-object v1</div><div class="line">    :goto_e     //判断是否有下一个元素</div><div class="line">    invoke-interface &#123;v1&#125;, Ljava/util/Iterator;-&gt;hasNext()Z</div><div class="line">    move-result v2</div><div class="line">    if-eqz v2, :cond_1e</div><div class="line">    .line 11</div><div class="line">    sget-object v2, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    invoke-interface &#123;v1&#125;, Ljava/util/Iterator;-&gt;next()Ljava/lang/Object;</div><div class="line">    move-result-object v3</div><div class="line">    invoke-virtual &#123;v2, v3&#125;, Ljava/io/PrintStream;-&gt;print(Ljava/lang/Object;)V</div><div class="line">    goto :goto_e    //跳至循环头部</div><div class="line">//--------------分割线---------------------</div><div class="line">    .line 14</div><div class="line">    :cond_1e    //得到迭代器</div><div class="line">    invoke-virtual &#123;v0&#125;, Ljava/util/ArrayList;-&gt;iterator()Ljava/util/Iterator;</div><div class="line">    move-result-object v0</div><div class="line">    .line 15</div><div class="line">    :goto_22    //判断是否有下一个元素</div><div class="line">    invoke-interface &#123;v0&#125;, Ljava/util/Iterator;-&gt;hasNext()Z</div><div class="line">    move-result v1</div><div class="line">    if-eqz v1, :cond_32</div><div class="line">    .line 16</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    invoke-interface &#123;v0&#125;, Ljava/util/Iterator;-&gt;next()Ljava/lang/Object;</div><div class="line">    move-result-object v2</div><div class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;print(Ljava/lang/Object;)V</div><div class="line">    goto :goto_22   //跳至循环头部</div><div class="line">    .line 18</div><div class="line">    :cond_32</div><div class="line">    return-void</div><div class="line">.end method</div></pre></td></tr></table></figure>
<p><strong>两种方式完全一样啊</strong></p>
<hr>
<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><h2 id="java-代码-1"><a href="#java-代码-1" class="headerlink" title="java 代码"></a>java 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">class HeySwitch</div><div class="line">&#123;</div><div class="line">    static void func()</div><div class="line">    &#123;</div><div class="line">        int a = 10;</div><div class="line">        //连续的case</div><div class="line">        switch(a)&#123;</div><div class="line">            case 0:</div><div class="line">                System.out.println(0);</div><div class="line">            case 1:</div><div class="line">                System.out.println(1);</div><div class="line">            case 2:</div><div class="line">                System.out.println(2);</div><div class="line">            case 3:</div><div class="line">                System.out.println(3);</div><div class="line">        &#125;</div><div class="line">        //不连续的case</div><div class="line">        switch(a)&#123;</div><div class="line">            case 0:</div><div class="line">                System.out.println(0);</div><div class="line">            case 32:</div><div class="line">                System.out.println(32);</div><div class="line">            case 64:</div><div class="line">                System.out.println(64);</div><div class="line">            case 128:</div><div class="line">                System.out.println(128);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="smali-代码-1"><a href="#smali-代码-1" class="headerlink" title="smali 代码"></a>smali 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">.class LHeySwitch;</div><div class="line">.super Ljava/lang/Object;</div><div class="line">.source &quot;HeySwitch.java&quot;</div><div class="line"># direct methods</div><div class="line">.method constructor &lt;init&gt;()V</div><div class="line">    .registers 1</div><div class="line">    .prologue</div><div class="line">    .line 3</div><div class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</div><div class="line">    return-void</div><div class="line">.end method</div><div class="line">.method static func()V</div><div class="line">    .registers 4</div><div class="line">    .prologue</div><div class="line">    const/4 v3, 0x0</div><div class="line">    .line 7</div><div class="line">    const/16 v0, 0xa</div><div class="line">    .line 8     //第一个switch的packed矩阵，指令格式 packed-switch vAA, +BBBBBBBB</div><div class="line">    packed-switch v0, :pswitch_data_3e</div><div class="line">    .line 19</div><div class="line">    :goto_6     //第二个switch的sparse矩阵，指令格式 sparse-switch vAA, +BBBBBBBB</div><div class="line">    sparse-switch v0, :sswitch_data_4a</div><div class="line">    .line 30</div><div class="line">    :goto_9         //函数结束</div><div class="line">    return-void</div><div class="line">//------------分割线-----------</div><div class="line">    .line 10</div><div class="line">    :pswitch_a</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    invoke-virtual &#123;v1, v3&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    .line 12</div><div class="line">    :pswitch_f</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const/4 v2, 0x1</div><div class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    .line 14</div><div class="line">    :pswitch_15</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const/4 v2, 0x2</div><div class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    .line 16</div><div class="line">    :pswitch_1b</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const/4 v2, 0x3</div><div class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    goto :goto_6</div><div class="line">    //------------分割线-----------</div><div class="line">    .line 21</div><div class="line">    :sswitch_22</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    invoke-virtual &#123;v0, v3&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    .line 23</div><div class="line">    :sswitch_27</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const/16 v1, 0x20</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    .line 25</div><div class="line">    :sswitch_2e</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const/16 v1, 0x40</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    .line 27</div><div class="line">    :sswitch_35</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const/16 v1, 0x80</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(I)V</div><div class="line">    goto :goto_9</div><div class="line">//------------分割线-----------</div><div class="line">    .line 8</div><div class="line">    nop</div><div class="line">    :pswitch_data_3e    //第一个矩阵</div><div class="line">    .packed-switch 0x0  //初始值为0，依次递增</div><div class="line">        :pswitch_a</div><div class="line">        :pswitch_f</div><div class="line">        :pswitch_15</div><div class="line">        :pswitch_1b</div><div class="line">    .end packed-switch</div><div class="line">    .line 19</div><div class="line">    :sswitch_data_4a    //第二个矩阵</div><div class="line">    .sparse-switch      //没有规定初始值，而是每个值对应相应的代码</div><div class="line">        0x0 -&gt; :sswitch_22</div><div class="line">        0x20 -&gt; :sswitch_27</div><div class="line">        0x40 -&gt; :sswitch_2e</div><div class="line">        0x80 -&gt; :sswitch_35</div><div class="line">    .end sparse-switch</div><div class="line">.end method</div></pre></td></tr></table></figure>
<h3 id="switch-指令格式"><a href="#switch-指令格式" class="headerlink" title="switch 指令格式"></a>switch 指令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">packed-switch vAA, +BBBBBBBB</div><div class="line">sparse-switch vAA, +BBBBBBBB</div></pre></td></tr></table></figure>
<p><code>AA</code> 表示要判断的值<br><code>BBBB</code> 表示相应 switch-payload 的偏移</p>
<h3 id="两种-switch-payload-的格式"><a href="#两种-switch-payload-的格式" class="headerlink" title="两种 switch-payload 的格式"></a>两种 switch-payload 的格式</h3><p><strong>(1) packed-switch-payload format</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ident</td>
<td>ushort = 0x0100</td>
<td>固定值</td>
</tr>
<tr>
<td>size</td>
<td>ushort</td>
<td>入口的个数</td>
</tr>
<tr>
<td>first_key</td>
<td>int</td>
<td>第一个switch的值（最小的）</td>
</tr>
<tr>
<td>targets</td>
<td>int[]</td>
<td>每个case相对于switch指令的偏移，而非此矩阵</td>
</tr>
</tbody>
</table>
<p><strong>(2) sparse-switch-payload format</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ident</td>
<td>ushort = 0x0200</td>
<td>固定值</td>
</tr>
<tr>
<td>size</td>
<td>ushort</td>
<td>入口的个数</td>
</tr>
<tr>
<td>keys</td>
<td>int[]</td>
<td>case的值，从低到高</td>
</tr>
<tr>
<td>targets</td>
<td>int[]</td>
<td>每个case相对于switch指令的偏移，而非此矩阵</td>
</tr>
</tbody>
</table>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>由<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">官方文档</a>可得<br><code>packed-switch</code> 的 opcode 为 <code>2b</code>，<code>sparse-switch</code> 的 opcode 为 <code>2c</code> .<br>在16进制编辑器中搜索 <code>2b</code>，可得两条 switch 的位置(0x146, 0x14c)，从 smali 代码中也能看出他们是相邻的。（当然这一步可用ida直接搜索packed-swtch更方便）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">00000140  .. .. .. .. .. .. 2b 00  3b 00 00 00 2c 00 44 00  |......+.;...,.D.|</div><div class="line">00000150  00 00</div></pre></td></tr></table></figure></p>
<p>第一条翻译为：<code>packed-switch v0,146h+2*3bh</code>,得矩阵的偏移为 0x1bc.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">000001b0  .. .. .. .. .. .. .. .. .. .. .. ..  00 01 04 00  |..n ....(.......|</div><div class="line">000001c0  00 00 00 00 07 00 00 00  0c 00 00 00 12 00 00 00  |................|</div><div class="line">000001d0  18 00 00 00</div></pre></td></tr></table></figure></p>
<p><code>ident</code>: 0x0100<br><code>size</code>: 0x04<br><code>first_key</code>: 0x0<br><code>targets</code>: 0x07, 0x0c, 0x12, 0x18<br>如：0x146+2*0x07=0x154 即为 case 0 对应的代码地址。</p>
<p>第二条翻译为：<code>sparse-switch v0,14ch+2*44h</code>,得矩阵的偏移为 0x1d4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">000001d0  .. .. .. .. 00 02 04 00  00 00 00 00 20 00 00 00  |............ ...|</div><div class="line">000001e0  40 00 00 00 80 00 00 00  1c 00 00 00 21 00 00 00  |@...........!...|</div><div class="line">000001f0  28 00 00 00 2f 00 00 00</div></pre></td></tr></table></figure></p>
<p><code>ident</code>: 0x0200<br><code>size</code>: 0x04<br><code>keys</code>: 0x00, 0x02, 0x04, 0x08<br><code>targets</code>: 0x1c, 0x21, 0x28, 0x2f<br>如：0x14c+2*0x1c=0x184 即为 case 0 对应的代码地址。</p>
<hr>
<h1 id="try"><a href="#try" class="headerlink" title="try"></a>try</h1><h2 id="java-代码："><a href="#java-代码：" class="headerlink" title="java 代码："></a>java 代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">class HeyTry</div><div class="line">&#123;</div><div class="line">    public static void func()</div><div class="line">    &#123;</div><div class="line">        try&#123;</div><div class="line">            int a = 10/0;</div><div class="line">        &#125;</div><div class="line">        catch(ArithmeticException e)&#123;   //共有三个这样的异常</div><div class="line">            System.out.println(&quot;zero error.&quot;);</div><div class="line">        &#125;</div><div class="line">        try&#123;</div><div class="line">            int a = 0;</div><div class="line">            int b = 10/a;</div><div class="line">        &#125;</div><div class="line">        catch(ArithmeticException e)&#123;</div><div class="line">            System.out.println(&quot;zero error.&quot;);</div><div class="line">        &#125;</div><div class="line">        catch(Exception e)&#123;</div><div class="line">            System.out.println(e);</div><div class="line">        &#125;</div><div class="line">        try&#123;</div><div class="line">            int a = 0;</div><div class="line">            try&#123;</div><div class="line">                int b = 10/a;</div><div class="line">            &#125;</div><div class="line">            catch(ArithmeticException e)&#123;</div><div class="line">                System.out.println(&quot;zero error.&quot;);</div><div class="line">            &#125;</div><div class="line">            int[] ar = &#123;0,0&#125;;</div><div class="line">            int c = ar[2];</div><div class="line">        &#125;</div><div class="line">        catch(Exception e)&#123;</div><div class="line">            System.out.println(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="smali-代码："><a href="#smali-代码：" class="headerlink" title="smali 代码："></a>smali 代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">.class LHeyTry;</div><div class="line">.super Ljava/lang/Object;</div><div class="line">.source &quot;HeyTry.java&quot;</div><div class="line"># direct methods</div><div class="line">.method constructor &lt;init&gt;()V</div><div class="line">    .registers 1</div><div class="line">    .prologue</div><div class="line">    .line 3</div><div class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</div><div class="line">    return-void</div><div class="line">.end method</div><div class="line">.method public static func()V</div><div class="line">    .registers 2</div><div class="line">    .prologue</div><div class="line">    .line 8</div><div class="line">    const/16 v0, 0xa</div><div class="line">    :try_start_2    //try开始</div><div class="line">    div-int/lit8 v0, v0, 0x0</div><div class="line">    :try_end_4      //try结束，紧跟着的是catch</div><div class="line">    .catch Ljava/lang/ArithmeticException; &#123;:try_start_2 .. :try_end_4&#125; :catch_18</div><div class="line">    .line 15</div><div class="line">    :goto_4</div><div class="line">    const/4 v0, 0x0     //原本是try内部的常量定义被挪到了外面</div><div class="line">    .line 16</div><div class="line">    const/16 v1, 0xa</div><div class="line">    :try_start_7</div><div class="line">    div-int v0, v1, v0</div><div class="line">    :try_end_9</div><div class="line">    .catch Ljava/lang/ArithmeticException; &#123;:try_start_7 .. :try_end_9&#125; :catch_21</div><div class="line">    .catch Ljava/lang/Exception; &#123;:try_start_7 .. :try_end_9&#125; :catch_2a</div><div class="line">    .line 26</div><div class="line">    :goto_9</div><div class="line">    const/4 v0, 0x0</div><div class="line">    .line 28</div><div class="line">    const/16 v1, 0xa</div><div class="line">    :try_start_c</div><div class="line">    div-int v0, v1, v0</div><div class="line">    :try_end_e      //原本是内外层关系的两个catch被放在了一起</div><div class="line">    .catch Ljava/lang/ArithmeticException; &#123;:try_start_c .. :try_end_e&#125; :catch_31</div><div class="line">    .catch Ljava/lang/Exception; &#123;:try_start_c .. :try_end_e&#125; :catch_3a</div><div class="line">    .line 34</div><div class="line">    :goto_e</div><div class="line">    const/4 v0, 0x2</div><div class="line">    :try_start_f</div><div class="line">    new-array v0, v0, [I</div><div class="line">    fill-array-data v0, :array_42   //fill-array-data-payload</div><div class="line">    .line 35</div><div class="line">    const/4 v1, 0x2</div><div class="line">    aget v0, v0, v1</div><div class="line">    :try_end_17</div><div class="line">    .catch Ljava/lang/Exception; &#123;:try_start_f .. :try_end_17&#125; :catch_3a</div><div class="line">    .line 40</div><div class="line">    :goto_17</div><div class="line">    return-void</div><div class="line">    .line 10</div><div class="line">    :catch_18       //同样的异常代码没有被优化</div><div class="line">    move-exception v0</div><div class="line">    .line 11</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const-string v1, &quot;zero error.&quot;</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</div><div class="line">    goto :goto_4</div><div class="line">    .line 18</div><div class="line">    :catch_21</div><div class="line">    move-exception v0</div><div class="line">    .line 19</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const-string v1, &quot;zero error.&quot;</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</div><div class="line">    goto :goto_9</div><div class="line">    .line 21</div><div class="line">    :catch_2a</div><div class="line">    move-exception v0</div><div class="line">    .line 22</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/Object;)V</div><div class="line">    goto :goto_9</div><div class="line">    .line 30</div><div class="line">    :catch_31</div><div class="line">    move-exception v0</div><div class="line">    .line 31</div><div class="line">    :try_start_32</div><div class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const-string v1, &quot;zero error.&quot;</div><div class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</div><div class="line">    :try_end_39</div><div class="line">    .catch Ljava/lang/Exception; &#123;:try_start_32 .. :try_end_39&#125; :catch_3a</div><div class="line">    goto :goto_e</div><div class="line">    .line 37</div><div class="line">    :catch_3a</div><div class="line">    move-exception v0</div><div class="line">    .line 38</div><div class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/Object;)V</div><div class="line">    goto :goto_17</div><div class="line">    .line 34</div><div class="line">    nop</div><div class="line">    :array_42   //fill-array-data-payload</div><div class="line">    .array-data 4</div><div class="line">        0x0</div><div class="line">        0x0</div><div class="line">    .end array-data</div><div class="line">.end method</div></pre></td></tr></table></figure>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>try 代码块以两个标号为界，<code>:try_start_数字</code> 和 <code>:try_end_数字</code>，（不晓得这一段的数字为什么没有规律）。<br>紧接着是 catch 的格式：<br><code>.catch 异常类 {try起始标号 .. try结束标号} catch代码标号</code><br>java 并没有对重复的 catch 代码进行优化，但是变量的定义被挪到了 try 之外。<br>嵌套的 try-catch 被分成了单个的 try-catch .</p>
<h3 id="try-在-dex-中的存在"><a href="#try-在-dex-中的存在" class="headerlink" title="try 在 dex 中的存在"></a>try 在 dex 中的存在</h3><p>关于try-catch是如何在dex文件中存在的参考<a href="http://kiya-z.github.io/2015/11/21/parse-dex-file-part-classdefs/" target="_blank" rel="external">解析 dex 文件结构 - 索引区和数据区（三） - ClassDefs</a> .</p>
<p><strong>下面是手动查找：</strong></p>
<p>前期准备:<br>classDefsSize: 0x1<br>classDefsOff: 0x128<br>directMethodsSize: 0x2<br>func函数的codeOff: 0x160<br>DexCode.triesSize: 0x05<br>try-catch 地址: 0x204,数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">00000200  .. .. .. .. 02 00 00 00  02 00 01 00 07 00 00 00  |................|</div><div class="line">00000210  02 00 04 00 0c 00 00 00  02 00 09 00 0f 00 00 00  |................|</div><div class="line">00000220  08 00 0e 00 32 00 00 00  07 00 0e 00 04 01 02 18  |....2...........|</div><div class="line">00000230  02 02 21 03 2a 02 02 31  03 3a 01 03 3a</div></pre></td></tr></table></figure></p>
<p>首先是0x5个DexTry,</p>
<table>
<thead>
<tr>
<th>startAddr</th>
<th>insnCount</th>
<th>handlerOff</th>
<th>对应的异常和handler(由下表所得)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x02</td>
<td>0x02</td>
<td>0x01</td>
<td>0号handler: 抓到 ArithmeticException</td>
</tr>
<tr>
<td>0x07</td>
<td>0x02</td>
<td>0x04</td>
<td>1号handler: 抓到 ArithmeticException和Exception</td>
</tr>
<tr>
<td>0x0c</td>
<td>0x02</td>
<td>0x09</td>
<td>2号handler: 抓到 ArithmeticException和Exception</td>
</tr>
<tr>
<td>0x0f</td>
<td>0x08</td>
<td>0x0e</td>
<td>3号handler: 抓到 Exception</td>
</tr>
<tr>
<td>0x32</td>
<td>0x07</td>
<td>0x0e</td>
<td>3号handler: 抓到 Exception</td>
</tr>
</tbody>
</table>
<p>[<em>注</em>]这里的handleroff是以handler_list为起始的偏移</p>
<p><code>catch_handler列表个数</code>: 0x04<br>下面是0x04个catch_handler：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>size</th>
<th>typeId</th>
<th>addr</th>
<th>catch_all_addr</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>0x01</td>
<td>0x02(java.lang.ArithmeticException)</td>
<td>0x18</td>
<td>-</td>
</tr>
<tr>
<td>0x1</td>
<td>0x02</td>
<td>0x02(java.lang.ArithmeticException)</td>
<td>0x21</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>0x03(java.lang.Exception)</td>
<td>0x2a</td>
<td>-</td>
</tr>
<tr>
<td>0x2</td>
<td>0x02</td>
<td>0x02(java.lang.ArithmeticException)</td>
<td>0x31</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>0x03(java.lang.Exception)</td>
<td>0x3a</td>
<td>-</td>
</tr>
<tr>
<td>0x03</td>
<td>0x01</td>
<td>0x03(java.lang.Exception)</td>
<td>0x3a</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>下面是使用 dexdump 的数据：</strong><br>可用来验证结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Processing &apos;HeyTry.dex&apos;...</div><div class="line">Opened &apos;HeyTry.dex&apos;, DEX version &apos;035&apos;</div><div class="line">Class #0            -</div><div class="line">  Class descriptor  : &apos;LHeyTry;&apos;</div><div class="line">  Access flags      : 0x0000 ()</div><div class="line">  Superclass        : &apos;Ljava/lang/Object;&apos;</div><div class="line">  Interfaces        -</div><div class="line">  Static fields     -</div><div class="line">  Instance fields   -</div><div class="line">  Direct methods    -</div><div class="line">    #0              : (in LHeyTry;)</div><div class="line">      name          : &apos;&lt;init&gt;&apos;</div><div class="line">      type          : &apos;()V&apos;</div><div class="line">      access        : 0x10000 (CONSTRUCTOR)</div><div class="line">      code          -</div><div class="line">      registers     : 1</div><div class="line">      ins           : 1</div><div class="line">      outs          : 1</div><div class="line">      insns size    : 4 16-bit code units</div><div class="line">      catches       : (none)</div><div class="line">      positions     :</div><div class="line">        0x0000 line=3</div><div class="line">      locals        :</div><div class="line">        0x0000 - 0x0004 reg=0 this LHeyTry;</div><div class="line">    #1              : (in LHeyTry;)</div><div class="line">      name          : &apos;func&apos;</div><div class="line">      type          : &apos;()V&apos;</div><div class="line">      access        : 0x0009 (PUBLIC STATIC)</div><div class="line">      code          -</div><div class="line">      registers     : 2</div><div class="line">      ins           : 0</div><div class="line">      outs          : 2</div><div class="line">      insns size    : 74 16-bit code units  //共74条指令</div><div class="line">      catches       : 5     //五个catch</div><div class="line">        0x0002 - 0x0004     //startAddr + insnCount</div><div class="line">          Ljava/lang/ArithmeticException; -&gt; 0x0018</div><div class="line">        0x0007 - 0x0009</div><div class="line">          Ljava/lang/ArithmeticException; -&gt; 0x0021</div><div class="line">          Ljava/lang/Exception; -&gt; 0x002a</div><div class="line">        0x000c - 0x000e</div><div class="line">          Ljava/lang/ArithmeticException; -&gt; 0x0031</div><div class="line">          Ljava/lang/Exception; -&gt; 0x003a</div><div class="line">        0x000f - 0x0017</div><div class="line">          Ljava/lang/Exception; -&gt; 0x003a</div><div class="line">        0x0032 - 0x0039</div><div class="line">          Ljava/lang/Exception; -&gt; 0x003a</div><div class="line">      positions     :</div><div class="line">        0x0000 line=8</div><div class="line">        0x0004 line=15</div><div class="line">        0x0005 line=16</div><div class="line">        0x0009 line=26</div><div class="line">        0x000a line=28</div><div class="line">        0x000e line=34</div><div class="line">        0x0014 line=35</div><div class="line">        0x0017 line=40</div><div class="line">        0x0018 line=10</div><div class="line">        0x0019 line=11</div><div class="line">        0x0021 line=18</div><div class="line">        0x0022 line=19</div><div class="line">        0x002a line=21</div><div class="line">        0x002b line=22</div><div class="line">        0x0031 line=30</div><div class="line">        0x0032 line=31</div><div class="line">        0x003a line=37</div><div class="line">        0x003b line=38</div><div class="line">        0x0041 line=34</div><div class="line">      locals        :</div><div class="line">  Virtual methods   -</div><div class="line">  source_file_idx   : 1 (HeyTry.java)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> smali </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解析 dex 文件结构 - 索引区和数据区（三） - ClassDefs]]></title>
      <url>/2015/11/21/parse-dex-file-part-classdefs/</url>
      <content type="html"><![CDATA[<p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dex-file-general-structure-3.png" alt="part-class-defs"></p>
<a id="more"></a>
<p>ClassDefs 表示某个类的全部信息，包括类类型、访问权限、父类、接口、源文件名、注解和代码等信息。<br>ClassDefs 的大小和文件偏移在 DexHeader 和 map_list 中都有指定。</p>
<hr>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>ClassDefs 以4字节对齐，即总大小为 4 * 8 * ClassDefsSize .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;class_def_item&quot;.</div><div class="line"> */</div><div class="line">struct DexClassDef &#123;</div><div class="line">    u4  classIdx;           /* 指向 typeIds 的索引，表示类的类型 */</div><div class="line">    u4  accessFlags;        /* 类的访问标识*/</div><div class="line">    u4  superclassIdx;      /* 指向 typeIds 的索引，表示父类类型 */</div><div class="line">    u4  interfacesOff;      /* 指向 DexTypeList 的文件偏移，表示接口*/</div><div class="line">    u4  sourceFileIdx;      /* 指向 stringIds 的索引，表示源文件名 */</div><div class="line">    u4  annotationsOff;     /* 指向 annotations_directory_item 的文件偏移，表示注解*/</div><div class="line">    u4  classDataOff;       /* 指向 class_data_item 的文件偏移*/</div><div class="line">    u4  staticValuesOff;    /* 指向 DexEncodedArray 的文件偏移*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="classIdx"><a href="#classIdx" class="headerlink" title="classIdx"></a>classIdx</h2><p>指向 typeIds 的索引，类类型，必须是一个类类型而不是数组或者基本类型。</p>
<hr>
<h2 id="accessFlags"><a href="#accessFlags" class="headerlink" title="accessFlags"></a>accessFlags</h2><p>类的访问标识，如 public、final 等，常量定义如下，包括类、字段和方法的访问标识：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>For Classes (and InnerClass annotations)</th>
<th>For Fields</th>
<th>For Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x1</td>
<td>public: visible everywhere</td>
<td>public: visible everywhere</td>
<td>public: visible everywhere</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x2</td>
<td>* private: only visible to defining class</td>
<td>private: only visible to defining class</td>
<td>private: only visible to defining class</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x4</td>
<td>* protected: visible to package and subclasses</td>
<td>protected: visible to package and subclasses</td>
<td>protected: visible to package and subclasses</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x8</td>
<td>* static: is not constructed with an outer this reference</td>
<td>static: global to defining class</td>
<td>static: does not take a this argument</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x10</td>
<td>final: not subclassable</td>
<td>final: immutable after construction</td>
<td>final: not overridable</td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td>0x20</td>
<td></td>
<td></td>
<td>synchronized: associated lock automatically acquired around call to this method.Note: This is only valid to set when ACC_NATIVE is also set.</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x40</td>
<td></td>
<td></td>
<td>bridge method, added automatically by compiler as a type-safe bridge</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x40</td>
<td></td>
<td>volatile: special access rules to help with thread safety</td>
<td></td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x80</td>
<td></td>
<td>transient: not to be saved by default serialization</td>
<td></td>
</tr>
<tr>
<td>ACC_VARARGS</td>
<td>0x80</td>
<td></td>
<td></td>
<td>last argument should be treated as a “rest” argument by compiler</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td>0x100</td>
<td></td>
<td></td>
<td>native: implemented in native code</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x200</td>
<td>interface: multiply-implementable abstract class</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x400</td>
<td>abstract: not directly instantiable</td>
<td></td>
<td>abstract: unimplemented by this class</td>
</tr>
<tr>
<td>ACC_STRICT</td>
<td>0x800</td>
<td></td>
<td></td>
<td>strictfp: strict rules for floating-point arithmetic</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>not directly defined in source code</td>
<td>not directly defined in source code</td>
<td>not directly defined in source code</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>declared as an annotation class</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>declared as an enumerated type</td>
<td>declared as an enumerated value</td>
<td></td>
</tr>
<tr>
<td>(unused)</td>
<td>0x8000</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ACC_CONSTRUCTOR</td>
<td>0x10000</td>
<td></td>
<td></td>
<td>constructor method (class or instance initializer)</td>
</tr>
<tr>
<td>ACC_DECLARED_SYNCHRONIZED</td>
<td>0x20000</td>
<td></td>
<td></td>
<td>declared synchronized. Note: This has no effect on execution (other than in reflection of this flag, per se).</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="superclassIdx"><a href="#superclassIdx" class="headerlink" title="superclassIdx"></a>superclassIdx</h2><p>指向 typeIds 的索引，父类类型；如果没有父类值为 NO_INDEX . 注意 NO_INDEX 值不是0，因为 0 是一个合法的索引，而且 NO_INDEX 是以 uleb128p1 编码的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uint NO_INDEX = 0xffffffff;    // == -1 if treated as a signed int</div></pre></td></tr></table></figure>
<hr>
<h2 id="interfacesOff"><a href="#interfacesOff" class="headerlink" title="interfacesOff"></a>interfacesOff</h2><p>指向 DexTypeList 的文件偏移（在数据段中），表示接口；如果没有接口此值为 0 。<br>DexTypeList 中的值必须是类类型，并且没有重复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;type_list&quot;.</div><div class="line"> */</div><div class="line">struct DexTypeList &#123;</div><div class="line">    u4  size;               /* DexTypeItem的个数 */</div><div class="line">    DexTypeItem list[1];    /* DexTypeItem的内容 */</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line"> * Direct-mapped &quot;type_item&quot;.</div><div class="line"> */</div><div class="line">struct DexTypeItem &#123;</div><div class="line">    u2  typeIdx;            /* 指向 typeIds 的索引 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="sourceFileIdx"><a href="#sourceFileIdx" class="headerlink" title="sourceFileIdx"></a>sourceFileIdx</h2><p>指向 stringIds 的索引，表示本类所在的源文件名，如果没有这个信息值为 NO_INDEX</p>
<hr>
<h2 id="annotationsOff"><a href="#annotationsOff" class="headerlink" title="annotationsOff"></a>annotationsOff</h2><p>指向 annotations_directory_item 的文件偏移，表示注解；如果没有注解，此值为 0 。</p>
<h3 id="annotations-directory-item"><a href="#annotations-directory-item" class="headerlink" title="annotations_directory_item"></a>annotations_directory_item</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;annotations_directory_item&quot;.</div><div class="line"> */</div><div class="line">struct DexAnnotationsDirectoryItem &#123;</div><div class="line">    u4  classAnnotationsOff;  /* 指向 DexAnnotationSetItem 的文件偏移，若无，值为0*/</div><div class="line">    u4  fieldsSize;           /* DexFieldAnnotationsItem 的个数*/</div><div class="line">    u4  methodsSize;          /* DexMethodAnnotationsItem 的个数*/</div><div class="line">    u4  parametersSize;       /* DexParameterAnnotationsItem 的个数*/</div><div class="line">    /* followed by DexFieldAnnotationsItem[fieldsSize] */</div><div class="line">    /* followed by DexMethodAnnotationsItem[methodsSize] */</div><div class="line">    /* followed by DexParameterAnnotationsItem[parametersSize] */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="annotation-set-item"><a href="#annotation-set-item" class="headerlink" title="annotation_set_item"></a>annotation_set_item</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;annotation_set_item&quot;.</div><div class="line"> */</div><div class="line">struct DexAnnotationSetItem &#123;</div><div class="line">    u4  size;               /* DexAnnotationItem 的个数*/</div><div class="line">    u4  entries[1];         /* DexAnnotationItem 的内容*/</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line"> * Direct-mapped &quot;annotation_item&quot;.</div><div class="line"> *</div><div class="line"> * NOTE: this structure is byte-aligned.</div><div class="line"> */</div><div class="line">struct DexAnnotationItem &#123;</div><div class="line">    u1  visibility;     /* 可见性 */</div><div class="line">    u1  annotation[1];  /* 以 encoded_annotation 格式编码 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>visibility 定义:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>VISIBILITY_BUILD</td>
<td>0x00</td>
<td>编译时可见</td>
</tr>
<tr>
<td>VISIBILITY_RUNTIME</td>
<td>0x01</td>
<td>运行时可见</td>
</tr>
<tr>
<td>VISIBILITY_SYSTEM</td>
<td>0x02</td>
<td>运行时可见, 但是只对系统可见，用户代码不可见</td>
</tr>
</tbody>
</table>
<p><strong>encoded_annotation 格式定义：</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type_idx</td>
<td>uleb128</td>
<td>注解类型. 必须是类类型.</td>
</tr>
<tr>
<td>size</td>
<td>uleb128</td>
<td>注解中 name-value 键值对的个数.</td>
</tr>
<tr>
<td>elements</td>
<td>annotation_element[size]</td>
<td>注解的元素（不是偏移）. 元素需按 string_id 的索引升序排列.</td>
</tr>
</tbody>
</table>
<p><strong>annotation_element格式：</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>name_idx</td>
<td>uleb128</td>
<td>代表元素名称，是指向 stringIds 的索引 .</td>
</tr>
<tr>
<td>value</td>
<td>encoded_value</td>
<td>元素值</td>
</tr>
</tbody>
</table>
<p><strong>encoded_value格式：</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>(value_arg &lt;&lt; 5) &#124; value_type</td>
<td>ubyte</td>
<td>表示后面 value 的类型， 可选高三位 clarifying argument .下面详述. value_arg 表示 value 的长度(size - 1), 比如 0 表示 value 需要 1字节, 7 表示 value 需要8字节，不过还是有例外，下面详述.</td>
</tr>
<tr>
<td>value</td>
<td>ubyte[]</td>
<td>值，不同的类型有不同的解码方式, 通常是小端存储。</td>
</tr>
</tbody>
</table>
<p><strong>value 的格式：</strong></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>类型值</th>
<th>value_arg Format</th>
<th>value Format</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>VALUE_BYTE</td>
<td>0x00</td>
<td>必须是0</td>
<td>ubyte[1]</td>
<td>有符号1字节整形值</td>
</tr>
<tr>
<td>VALUE_SHORT</td>
<td>0x02</td>
<td>size - 1 (0…1)</td>
<td>ubyte[size]</td>
<td>有符号4字节整型值，符号扩展</td>
</tr>
<tr>
<td>VALUE_CHAR</td>
<td>0x03</td>
<td>size - 1 (0…1)</td>
<td>ubyte[size]</td>
<td>无符号4字节整型值，0扩展</td>
</tr>
<tr>
<td>VALUE_INT</td>
<td>0x04</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>有符号4字节整型值，符号扩展</td>
</tr>
<tr>
<td>VALUE_LONG</td>
<td>0x06</td>
<td>size - 1 (0…7)</td>
<td>ubyte[size]</td>
<td>有符号8字节整型值，符号扩展</td>
</tr>
<tr>
<td>VALUE_FLOAT</td>
<td>0x10</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>4字节位模式，0扩展为右侧，以 IEEE754 32位浮点类型解码</td>
</tr>
<tr>
<td>VALUE_DOUBLE</td>
<td>0x11</td>
<td>size - 1 (0…7)</td>
<td>ubyte[size]</td>
<td>8字节位模式，0扩展为右侧，以 IEEE754 64位浮点类型解码</td>
</tr>
<tr>
<td>VALUE_STRING</td>
<td>0x17</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>无符号(0扩展)4字节整形,解码为指向string_ids的索引，代表字符串</td>
</tr>
<tr>
<td>VALUE_TYPE</td>
<td>0x18</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>符号(0扩展)4字节整形,解码为指向type_ids的索引，代表类型或类</td>
</tr>
<tr>
<td>VALUE_FIELD</td>
<td>0x19</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>符号(0扩展)4字节整形,解码为指向field_ids的索引，代表字段</td>
</tr>
<tr>
<td>VALUE_METHOD</td>
<td>0x1a</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>符号(0扩展)4字节整形,解码为指向method_ids的索引，代表方法</td>
</tr>
<tr>
<td>VALUE_ENUM</td>
<td>0x1b</td>
<td>size - 1 (0…3)</td>
<td>ubyte[size]</td>
<td>无符号(0扩展)4字节整形,解码为指向field_ids的索引，代表枚举常量</td>
</tr>
<tr>
<td>VALUE_ARRAY</td>
<td>0x1c</td>
<td>必须是0</td>
<td>encoded_array</td>
<td>数组，格式为encoded_array format.</td>
</tr>
<tr>
<td>VALUE_ANNOTATION</td>
<td>0x1d</td>
<td>必须是0</td>
<td>encoded_annotation</td>
<td>子注解, 格式为encoded_annotation format.</td>
</tr>
<tr>
<td>VALUE_NULL</td>
<td>0x1e</td>
<td>必须是0</td>
<td>(none)</td>
<td>null</td>
</tr>
<tr>
<td>VALUE_BOOLEAN</td>
<td>0x1f</td>
<td>boolean (0…1)</td>
<td>(none)</td>
<td>一比特的值， 0 代表 false ， 1 代表 true.</td>
</tr>
</tbody>
</table>
<h4 id="field-annotations-item"><a href="#field-annotations-item" class="headerlink" title="field_annotations_item"></a>field_annotations_item</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;field_annotations_item&quot;.</div><div class="line"> */</div><div class="line">struct DexFieldAnnotationsItem &#123;</div><div class="line">    u4  fieldIdx;</div><div class="line">    u4  annotationsOff;             /* 指向 DexAnnotationSetItem 的文件偏移*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="method-annotations-item"><a href="#method-annotations-item" class="headerlink" title="method_annotations_item"></a>method_annotations_item</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;method_annotations_item&quot;.</div><div class="line"> */</div><div class="line">struct DexMethodAnnotationsItem &#123;</div><div class="line">    u4  methodIdx;</div><div class="line">    u4  annotationsOff;             /* 指向 DexAnnotationSetItem 的文件偏移 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="parameter-annotations-item"><a href="#parameter-annotations-item" class="headerlink" title="parameter_annotations_item"></a>parameter_annotations_item</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;parameter_annotations_item&quot;.</div><div class="line"> */</div><div class="line">struct DexParameterAnnotationsItem &#123;</div><div class="line">    u4  methodIdx;</div><div class="line">    u4  annotationsOff;             /* 指向 DexAnnotationSetRefList 的文件偏移*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;annotation_set_ref_list&quot;.</div><div class="line"> */</div><div class="line">struct DexAnnotationSetRefList &#123;</div><div class="line">    u4  size;</div><div class="line">    DexAnnotationSetRefItem list[1];</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line"> * Direct-mapped &quot;annotation_set_ref_item&quot;.</div><div class="line"> */</div><div class="line">struct DexAnnotationSetRefItem &#123;</div><div class="line">    u4  annotationsOff;             /* offset to DexAnnotationSetItem */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* annotation constants */</div><div class="line">enum &#123;</div><div class="line">    kDexVisibilityBuild         = 0x00,     /* annotation visibility */</div><div class="line">    kDexVisibilityRuntime       = 0x01,</div><div class="line">    kDexVisibilitySystem        = 0x02,</div><div class="line">    kDexAnnotationByte          = 0x00,</div><div class="line">    kDexAnnotationShort         = 0x02,</div><div class="line">    kDexAnnotationChar          = 0x03,</div><div class="line">    kDexAnnotationInt           = 0x04,</div><div class="line">    kDexAnnotationLong          = 0x06,</div><div class="line">    kDexAnnotationFloat         = 0x10,</div><div class="line">    kDexAnnotationDouble        = 0x11,</div><div class="line">    kDexAnnotationString        = 0x17,</div><div class="line">    kDexAnnotationType          = 0x18,</div><div class="line">    kDexAnnotationField         = 0x19,</div><div class="line">    kDexAnnotationMethod        = 0x1a,</div><div class="line">    kDexAnnotationEnum          = 0x1b,</div><div class="line">    kDexAnnotationArray         = 0x1c,</div><div class="line">    kDexAnnotationAnnotation    = 0x1d,</div><div class="line">    kDexAnnotationNull          = 0x1e,</div><div class="line">    kDexAnnotationBoolean       = 0x1f,</div><div class="line">    kDexAnnotationValueTypeMask = 0x1f,     /* low 5 bits */</div><div class="line">    kDexAnnotationValueArgShift = 5,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="classDataOff"><a href="#classDataOff" class="headerlink" title="classDataOff"></a>classDataOff</h2><p>指向 class_data_item 的文件偏移，如果此类没有数据(如接口)，值为0.<br>除了 DexCode 之外的结构是定义在 /dalvik/libdex/DexCLass.h 文件中的，并且采用的是 uleb128 编码方式。与之前不同</p>
<h3 id="class-data-item-定义"><a href="#class-data-item-定义" class="headerlink" title="class_data_item 定义"></a>class_data_item 定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/* expanded form of class_data_item. Note: If a particular item is</div><div class="line"> * absent (e.g., no static fields), then the corresponding pointer</div><div class="line"> * is set to NULL. */</div><div class="line">struct DexClassData &#123;</div><div class="line">    DexClassDataHeader header;          /* 字段与方法的个数 */</div><div class="line">    DexField*          staticFields;    /* 静态字段结构 */</div><div class="line">    DexField*          instanceFields;    /* 实例字段结构 */</div><div class="line">    DexMethod*         directMethods;    /* 直接方法结构 */</div><div class="line">    DexMethod*         virtualMethods;    /* 虚方法结构 */</div><div class="line">&#125;;</div><div class="line">/* expanded form of a class_data_item header */</div><div class="line">struct DexClassDataHeader &#123;</div><div class="line">    u4 staticFieldsSize;    /*静态字段个数*/</div><div class="line">    u4 instanceFieldsSize;  /*实例字段的个数*/</div><div class="line">    u4 directMethodsSize;   /*直接方法的个数*/</div><div class="line">    u4 virtualMethodsSize;  /*虚方法的个数*/</div><div class="line">&#125;;</div><div class="line">/* expanded form of encoded_field */</div><div class="line">struct DexField &#123;</div><div class="line">    u4 fieldIdx;    /*指向 DexFieldId 的索引 */</div><div class="line">    u4 accessFlags; /* 访问标识 */</div><div class="line">&#125;;</div><div class="line">/* expanded form of encoded_method */</div><div class="line">struct DexMethod &#123;</div><div class="line">    u4 methodIdx;    /* 指向 DexMethodId 的索引 */</div><div class="line">    u4 accessFlags;  /* 访问标识 */</div><div class="line">    u4 codeOff;      /* 指向 DexCode 的文件偏移，如果方法是abstract或者native的，值为0*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="code-item"><a href="#code-item" class="headerlink" title="code_item"></a>code_item</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;code_item&quot;.</div><div class="line"> *</div><div class="line"> * The &quot;catches&quot; table is used when throwing an exception,</div><div class="line"> * &quot;debugInfo&quot; is used when displaying an exception stack trace or</div><div class="line"> * debugging. An offset of zero indicates that there are no entries.</div><div class="line"> */</div><div class="line">struct DexCode &#123;</div><div class="line">    u2  registersSize;      /* 使用的寄存器个数 */</div><div class="line">    u2  insSize;            /* 参数个数 */</div><div class="line">    u2  outsSize;           /* 调用其他方法时使用的寄存器个数 */</div><div class="line">    u2  triesSize;          /* Try 的个数*/</div><div class="line">    u4  debugInfoOff;       /* 调试信息(行号和局部变量信息)的文件偏移，没有的话值为0，结构为 debug_info_item*/</div><div class="line">    u4  insnsSize;          /* 指令个数，以2字节为单位*/</div><div class="line">    u2  insns[1];           /* 指令数组，指令含义参考dalvik字节码格式*/</div><div class="line">    /* 2字节用于对齐(try的结构是以4字节对齐的，只有triesSize不为0且insnsSize为奇数的时候此值才会出现) */</div><div class="line">    /* try_item[triesSize] DexTry 结构，指示哪里有异常，怎样处理；数组中的元素必须没有重叠和覆盖 */</div><div class="line">    /* try/catch 中 handler 的个数 */</div><div class="line">    /* catch_handler_item[handlersSize] DexCatchHandler结构*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="debug-info-item"><a href="#debug-info-item" class="headerlink" title="debug_info_item"></a>debug_info_item</h4><p>每个 debug_info_item 以一个变长的 header 开始(长度取决于方法的参数个数)，接着是操作码（用来修改状态机器码的值），最后是一个结束字节 <code>DBG_END_SEQUENCE</code>。</p>
<p><strong>状态机器码</strong> 包含5个寄存器，同时也追踪着每个寄存器中最后一个局部变量的名字和类型，为 DBG_RESTART_LOCAL 做准备。<br><code>address</code>寄存器代表两字节指令的偏移地址，在每个 debug_info 序列里以0开始，单调递增；<br><code>line</code>寄存器代表下一条指令的行数，它在 header 中被初始化，可能会加减变化但绝不会小于 1；<br><code>source_file</code>寄存器代表行数所在的源文件，它的类型是 class_def_item 中的 source_file_idx；<br><code>prologue_end</code> 和 <code>epilogue_begin</code> 是布尔类型的标识(初始值为false)，代表下一条指令是不是函数入口或者函数结束。</p>
<p><strong>header 的格式：</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>line_start</td>
<td>uleb128</td>
<td>line 寄存器的初始值，不代表真实的入口</td>
</tr>
<tr>
<td>parameters_size</td>
<td>uleb128</td>
<td>参数名字的个数. 如果是实例方法的话，不包括this.</td>
</tr>
<tr>
<td>parameter_names</td>
<td>uleb128p1[parameters_size]</td>
<td>方法的参数名的字符串索引. NO_INDEX 表示相关参数没有名字. 类型描述符和签名同方法的类型描述符和签名.</td>
</tr>
</tbody>
</table>
<p><strong>debug_info 中操作的值：</strong></p>
<table>
<thead>
<tr>
<th>名字</th>
<th>值</th>
<th>格式</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DBG_END_SEQUENCE</td>
<td>0x00</td>
<td></td>
<td>(none)</td>
<td>代表调试信息的终止</td>
</tr>
<tr>
<td>DBG_ADVANCE_PC</td>
<td>0x01</td>
<td>uleb128  addr_diff</td>
<td>addr_diff: 地址寄存器加上此值</td>
<td>使address寄存器指向下一个地址</td>
</tr>
<tr>
<td>DBG_ADVANCE_LINE</td>
<td>0x02</td>
<td>sleb128 line_diff</td>
<td>line_diff: line寄存器加上此值</td>
<td>使line寄存器指向新的一行</td>
</tr>
<tr>
<td>DBG_START_LOCAL</td>
<td>0x03</td>
<td>uleb128  register_num，uleb128p1 name_idx，uleb128p1 type_idx</td>
<td>register_num: 某个寄存器，name_idx: 指向string的索引，type_idx: 指向type的索引</td>
<td>在当前地址引入一个局部变量. name_idx 或 type_idx 可能是 NO_INDEX，代表此值未知.</td>
</tr>
<tr>
<td>DBG_START_LOCAL_EXTENDED</td>
<td>0x04</td>
<td>uleb128 register_num，uleb128p1 name_idx，uleb128p1 type_idx，uleb128p1 sig_idx</td>
<td>register_num: 某个寄存器，name_idx: 指向string的索引，type_idx: 指向type的索引，sig_idx: 指向string的索引，表示类型签名</td>
<td>在当前地址引入一个带有类型签名的局部变量. name_idx 或 type_idx、sig_idx 可能是 NO_INDEX，代表此值未知.”dalvik.annotation.Signature” 有关于处理签名的说明.</td>
</tr>
<tr>
<td>DBG_END_LOCAL</td>
<td>0x05</td>
<td>uleb128 register_num</td>
<td>register_num: 某个寄存器</td>
<td>代表当前地址的局部变量超出范围</td>
</tr>
<tr>
<td>DBG_RESTART_LOCAL</td>
<td>0x06</td>
<td>uleb128 register_num</td>
<td>register_num: 重新赋值的寄存器</td>
<td>在当前地址重新引入一个局部变量.名字和类型同上一个局部变量.</td>
</tr>
<tr>
<td>DBG_SET_PROLOGUE_END</td>
<td>0x07</td>
<td></td>
<td>(none)</td>
<td>设置 prologue_end 状态寄存器, 表示下一个入口点应该被视作方法开始的结束(可设置方法断点的合适地方). prologue_end寄存器的值可以被任何&gt;=0x0a的特殊操作码清空.</td>
</tr>
<tr>
<td>DBG_SET_EPILOGUE_BEGIN</td>
<td>0x08</td>
<td></td>
<td>(none)</td>
<td>设置epilogue_begin状态寄存器, 表示下一个入口点应该被视作方法结束的开始(在方法结束之前使其挂起的合适地方). epilogue_begin寄存器的值可以被任何&gt;=0x0a的特殊操作码清空.</td>
</tr>
<tr>
<td>DBG_SET_FILE</td>
<td>0x09</td>
<td>uleb128p1 name_idx</td>
<td>name_idx: 指向string的索引，表示源文件名; NO_INDEX 表示未知</td>
<td>表面接下来的行号入口都与这个文件相关, 而不是 code_item 指定的默认名字.</td>
</tr>
<tr>
<td>Special Opcodes</td>
<td>0x0a…0xff</td>
<td></td>
<td>(none)</td>
<td>line、address寄存器加减, 开启新的入口点, 清空 prologue_end、 epilogue_begin寄存器. 公式如下.</td>
</tr>
</tbody>
</table>
<p><strong>Special Opcodes：</strong></p>
<p>使 line、address 寄存器小幅度变化/开启一个新的入口点. 范围是 0x0a ~ 0xff .</p>
<p>DBG_FIRST_SPECIAL = 0x0a  // 最小的特殊操作码<br>DBG_LINE_BASE   = -4      // 最小的行号增量<br>DBG_LINE_RANGE  = 15      // 代表行号的变化值</p>
<p>公式：<br>adjusted_opcode = opcode - DBG_FIRST_SPECIAL<br>line += DBG_LINE_BASE + (adjusted_opcode % DBG_LINE_RANGE)<br>address += (adjusted_opcode / DBG_LINE_RANGE)</p>
<h4 id="try-item"><a href="#try-item" class="headerlink" title="try_item"></a>try_item</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;try_item&quot;.</div><div class="line"> */</div><div class="line">struct DexTry &#123;</div><div class="line">    u4  startAddr;          /* 异常起始地址, 2个字节为单位 */</div><div class="line">    u2  insnCount;          /* 指令个数, 2个字节为单位，最后一个指令为 startAddr + insnCount - 1 */</div><div class="line">    u2  handlerOff;         /* 以 handler 列表为起始的 指向异常对应的 handler 的偏移*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="catch-handler-item"><a href="#catch-handler-item" class="headerlink" title="catch_handler_item"></a>catch_handler_item</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Catch handler entry, used while iterating over catch_handler_items.</div><div class="line"> */</div><div class="line">struct DexCatchHandler &#123;</div><div class="line">    u4          typeIdx;    /* catch 到的异常的类型索引，指向 typeIds */</div><div class="line">    u4          address;    /* handler 的地址 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="番外-关于-catch-handler-list"><a href="#番外-关于-catch-handler-list" class="headerlink" title="番外 - 关于 catch_handler_list"></a>番外 - 关于 catch_handler_list</h4><p>catch_handler_list 在源码中没有定义，下面的表格是其格式：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>size</td>
<td>uleb128</td>
<td>handler 列表的个数</td>
</tr>
<tr>
<td>list</td>
<td>encoded_catch_handler[handlers_size]</td>
<td>handler 列表</td>
</tr>
</tbody>
</table>
<p>单个 catch_handler 的格式：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>size</td>
<td>sleb128</td>
<td>列表中 catch 到的类型的个数. 如果不是正数，则handler列表中含有可以捕获到所有异常的handler. 比如 0 表示没有指定异常的类型，只有一个所有异常handler. 2 表示有两个指定类型的异常. -1 有一个指定类型的异常和一个可以捕获到所有异常的handler.</td>
</tr>
<tr>
<td>handlers</td>
<td>DexCatchHandler[abs(size)]</td>
<td>abs(size) 个handler, 存放的是指定类型的异常.</td>
</tr>
<tr>
<td>catch_all_addr</td>
<td>uleb128 (optional)</td>
<td>可以处理所有异常的 handler 的地址. size为0或者负数时此值有效.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="staticValuesOff"><a href="#staticValuesOff" class="headerlink" title="staticValuesOff"></a>staticValuesOff</h2><p>指向 DexEncodedArray 的文件偏移，表示静态字段的初始值，值为0表示没有设定静态字段的初始值，静态字段被初始化为0或者null.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;encoded_array&quot;.</div><div class="line"> *</div><div class="line"> * NOTE: this structure is byte-aligned.</div><div class="line"> */</div><div class="line">struct DexEncodedArray &#123;</div><div class="line">    u1  array[1];                   /* encoded_array 格式的数据 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>encoded_array 格式：</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>size</td>
<td>uleb128</td>
<td>数组元素的个数，必须不大于静态字段的个数和对应的field_list的个数，如果是小于，剩余的静态字段按照相应的类型被初始化为0或者null.</td>
</tr>
<tr>
<td>values</td>
<td>encoded_value[size]</td>
<td>数组内容</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h1><p>classDefsSize：0x02<br>classDefsOff：0x047c</p>
<p>0x047c ~ 0x04bc</p>
<h2 id="DexClassDef数据及其解析"><a href="#DexClassDef数据及其解析" class="headerlink" title="DexClassDef数据及其解析"></a>DexClassDef数据及其解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">00000470  .. .. .. .... .. .. ..   .. .. .. .. 05 00 00 00  |------------....|</div><div class="line">00000480  01 00 00 00 0e 00 00 00  00 00 00 00 1f 00 00 00  |................|</div><div class="line">00000490  00 00 00 00 c2 0f 00 00  00 00 00 00 06 00 00 00  |................|</div><div class="line">000004a0  01 00 00 00 02 00 00 00  00 00 00 00 20 00 00 00  |............ ...|</div><div class="line">000004b0  64 0a 00 00 de 0f 00 00  00 00 00 00</div></pre></td></tr></table></figure>
<p>以第一个为例：</p>
<ol>
<li><p><code>classIdx</code>=0x05，即第0x05个typeId，得类类型为 Lcom/shell/NativeApplication;</p>
</li>
<li><p><code>accessFlags</code>=0x01，查表得权限 ACC_PUBLIC</p>
</li>
<li><p><code>superclassIdx</code>=0x0e，即第0x0e个typeId，得父类类型为 Ljava/lang/Object;</p>
</li>
<li><p><code>interfacesOff</code>=0x0000，没有实现接口</p>
</li>
<li><p><code>sourceFileIdx</code>=0x1f，即第0x1f个stringId，得源文件名为 NativeApplication.java</p>
</li>
<li><p><code>annotationsOff</code>=0x0000，没有注解</p>
</li>
<li><p><code>classDataOff</code>=0x0fc2，得DexClassData偏移为0x0fc2</p>
</li>
<li><p><code>staticValuesOff</code>=0x0000，没有静态数据的初始值</p>
</li>
</ol>
<h2 id="DexClassData数据及其解析"><a href="#DexClassData数据及其解析" class="headerlink" title="DexClassData数据及其解析"></a>DexClassData数据及其解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">00000fc0  .. .. 00 00 05 00 03 88  80 04 90 18 01 81 80 04  |................|</div><div class="line">00000fd0  b8 18 01 89 02 00 01 89  02 00 01 89 02 00 00 00  |................|</div><div class="line">00000fe0  03 04 08 81 80 04 d0 18  03 02 e8 18 01 09 f4 19  |................|</div></pre></td></tr></table></figure>
<p>[<strong>注意DexClassData中数字的类型为uleb128</strong>]<br>① <strong>header</strong>：<code>staticFieldsSize</code>=0x00, <code>instanceFieldsSize</code>=0x00, <code>directMethodsSize</code>=0x05, <code>virtualMethodsSize</code>=0x00, 即0个静态字段，0个实例字段，5个直接方法，0个虚方法；</p>
<p>② <strong>directMethods</strong>：(共5个，以第一个为例)</p>
<ul>
<li><code>methodIdx</code>=0x03，即第0x03个methodId，得直接方法为 void com.shell.NativeApplication.<clinit>()</clinit></li>
<li><code>accessFlags</code>=<code>88 80 04</code>，解码为0x10008，得方法访问权限为 ACC_STATIC 和 ACC_CONSTRUCTOR</li>
<li><code>codeOff</code>=<code>90 18</code>，解码为0xc10，得 DexCode 偏移为 0xc10</li>
</ul>
<h2 id="DexCode数据及其解析"><a href="#DexCode数据及其解析" class="headerlink" title="DexCode数据及其解析"></a>DexCode数据及其解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">00000c10  01 00 00 00 01 00 00 00  7c 0a 00 00 0b 00 00 00  |........|.......|</div><div class="line">00000c20  1a 00 00 00 71 10 20 00  00 00 1a 00 01 00 71 10  |....q. .......q.|</div><div class="line">00000c30  20 00 00 00 0e 00 00 00  01 00 01 00 01 00 00 00  | ...............|</div><div class="line">00000c40  83 0a 00 00 04 00 00 00  70 10 1d 00 00 00 0e 00  |........p.......|</div><div class="line">00000c50  01 00 01 00 01 00 00 00  88 0a 00 00 04 00 00 00  |................|</div><div class="line">00000c60  70 10 00 00 00 00 0e 00  0a 00 04 00 04 00 01 00  |p...............|</div><div class="line">00000c70  8d 0a 00 00 38 00 00 00  6e 10 12 00 09 00 0c 05  |....8...n.......|</div><div class="line">00000c80  6e 10 11 00 05 00 0a 05  39 05 09 00 6e 10 12 00  |n.......9...n...|</div></pre></td></tr></table></figure>
<ul>
<li><code>registersSize</code>=0x0001，得寄存器个数为1</li>
<li><code>insSize</code>=0x0000，得参数个数为0</li>
<li><code>outsSize</code>=0x0001，调用其他方法使用寄存器个数为1</li>
<li><code>triesSize</code>=0x0000，try的个数为0</li>
<li><code>debugInfoOff</code>=0x0a7c，debug信息偏移为0x0a7c</li>
<li><code>insnsSize</code>=0x0b，即有0xb个2字节指令，在 0x00000c20 ~ 0x00000c35 之间</li>
<li><code>insns</code>={1a 00 00 00 71 10 20 00 00 00 1a 00 01 00 71 10 20 00 00 00 0e 00}</li>
</ul>
<h3 id="debug-info数据及其解析"><a href="#debug-info数据及其解析" class="headerlink" title="debug_info数据及其解析"></a>debug_info数据及其解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">00000a70  .. .. .. .. .. .. .. ..  .. .. .. .. 09 00 07 0e  |........\.......|</div><div class="line">00000a80  5a 56 00</div></pre></td></tr></table></figure>
<ul>
<li><strong>header:</strong><br>  line_start(09)=0x09，得line寄存器的初始值为0x09；<br>  parameters_size(0x00)=0x00，得参数的名字的个数为0；</li>
<li><strong>操作码：</strong><br>  <code>0x07</code>:DBG_SET_PROLOGUE_END，方法开始；<br>  <code>0x0e</code>:0x0e-0x0a=0x04,即行号+=DBG_LINE_BASE+(0x04%DBG_LINE_RANGE),地址+=(0x04/DBG_LINE_RANGE),得行号+0,地址+0;<br>  <code>0x5a</code>:0x5a-0x0a=0x50,即行号+=DBG_LINE_BASE+(0x50%DBG_LINE_RANGE),地址+=(0x50/DBG_LINE_RANGE),得行号+1,地址+5;<br>  <code>0x56</code>:0x56-0x0a=0x4c,即行号+=DBG_LINE_BASE+(0x4c%DBG_LINE_RANGE),地址+=(0x4c/DBG_LINE_RANGE),得行号+1,地址+5;<br>  <code>0x00</code>:DBG_END_SEQUENCE，调试结束。</li>
</ul>
<h3 id="insns-中的指令数据的解析"><a href="#insns-中的指令数据的解析" class="headerlink" title="insns 中的指令数据的解析"></a>insns 中的指令数据的解析</h3><p>在 <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">Dalvik bytecode</a> 找到 OpCode 的含义及格式，在 <a href="https://source.android.com/devices/tech/dalvik/instruction-formats.html" target="_blank" rel="external">Dalvik Executable instruction formats</a> 找到该格式的表示方式。</p>
<p><strong>第1条代码：</strong></p>
<p><strong>1a</strong> ： 含义为 <code>const-string vAA, string@BBBB</code>， 格式为 <code>1a 21c</code><br><strong>21c</strong> : 格式为 <code>AA|op BBBB</code>，表示方式有三种：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">op vAA, type@BBBB</div><div class="line">op vAA, field@BBBB</div><div class="line">op vAA, string@BBBB</div></pre></td></tr></table></figure></p>
<p><code>1a</code> 的含义已经为我们指明，我们应该采用第三种。1a 后面的6个字节为 <code>00 00 00</code>，即 AA 是 00，BBBB 是 0000。<br>则可翻译为 <code>const-string v0, string@0000</code>， 找到第0x0个 StringId 对应的字符串 /data/data/com.zyh.lightingbackup/.lib/libexec.so .<br>最终解析为 <code>const-string v0, &quot;/data/data/com.zyh.lightingbackup/.lib/libexec.so&quot;</code></p>
<p><strong>第2条代码：</strong></p>
<p><strong>71</strong> ： 含义为 <code>invoke-static</code>，格式为 <code>71 35c</code><br><strong>35c</strong> ： 格式为 <code>A|G|op BBBB F|E|D|C</code> ，表示方式有7种：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[A=5] op &#123;vC, vD, vE, vF, vG&#125;, meth@BBBB</div><div class="line">[A=5] op &#123;vC, vD, vE, vF, vG&#125;, type@BBBB</div><div class="line">[A=4] op &#123;vC, vD, vE, vF&#125;, kind@BBBB</div><div class="line">[A=3] op &#123;vC, vD, vE&#125;, kind@BBBB</div><div class="line">[A=2] op &#123;vC, vD&#125;, kind@BBBB</div><div class="line">[A=1] op &#123;vC&#125;, kind@BBBB</div><div class="line">[A=0] op &#123;&#125;, kind@BBBB</div></pre></td></tr></table></figure></p>
<p>71 后面的 A = 1, G = 0，所以应该采用方式 <code>[A=1] op {vC}, kind@BBBB</code>，<br>而 BBBB = 0020, F|E|D|C = 0000，可翻译为 <code>invoke-static {v0}, kind@0020</code>，找到第 0x20 个methodId 对应的函数 void java.lang.System.load(java.lang.String) .<br>最终解析为 <code>invoke-static {v0}, Ljava/lang/System;-&gt;load(Ljava/lang/String;)V</code></p>
<p>最后我们可以使用 apktool 将 apk 文件反编译，在 /smali/com/shell/NativeApplication.smali 文件中找到 <clinit> 方法，看代码对照！</clinit></p>
<hr>
<h1 id="写程序解析"><a href="#写程序解析" class="headerlink" title="写程序解析"></a>写程序解析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div></pre></td><td class="code"><pre><div class="line">def parseClassdef_Name(f):</div><div class="line">    return DexStruct.DexTypes[struct.unpack(&apos;I&apos;,f.read(4))[0]][&apos;content&apos;]</div><div class="line">def parseClassdef_Accessflag(f):</div><div class="line">    return struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">def parseClassdef_Superclass(f):</div><div class="line">    class_superclass_id = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    if class_superclass_id == -1:</div><div class="line">        return None</div><div class="line">    return DexStruct.DexTypes[class_superclass_id][&apos;content&apos;]</div><div class="line">def parseClassdef_Interface(f):</div><div class="line">    interface_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    if interface_off == 0:</div><div class="line">        return None</div><div class="line">    f.seek(interface_off)</div><div class="line">    type_list_size = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    type_list = []</div><div class="line">    for i in range(type_list_size):</div><div class="line">        type_id = struct.unpack(&apos;H&apos;,f.read(2))[0]</div><div class="line">        type_list.append(DexStruct.DexTypes[type_id][&apos;content&apos;])</div><div class="line">    return type_list</div><div class="line">def parseClassdef_Sourcefile(f):</div><div class="line">    class_sourcefile_id = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    if class_sourcefile_id == -1:</div><div class="line">        return None</div><div class="line">    return DexStruct.DexStrings[class_sourcefile_id][&apos;content&apos;]</div><div class="line">def parseClassdef_Annotations(f):</div><div class="line">    annotations_directory_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    if annotations_directory_off == 0:</div><div class="line">        return None</div><div class="line">    #-----------</div><div class="line">    f.seek(annotations_directory_off)</div><div class="line">    class_Annotations_Off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    field_size = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    method_size = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    parameter_size = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    #---------</div><div class="line">    annotations_directory = None</div><div class="line">    if class_Annotations_Off != 0:</div><div class="line">        # f.seek(class_Annotations_Off)</div><div class="line">        # annotation_set_item_size = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        # for i in range(annotation_set_item_size):</div><div class="line">        #     item_visibility = struct.unpack(&apos;B&apos;,f.read(1))[0]</div><div class="line">        #     item_annotation = struct.unpack(&apos;B&apos;,f.read(1))[0]</div><div class="line">        pass    # 解码暂且略过</div><div class="line">    #--------</div><div class="line">    f.seek(annotations_directory_off+4*4)</div><div class="line">    fieldAnnotation_list = []</div><div class="line">    for i in range(field_size):</div><div class="line">        field = DexStruct.DexFields[struct.unpack(&apos;I&apos;,f.read(4))[0]]</div><div class="line">        field_annotation_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        fieldAnnotation_item = &#123;</div><div class="line">            &apos;field&apos; : field,</div><div class="line">            &apos;annotationsOff&apos; : field_annotation_off,</div><div class="line">        &#125;</div><div class="line">        fieldAnnotation_list.append(fieldAnnotation_item)</div><div class="line">    #--------</div><div class="line">    f.seek(annotations_directory_off+4*4+field_size*8)</div><div class="line">    methodAnnotation_list = []</div><div class="line">    for i in range(method_size):</div><div class="line">        method= DexStruct.DexMethods[struct.unpack(&apos;I&apos;,f.read(4))[0]]</div><div class="line">        method_annotation_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        methodAnnotation_item = &#123;</div><div class="line">            &apos;method&apos; : method,</div><div class="line">            &apos;annotationsOff&apos; : method_annotation_off,</div><div class="line">        &#125;</div><div class="line">        methodAnnotation_list.append(methodAnnotation_item)</div><div class="line">    #--------</div><div class="line">    f.seek(annotations_directory_off+4*4+field_size*8+method_size*8)</div><div class="line">    parameterAnnotation_list = []</div><div class="line">    for i in range(parameter_size):</div><div class="line">        param_method = DexStruct.DexMethods[struct.unpack(&apos;I&apos;,f.read(4))[0]]</div><div class="line">        param_annotation_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        parameterAnnotation_item = &#123;</div><div class="line">            &apos;method&apos; : param_method,</div><div class="line">            &apos;annotationsOff&apos; : param_annotation_off,</div><div class="line">        &#125;</div><div class="line">        parameterAnnotation_list.append(parameterAnnotation_item)</div><div class="line">    tmpDexAnnotationsDirectoryItem = &#123;</div><div class="line">        &apos;classAnnotations&apos; : annotations_directory,</div><div class="line">        &apos;fieldSize&apos; : field_size,</div><div class="line">        &apos;methodSize&apos; : method_size,</div><div class="line">        &apos;parameterSize&apos; : parameter_size,</div><div class="line">        &apos;fieldAnnotation&apos; : fieldAnnotation_list,</div><div class="line">        &apos;methodAnnotation&apos; : methodAnnotation_list,</div><div class="line">        &apos;parameterAnnotaions&apos; : parameterAnnotation_list,</div><div class="line">    &#125;</div><div class="line">    return tmpDexAnnotationsDirectoryItem</div><div class="line">def parseClassdef_ClassData(f):</div><div class="line">    class_data_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    if class_data_off == 0:</div><div class="line">        return None</div><div class="line">    f.seek(class_data_off)</div><div class="line">    #-----</div><div class="line">    header = &#123;</div><div class="line">        &apos;staticFieldsSize&apos; : readuleb128(f),</div><div class="line">        &apos;instanceFieldsSize&apos; :  readuleb128(f),</div><div class="line">        &apos;directMethodsSize&apos; : readuleb128(f),</div><div class="line">        &apos;virtualMethodsSize&apos; : readuleb128(f),</div><div class="line">    &#125;</div><div class="line">    #-----</div><div class="line">    staticFields = []</div><div class="line">    if header[&apos;staticFieldsSize&apos;] != 0:</div><div class="line">        for i in range(header[&apos;staticFieldsSize&apos;]):</div><div class="line">            tmpstaticFields = &#123;</div><div class="line">                &apos;field&apos; : DexStruct.DexFields[readuleb128(f)],</div><div class="line">                &apos;accessFlags&apos; : readuleb128(f)</div><div class="line">            &#125;</div><div class="line">            staticFields.append(tmpstaticFields)</div><div class="line">    #-----------</div><div class="line">    instanceFields = []</div><div class="line">    if header[&apos;instanceFieldsSize&apos;] != 0:</div><div class="line">        for i in range(header[&apos;instanceFieldsSize&apos;]):</div><div class="line">            tmpinstanceFields = &#123;</div><div class="line">                &apos;field&apos; : DexStruct.DexFields[readuleb128(f)],</div><div class="line">                &apos;accessFlags&apos; : readuleb128(f)</div><div class="line">            &#125;</div><div class="line">            instanceFields.append(tmpinstanceFields)</div><div class="line">    #-----</div><div class="line">    directMethods = []</div><div class="line">    if header[&apos;directMethodsSize&apos;] != 0:</div><div class="line">        for i in range(header[&apos;directMethodsSize&apos;]):</div><div class="line">            tmpdirectMethods = &#123;</div><div class="line">                &apos;method&apos; : DexStruct.DexMethods[readuleb128(f)],</div><div class="line">                &apos;accessFlags&apos; : readuleb128(f),</div><div class="line">                &apos;codeOff&apos;: readuleb128(f),</div><div class="line">                ####### dexcode 还没解析</div><div class="line">            &#125;</div><div class="line">            directMethods.append(tmpdirectMethods)</div><div class="line">    #-----</div><div class="line">    virtualMethods = []</div><div class="line">    if header[&apos;virtualMethodsSize&apos;] != 0:</div><div class="line">        for i in range(header[&apos;virtualMethodsSize&apos;]):</div><div class="line">            tmpvirtualMethods = &#123;</div><div class="line">                &apos;method&apos; : DexStruct.DexMethods[readuleb128(f)],</div><div class="line">                &apos;accessFlags&apos; : readuleb128(f),</div><div class="line">                &apos;codeOff&apos; : readuleb128(f)</div><div class="line">                ####### dexcode 还没解析</div><div class="line">            &#125;</div><div class="line">            virtualMethods.append(tmpvirtualMethods)</div><div class="line">    DexClassData = &#123;</div><div class="line">        &apos;DexClassDataHeader&apos; : header,</div><div class="line">        &apos;staticFields&apos; : staticFields,</div><div class="line">        &apos;instanceFields&apos; : instanceFields,</div><div class="line">        &apos;directMethods&apos; : directMethods,</div><div class="line">        &apos;virtualMethods&apos; : virtualMethods,</div><div class="line">    &#125;</div><div class="line">    return DexClassData</div><div class="line">def parseClassdef_StaticValue(f):</div><div class="line">    staticvalue_off = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">    if staticvalue_off == 0:</div><div class="line">        return None</div><div class="line">    return None ## 还没解析 encoded value</div><div class="line">def parseClassdefs(f):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    此函数基于之前所有的函数结果</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    for i in range(DexStruct.DexHeader[&apos;classDefsSize&apos;]):</div><div class="line">        item_off = i*4*8 + DexStruct.DexHeader[&apos;classDefsOff&apos;]</div><div class="line">        f.seek(item_off)</div><div class="line">        class_name = parseClassdef_Name(f)</div><div class="line">        class_accessflag = parseClassdef_Accessflag(f)</div><div class="line">        class_superclass = parseClassdef_Superclass(f)</div><div class="line">        class_interface = parseClassdef_Interface(f)</div><div class="line">        f.seek(item_off+4*4)</div><div class="line">        class_sourcefile = parseClassdef_Sourcefile(f)</div><div class="line">        class_annotation = parseClassdef_Annotations(f)</div><div class="line">        f.seek(item_off+4*6)</div><div class="line">        class_classdata = parseClassdef_ClassData(f)</div><div class="line">        f.seek(item_off+4*7)</div><div class="line">        class_staticvalue = parseClassdef_StaticValue(f)</div><div class="line">        tmpDexClassDef = &#123;</div><div class="line">            &apos;class&apos; : class_name,</div><div class="line">            &apos;accessFlags&apos; : class_accessflag,</div><div class="line">            &apos;superclass&apos; : class_superclass,</div><div class="line">            &apos;interfaces&apos; : class_interface,</div><div class="line">            &apos;sourceFile&apos; : class_sourcefile,</div><div class="line">            &apos;annotations&apos; : class_annotation,</div><div class="line">            &apos;classData&apos; : class_classdata,</div><div class="line">            &apos;staticValue&apos; : class_staticvalue,</div><div class="line">        &#125;</div><div class="line">        DexStruct.DexClassDefs.append(tmpDexClassDef)</div></pre></td></tr></table></figure>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik Executable format</a></p>
<p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">《Android 软件安全与逆向分析》</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解析 dex 文件结构 - 索引区和数据区（二） - Protos & Fields & Methods]]></title>
      <url>/2015/11/20/parse-dex-file-part-protos-fields-methods/</url>
      <content type="html"><![CDATA[<p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dex-file-general-structure-2.png" alt="part-2"></p>
<a id="more"></a>
<h1 id="ProtoIds"><a href="#ProtoIds" class="headerlink" title="ProtoIds"></a>ProtoIds</h1><p>ProtoIds 存放的是<strong>原型的声明</strong>，包括原型简名、参数和返回值。<br>ProtoIds 的大小和文件偏移在 DexHeader 和 map_list 中都有指定。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>ProtoIds 以4字节对齐，即总大小为 4 * 3 * protoIdsSize .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;proto_id_item&quot;.</div><div class="line"> */</div><div class="line">struct DexProtoId &#123;</div><div class="line">    u4  shortyIdx;          /* 指向 stringIds 的索引，表示简名 */</div><div class="line">    u4  returnTypeIdx;      /* 指向 TypeIds 的索引，表示返回类型 */</div><div class="line">    u4  parametersOff;      /* 指向 type_list 的文件偏移，表示参数列表，为 0 表示没有参数，参数类型中没有空*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;type_list&quot;.</div><div class="line"> */</div><div class="line">struct DexTypeList &#123;</div><div class="line">    u4  size;               /* DexTypeItem 的个数 */</div><div class="line">    DexTypeItem list[1];    /* DexTypeItem 数组内容 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;type_item&quot;.</div><div class="line"> */</div><div class="line">struct DexTypeItem &#123;</div><div class="line">    u2  typeIdx;            /* 指向 typeIds 的索引*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h2><p><strong>某 dex 文件的 ProtoIds 部分</strong>：</p>
<p>protoIdsSize : 0x12<br>protoIdsOff : 0x0244</p>
<p>0x0244 ~ 0x031c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00000240  .. .. .. .. 06 00 00 00  00 00 00 00 40 0a 00 00  |)...........@...|</div><div class="line">00000250  07 00 00 00 01 00 00 00  00 00 00 00 08 00 00 00  |................|</div><div class="line">00000260  01 00 00 00 48 0a 00 00  09 00 00 00 08 00 00 00  |....H...........|</div><div class="line">00000270  00 00 00 00 0a 00 00 00  0c 00 00 00 f8 09 00 00  |................|</div><div class="line">00000280  09 00 00 00 0f 00 00 00  00 00 00 00 0a 00 00 00  |................|</div><div class="line">00000290  14 00 00 00 14 0a 00 00  .. .. .. .. .. .. .. ..  </div><div class="line">........  .. .. .. .. .. .. .. ..  28 00 00 00 17 00 00 00  |........(.......|</div><div class="line">00000300  2c 0a 00 00 27 00 00 00  17 00 00 00 1c 0a 00 00  |,...&apos;...........|</div><div class="line">00000310  .. .. .. .. .. .. .. ..  14 0a 00 00</div></pre></td></tr></table></figure>
<p>以第一个 DexProtoId 为例，<br>shortyIdx=0x06 =&gt; stringIdOff=0x88 =&gt; stringDataOff=0x0544 =&gt; IL<br>returnTypeIdx=0x00 =&gt; stringId=0x05 =&gt; StringIdOff=0x84 =&gt; stringDataOff=0x0541 =&gt; I<br>parametersOff=0x0a40 =&gt; <code>01 00 00 00 18 00</code> =&gt; typeIdOff=0x240 =&gt; stringIdOff=0x29 =&gt; stringDataOff=0x079c =&gt; [B<br>即此函数声明为 int (Byte[])</p>
<p><strong>以此类推：</strong></p>
<table>
<thead>
<tr>
<th>序数</th>
<th>原型</th>
<th>返回值</th>
<th>参数</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>IL</td>
<td>I</td>
<td>[B</td>
<td>int (Byte[])</td>
</tr>
<tr>
<td>0x01</td>
<td>J</td>
<td>J</td>
<td>无</td>
<td>long ()</td>
</tr>
<tr>
<td>0x02</td>
<td>JL</td>
<td>J</td>
<td>Ljava/io/File;</td>
<td>long (File)</td>
</tr>
<tr>
<td>0x03</td>
<td>L</td>
<td>Ljava/io/File;</td>
<td>无</td>
<td>File ()</td>
</tr>
<tr>
<td>0x04</td>
<td>LL</td>
<td>Ljava/io/InputStream;</td>
<td>Ljava/util/zip/ZipEntry;</td>
<td>InputStream (ZipENtry)</td>
</tr>
<tr>
<td>0x05</td>
<td>L</td>
<td>Ljava/lang/String;</td>
<td>无</td>
<td>String ()</td>
</tr>
<tr>
<td>0x06</td>
<td>LL</td>
<td>Ljava/util/zip/ZipEntry;</td>
<td>Ljava/lang/String;</td>
<td>ZipEntry (String)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0x10</td>
<td>ZLL</td>
<td>Z</td>
<td>Landroid/app/Application; Ljava/lang/String;</td>
<td>bool (Application,String)</td>
</tr>
<tr>
<td>0x11</td>
<td>ZL</td>
<td>Z</td>
<td>Ljava/lang/Object;</td>
<td>bool (Object)</td>
</tr>
<tr>
<td>0x12</td>
<td>ZL</td>
<td>Z</td>
<td>Ljava/lang/String;</td>
<td>bool (String)</td>
</tr>
</tbody>
</table>
<h2 id="写程序解析"><a href="#写程序解析" class="headerlink" title="写程序解析"></a>写程序解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">def parseProtos(f):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    此函数基于 parseStrings 和 parseTypes 函数的结果</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    cur_pos = 0</div><div class="line">    for i in range(DexStruct.DexHeader[&apos;protoIdsSize&apos;]):</div><div class="line">        f.seek(DexStruct.DexHeader[&apos;protoIdsOff&apos;] + cur_pos)</div><div class="line">        proto_shortyId = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        proto_returnTypeId = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        proto_paramtersOff = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        parameters = []</div><div class="line">        if proto_paramtersOff &gt; 0:  # 有参数再读取</div><div class="line">            f.seek(proto_paramtersOff)</div><div class="line">            param_size = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">            for j in range(param_size):</div><div class="line">                param_typeId = struct.unpack(&apos;H&apos;,f.read(2))[0]</div><div class="line">                parameters.append(DexStruct.DexTypes[param_typeId][&apos;content&apos;])</div><div class="line">        tmpDexProto = &#123;</div><div class="line">            &apos;shortyDescription&apos; : DexStruct.DexStrings[proto_shortyId][&apos;content&apos;],</div><div class="line">            &apos;returnType&apos; : DexStruct.DexTypes[proto_returnTypeId][&apos;content&apos;],</div><div class="line">            &apos;parameters&apos; :  parameters,</div><div class="line">        &#125;;</div><div class="line">        DexStruct.DexProtos.append(tmpDexProto)</div><div class="line">        cur_pos += 12</div></pre></td></tr></table></figure>
<hr>
<h1 id="FieldIds"><a href="#FieldIds" class="headerlink" title="FieldIds"></a>FieldIds</h1><p>fields 表示的是类中的字段，包括本字段所属的类、字段类型和字段名。<br>FieldIds 的大小和文件偏移在 DexHeader 和 map_list 中都有指定。</p>
<h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><p>以 4 字节对齐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;field_id_item&quot;.</div><div class="line"> */</div><div class="line">struct DexFieldId &#123;</div><div class="line">    u2  classIdx;           /* 指向 typeIds 的索引，表示定义这个字段的类 */</div><div class="line">    u2  typeIdx;            /* 指向 typeIds 的索引，表示字段类型 */</div><div class="line">    u4  nameIdx;            /* 指向 stringIds 的索引，表示字段名*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="手动查找"><a href="#手动查找" class="headerlink" title="手动查找"></a>手动查找</h2><p><strong>某 dex 文件的 FieldIds 部分</strong>：</p>
<p>fieldIdsSize : 0x01<br>fieldIdsOff : 0x031c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">00000310  .. .. .. .. .. .. .. ..  .. .. .. .. 04 00 0f 00  |&apos;...............|</div><div class="line">00000320  04 00 00 00 .. .. .. ..  .. .. .. .. .. .. .. ..  |................|</div></pre></td></tr></table></figure>
<p>由 DexFieldId 可得 ：<br>classIdx=0x0004 =&gt; typeId=0x0d =&gt; stringDataOff=0x00a4 =&gt; Landroid/os/Build;<br>typeIdx=0x000f =&gt; typeId=0x18 =&gt; stringDataOff=0x00d0 =&gt; Ljava/lang/String;<br>nameIdx=0x00000004 =&gt; stringDataOff=0x0538 =&gt; CPU_ABI</p>
<h2 id="写程序解析-1"><a href="#写程序解析-1" class="headerlink" title="写程序解析"></a>写程序解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def parseFields(f):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    此函数基于 parseStrings 和 parseTypes 函数的结果</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    f.seek(DexStruct.DexHeader[&apos;fieldIdsOff&apos;])</div><div class="line">    for i in range(DexStruct.DexHeader[&apos;fieldIdsSize&apos;]):</div><div class="line">        field_class = DexStruct.DexTypes[struct.unpack(&apos;H&apos;,f.read(2))[0]][&apos;content&apos;]</div><div class="line">        field_type = DexStruct.DexTypes[struct.unpack(&apos;H&apos;,f.read(2))[0]][&apos;content&apos;]</div><div class="line">        field_name = DexStruct.DexStrings[struct.unpack(&apos;I&apos;,f.read(4))[0]][&apos;content&apos;]</div><div class="line">        tmpDexFieldItem = &#123;</div><div class="line">            &apos;class&apos; : field_class,</div><div class="line">            &apos;Type&apos; : field_type,</div><div class="line">            &apos;name&apos; : field_name,</div><div class="line">        &#125;</div><div class="line">        DexStruct.DexFields.append(tmpDexFieldItem)</div></pre></td></tr></table></figure>
<hr>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>MethodId 表示的是方法，包括本方法所属的类、方法原型 (proto) 和方法名。<br>MethodId 的大小和文件偏移在 DexHeader 和 map_list 中都有指定。</p>
<h2 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h2><p>以 4 字节对齐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;method_id_item&quot;.</div><div class="line"> */</div><div class="line">struct DexMethodId &#123;</div><div class="line">    u2  classIdx;           /* 指向 typeIds，表示定义这个方法的类 */</div><div class="line">    u2  protoIdx;           /* 指向 protoIds，表示方法的原型*/</div><div class="line">    u4  nameIdx;            /* 指向 stringIds，表示方法名 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="手动查找-1"><a href="#手动查找-1" class="headerlink" title="手动查找"></a>手动查找</h2><p><strong>某 dex 文件的 methodIds 部分</strong>：</p>
<p>methodIdsSize : 0x2b<br>methodIdsOff : 0x0324</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">00000320  .. .. .. .. 02 00 07 00  03 00 00 00 02 00 08 00  |................|</div><div class="line">00000330  30 00 00 00 .. ...</div><div class="line">........</div><div class="line">00000470  42 00 00 00 15 00 04 00  43 00 00 00</div></pre></td></tr></table></figure>
<p>以第一个 <code>02 00 07 00 03 00 00 00</code> 为例：<br>classIdx=0x02 =&gt; Landroid/app/Application;<br>protoIdx=0x07 =&gt; void ()<br>nameIdx=0x03 =&gt; &lt;init&gt;<br>即该函数为 void android.app.Application.&lt;init&gt;()</p>
<p>以此类推：</p>
<table>
<thead>
<tr>
<th>序数</th>
<th>所属的类</th>
<th>函数原型</th>
<th>函数名</th>
<th>全称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>Landroid/app/Application;</td>
<td>void ()</td>
<td><init></init></td>
<td>void android.app.Application.<init>()</init></td>
</tr>
<tr>
<td>0x01</td>
<td>Landroid/app/Application;</td>
<td>void (android.content.Context)</td>
<td>attachBaseContext</td>
<td>void android.app.Application.attachBaseContext(android.content.Context)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0x2b</td>
<td>Ljava/util/zip/ZipFile;</td>
<td>InputStream (ZipENtry)</td>
<td>getInputStream</td>
<td>java.io.InputStream java.util.zip.ZipFile.getInputStream(java.util.zip.ZipEntry)</td>
</tr>
</tbody>
</table>
<h2 id="写程序解析-2"><a href="#写程序解析-2" class="headerlink" title="写程序解析"></a>写程序解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def parseMethods(f):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    此函数基于 parseStrings、parseProtos 和 parseTypes 函数的结果</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    f.seek(DexStruct.DexHeader[&apos;methodIdsOff&apos;])</div><div class="line">    for i in range(DexStruct.DexHeader[&apos;methodIdsSize&apos;]):</div><div class="line">        method_class = DexStruct.DexTypes[struct.unpack(&apos;H&apos;,f.read(2))[0]][&apos;content&apos;]</div><div class="line">        method_proto = DexStruct.DexProtos[struct.unpack(&apos;H&apos;,f.read(2))[0]]</div><div class="line">        method_name = DexStruct.DexStrings[struct.unpack(&apos;I&apos;,f.read(4))[0]][&apos;content&apos;]</div><div class="line">        tmpDexMethodItem = &#123;</div><div class="line">            &apos;class&apos; : method_class,</div><div class="line">            &apos;proto&apos; : method_proto,</div><div class="line">            &apos;name&apos; : method_name,</div><div class="line">        &#125;</div><div class="line">        DexStruct.DexMethods.append(tmpDexMethodItem)</div></pre></td></tr></table></figure>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik Executable format</a></p>
<p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">《Android 软件安全与逆向分析》</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解析 dex 文件结构 - 索引区和数据区（一） - Strings & Types]]></title>
      <url>/2015/11/19/parse-dex-file-part-strings-and-type-descriptors/</url>
      <content type="html"><![CDATA[<p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dex-file-general-structure-1.png" alt="part-1"></p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="http://kiya-z.github.io/2015/11/17/parse-dex-file-part-dex-header/" target="_blank" rel="external">解析 dex 文件结构 - DexHeader</a> 中我们知道 Table 部分就是索引结构区，他们是是作为指向 Data 区数据的结构索引而存在的。<br>数据区是 dex 会用到的全部数据。</p>
<hr>
<h1 id="StringIds-和-StringData"><a href="#StringIds-和-StringData" class="headerlink" title="StringIds 和 StringData"></a>StringIds 和 StringData</h1><p>StringIds 存放的是字符串的 id，也就是数据区中各个 StringData 的文件偏移。<br>StringIds 的大小和文件偏移在 DexHeader 和 map_list 中都有指定。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>StringIds 以4字节对齐，即总大小为 4 * stringIdsSize .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;string_id_item&quot;.</div><div class="line"> */</div><div class="line">struct DexStringId &#123;</div><div class="line">    u4 stringDataOff;      /* file offset to string_data_item */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>按照 StringIds 指示的偏移来到数据区对应的位置，StringData 采用的格式为：</p>
<p><strong>字符串长度</strong> : uleb128 格式，不包括字符串尾部的 00 。<br><strong>字符串内容</strong>：MUTF-8(经过修改的UTF-8)，以 00 结尾 .</p>
<h2 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h2><p><strong>某 dex 文件的 StringIds 部分</strong>：</p>
<p>stringIdsSize：0x5c<br>stringIdsOff：0x0070</p>
<p>0x0070 ~ 0x01df</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00000070  bc 04 00 00 ef 04 00 00  26 05 00 00 30 05 00 00  |........&amp;...0...|</div><div class="line">00000080  38 05 00 00 41 05 00 00  44 05 00 00 48 05 00 00  |8...A...D...H...|</div><div class="line">00000090  4b 05 00 00 4f 05 00 00  52 05 00 00 56 05 00 00  |K...O...R...V...|</div><div class="line">000000a0  71 05 00 00 8c 05 00 00  a0 05 00 00 bf 05 00 00  |q...............|</div><div class="line">000000b0  dd 05 00 00 f9 05 00 00  09 06 00 00 24 06 00 00  |............$...|</div><div class="line">000000c0  40 06 00 00 57 06 00 00  6e 06 00 00 85 06 00 00  |@...W...n.......|</div><div class="line">........  .. .. .. ..</div><div class="line">000001c0  c4 09 00 00 c9 09 00 00  d1 09 00 00 dd 09 00 00  |................|</div><div class="line">000001d0  e4 09 00 00 eb 09 00 00  f0 09 00 00 f4 09 00 00  |................|</div></pre></td></tr></table></figure>
<p>以第一个字符串为例，文件偏移为 <code>bc 04 00 00</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">000004b0  64 0a 00 00 de 0f 00 00  00 00 00 00 31 2f 64 61  |d...........1/da|</div><div class="line">000004c0  74 61 2f 64 61 74 61 2f  63 6f 6d 2e 7a 79 68 2e  |ta/data/com.zyh.|</div><div class="line">000004d0  6c 69 67 68 74 69 6e 67  62 61 63 6b 75 70 2f 2e  |lightingbackup/.|</div><div class="line">000004e0  6c 69 62 2f 6c 69 62 65  78 65 63 2e 73 6f 00 35  |lib/libexec.so.5|</div></pre></td></tr></table></figure></p>
<p>根据 <a href="http://kiya-z.github.io/2015/11/18/parse-dex-file-part-leb128/" target="_blank" rel="external">LEB128 的解码格式</a>可知：<br>字符串的长度为 0x31(有效位：011 0001) = 49 个字节。(“/data/data/com.zyh.lightingbackup/.lib/libexec.so”)</p>
<p><strong>以此类推：</strong></p>
<table>
<thead>
<tr>
<th>序数</th>
<th>文件偏移</th>
<th>字符串长度</th>
<th>字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>0x04bc</td>
<td>0x31</td>
<td>/data/data/com.zyh.lightingbackup/.lib/libexec.so</td>
</tr>
<tr>
<td>0x01</td>
<td>0x04ef</td>
<td>0x35</td>
<td>/data/data/com.zyh.lightingbackup/.lib/libexecmain.so</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0x04</td>
<td>0x0538</td>
<td>0x07</td>
<td>CPU_ABI</td>
</tr>
<tr>
<td>0x05</td>
<td>0x0541</td>
<td>0x01</td>
<td>I</td>
</tr>
<tr>
<td>0x06</td>
<td>0x0544</td>
<td>0x02</td>
<td>IL</td>
</tr>
<tr>
<td>0x07</td>
<td>0x0548</td>
<td>0x01</td>
<td>J</td>
</tr>
<tr>
<td>0x08</td>
<td>0x054b</td>
<td>0x02</td>
<td>JL</td>
</tr>
<tr>
<td>0x09</td>
<td>0x054f</td>
<td>0x01</td>
<td>L</td>
</tr>
<tr>
<td>0x0a</td>
<td>0x0552</td>
<td>0x02</td>
<td>LL</td>
</tr>
<tr>
<td>0x0b</td>
<td>0x0556</td>
<td>0x19</td>
<td>Landroid/app/Application;</td>
</tr>
<tr>
<td>0x0c</td>
<td>0x0571</td>
<td>0x19</td>
<td>Landroid/content/Context;</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0x5b</td>
<td>0x09f0</td>
<td>0x02</td>
<td>ze</td>
</tr>
<tr>
<td>0x5c</td>
<td>0x09f4</td>
<td>0x02</td>
<td>zf</td>
</tr>
</tbody>
</table>
<h2 id="写程序解析字符串"><a href="#写程序解析字符串" class="headerlink" title="写程序解析字符串"></a>写程序解析字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">def readuleb128(f):</div><div class="line">    num = struct.unpack(&apos;B&apos;,f.read(1))[0]     # 读第一字节</div><div class="line">    if num &gt; 0x7f :</div><div class="line">        cur = struct.unpack(&apos;B&apos;,f.read(1))[0]     #读第二字节</div><div class="line">        num = (num &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7)</div><div class="line">        if cur &gt; 0x7f:</div><div class="line">            cur = struct.unpack(&apos;B&apos;,f.read(1))[0]     #读第三字节</div><div class="line">            num = num | ((cur &amp; 0x7f) &lt;&lt; 14)</div><div class="line">            if cur &gt; 0x7f:</div><div class="line">                cur = struct.unpack(&apos;B&apos;,f.read(1))[0]     #读第四字节</div><div class="line">                num = num | ((cur &amp; 0x7f) &lt;&lt; 21)</div><div class="line">                if cur &gt; 0x7f:</div><div class="line">                    cur = struct.unpack(&apos;B&apos;,f.read(1))[0]     #读第五字节</div><div class="line">                    num = num | ((cur &amp; 0x7f) &lt;&lt; 28)</div><div class="line">    return num</div><div class="line">def parseStrings(f):</div><div class="line">    f.seek(DexStruct.DexHeader[&apos;stringIdsOff&apos;])</div><div class="line">    stringIds_data = f.read(4*DexStruct.DexHeader[&apos;stringIdsSize&apos;])</div><div class="line">    cur_pos = 0</div><div class="line">    for i in range(DexStruct.DexHeader[&apos;stringIdsSize&apos;]):</div><div class="line">        str_off =  struct.unpack(&apos;I&apos;,stringIds_data[cur_pos:cur_pos+4])[0]</div><div class="line">        f.seek(str_off)</div><div class="line">        str_len = readuleb128(f)</div><div class="line">        str_content = f.read(str_len)</div><div class="line">        cur_pos += 4</div><div class="line">        tmpDexStringItem = &#123;</div><div class="line">            &apos;offset&apos; : str_off,</div><div class="line">            &apos;len&apos; : str_len,</div><div class="line">            &apos;content&apos; : str_content,</div><div class="line">        &#125;</div><div class="line">        DexStruct.DexStrings.append(tmpDexStringItem)</div></pre></td></tr></table></figure>
<hr>
<h1 id="TypeIds"><a href="#TypeIds" class="headerlink" title="TypeIds"></a>TypeIds</h1><p>TypeIds 存放的是 stringIds 内的索引，也就是说 StringData 里面的一些字符串是类型描述符。<br>TypeIds 的大小和文件偏移在 DexHeader 和 map_list 中都有指定。</p>
<p>这里的类型描述符可以代表 dex 文件中的任何类型，包括基本类型，类类型，数组类型和空类型。</p>
<h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><p>TypeIds 以4字节对齐，即总大小为 4 * typeIdsSize .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;type_id_item&quot;.</div><div class="line"> */</div><div class="line">struct DexTypeId &#123;</div><div class="line">    u4  descriptorIdx;      /* index into stringIds list for type descriptor */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过 <code>descriptorIdx</code> 可以得到相应<code>类型描述符</code>的字符串的 StringId，从而找到相应的字符串。</p>
<h2 id="手动查找"><a href="#手动查找" class="headerlink" title="手动查找"></a>手动查找</h2><p><strong>某 dex 文件的 TypeIds 部分</strong>：</p>
<p>TypeIdsSize：0x19<br>TypeIdsOff：0x01e0</p>
<p>0x01e0 ~ 0x0244</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">000001e0  05 00 00 00 07 00 00 00  0b 00 00 00 0c 00 00 00  |................|</div><div class="line">000001f0  0d 00 00 00 0e 00 00 00  0f 00 00 00 10 00 00 00  |................|</div><div class="line">00000200  11 00 00 00 12 00 00 00  13 00 00 00 14 00 00 00  |................|</div><div class="line">00000210  15 00 00 00 16 00 00 00  17 00 00 00 18 00 00 00  |................|</div><div class="line">00000220  19 00 00 00 1a 00 00 00  1b 00 00 00 1c 00 00 00  |................|</div><div class="line">00000230  1d 00 00 00 1e 00 00 00  21 00 00 00 26 00 00 00  |........!...&amp;...|</div><div class="line">00000240  29 00 00 00</div></pre></td></tr></table></figure>
<p>以第一个索引值 0x05 为例，在 StringIds 中找到第 0x05 个 StringId，也就是 0x0070(stringIdsOff) + 0x05 * 4 = 0x0084，<br>该地址值为 0x0541，0x0541 处的字符串为 “I”，int 类型。类型对照参见下表 - Dalvik 字节码类型。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>V</td>
<td>void; 只用于返回值</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
<tr>
<td>Lfully/qualified/Name;</td>
<td>类名：fully.qualified.Name</td>
</tr>
<tr>
<td>[descriptor</td>
<td>数组描述符，可以表示多维数组如 [[[descriptor，但最多只能有255个维度</td>
</tr>
</tbody>
</table>
<p>以此类推：</p>
<table>
<thead>
<tr>
<th>序数</th>
<th>descriptorIdx</th>
<th>StringId</th>
<th>Type</th>
<th>真正类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>0x05</td>
<td>0x0084</td>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>0x01</td>
<td>0x07</td>
<td>0x008c</td>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>0x02</td>
<td>0x0b</td>
<td>0x009c</td>
<td>Landroid/app/Application;</td>
<td>android.app.Application</td>
</tr>
<tr>
<td>0x03</td>
<td>0x0c</td>
<td>0x00a0</td>
<td>Landroid/content/Context;</td>
<td>android.content.Context</td>
</tr>
<tr>
<td>0x04</td>
<td>0x0d</td>
<td>0x00a4</td>
<td>Landroid/os/Build;</td>
<td>android.os.Build</td>
</tr>
<tr>
<td>0x05</td>
<td>0x0e</td>
<td>0x00a8</td>
<td>Lcom/shell/NativeApplication;</td>
<td>com.shell.NativeApplication</td>
</tr>
<tr>
<td>0x06</td>
<td>0x0f</td>
<td>0x00ac</td>
<td>Lcom/shell/SuperApplication;</td>
<td>com.shell.SuperApplication</td>
</tr>
<tr>
<td>0x07</td>
<td>0x10</td>
<td>0x00b0</td>
<td>Ldalvik/annotation/Throws;</td>
<td>dalvik.annotation.Throws</td>
</tr>
<tr>
<td>0x08</td>
<td>0x11</td>
<td>0x00b4</td>
<td>Ljava/io/File;</td>
<td>java.io.File</td>
</tr>
<tr>
<td>0x09</td>
<td>0x12</td>
<td>0x00b8</td>
<td>Ljava/io/FileInputStream;</td>
<td>java.io.FileInputStream</td>
</tr>
<tr>
<td>0x0a</td>
<td>0x13</td>
<td>0x00bc</td>
<td>Ljava/io/FileOutputStream;</td>
<td>java.io.FileOutputStream</td>
</tr>
<tr>
<td>0x0b</td>
<td>0x14</td>
<td>0x00c0</td>
<td>Ljava/io/IOException;</td>
<td>java.io.IOException</td>
</tr>
<tr>
<td>0x0c</td>
<td>0x15</td>
<td>0x00c4</td>
<td>Ljava/io/InputStream;</td>
<td>java.io.InputStream</td>
</tr>
<tr>
<td>0x0d</td>
<td>0x16</td>
<td>0x00c8</td>
<td>Ljava/lang/Exception;</td>
<td>java.lang.Exception</td>
</tr>
<tr>
<td>0x0e</td>
<td>0x17</td>
<td>0x00cc</td>
<td>Ljava/lang/Object;</td>
<td>java.lang.Object</td>
</tr>
<tr>
<td>0x0f</td>
<td>0x18</td>
<td>0x00d0</td>
<td>Ljava/lang/String;</td>
<td>java.lang.String</td>
</tr>
<tr>
<td>0x10</td>
<td>0x19</td>
<td>0x00d4</td>
<td>Ljava/lang/System;</td>
<td>java.lang.System</td>
</tr>
<tr>
<td>0x11</td>
<td>0x1a</td>
<td>0x00d8</td>
<td>Ljava/util/zip/CRC32;</td>
<td>java.util.zip.CRC32</td>
</tr>
<tr>
<td>0x12</td>
<td>0x1b</td>
<td>0x00dc</td>
<td>Ljava/util/zip/CheckedInputStream;</td>
<td>java.util.zip.CheckedInputStream</td>
</tr>
<tr>
<td>0x13</td>
<td>0x1c</td>
<td>0x00e0</td>
<td>Ljava/util/zip/Checksum;</td>
<td>java.util.zip.Checksum</td>
</tr>
<tr>
<td>0x14</td>
<td>0x1d</td>
<td>0x00e4</td>
<td>Ljava/util/zip/ZipEntry;</td>
<td>java.util.zip.ZipEntry</td>
</tr>
<tr>
<td>0x15</td>
<td>0x1e</td>
<td>0x00e8</td>
<td>Ljava/util/zip/ZipFile;</td>
<td>java.util.zip.ZipFile</td>
</tr>
<tr>
<td>0x16</td>
<td>0x21</td>
<td>0x00f4</td>
<td>V</td>
<td>void</td>
</tr>
<tr>
<td>0x17</td>
<td>0x26</td>
<td>0x0108</td>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>0x18</td>
<td>0x29</td>
<td>0x0114</td>
<td>[B]</td>
<td>byte[]</td>
</tr>
</tbody>
</table>
<h2 id="写程序解析-TypeIds"><a href="#写程序解析-TypeIds" class="headerlink" title="写程序解析 TypeIds"></a>写程序解析 TypeIds</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def parseTypes(f):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    此函数基于 parseStrings 函数的结果，调用前需先调用 parseStrings</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    f.seek(DexStruct.DexHeader[&apos;typeIdsOff&apos;])</div><div class="line">    for i in range(DexStruct.DexHeader[&apos;typeIdsSize&apos;]):</div><div class="line">        type_desc_id = struct.unpack(&apos;I&apos;,f.read(4))[0]</div><div class="line">        DexStruct.DexTypes.append(DexStruct.DexStrings[type_desc_id])</div></pre></td></tr></table></figure>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik Executable format</a></p>
<p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">《Android 软件安全与逆向分析》</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[号称 Edit Everything 的 010 Editor]]></title>
      <url>/2015/11/19/tools-010-editor/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>010 Editor 是一款 16 进制编辑器，Text Editor 、HexEditor 、Disk Editor &amp; Process Editor .</p>
<a id="more"></a>
<p>支持文件的二进制比较；</p>
<p>支持 bmp 、avi 、map3 、map4 等常见文件和 AndroidManifest、dex 、elf 、exe等程序员文件的解析，学习文件格式解析的时候再也不用怕点来点去找不到字节了～<br>这些解析脚本都是由很多人提交的，如果你认为现有的脚本有何不足或者你解析了一种新的文件格式，都可以向网站提交，然后出现在下载页面！</p>
<p>30 天试用期。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.sweetscape.com/010editor/" target="_blank" rel="external">官网</a></p>
<p><a href="http://www.sweetscape.com/010editor/templates/" target="_blank" rel="external">脚本下载</a></p>
<p><a href="http://www.sweetscape.com/010editor/features.html" target="_blank" rel="external">全部特性</a></p>
<p><a href="http://www.sweetscape.com/010editor/screenshots.html" target="_blank" rel="external">在线引导</a></p>
]]></content>
      
        <categories>
            
            <category> Cool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解析 dex 文件结构 - LEB128]]></title>
      <url>/2015/11/18/parse-dex-file-part-leb128/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>dex 文件中用到的数据类型有:</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8位有符号整数</td>
</tr>
<tr>
<td>ubyte</td>
<td>8位无符号整数</td>
</tr>
<tr>
<td>short</td>
<td>16位有符号整数，小端存储</td>
</tr>
<tr>
<td>ushort</td>
<td>16位无符号整数，小端存储</td>
</tr>
<tr>
<td>int</td>
<td>32位有符号整数，小端存储</td>
</tr>
<tr>
<td>uint</td>
<td>32位无符号整数，小端存储</td>
</tr>
<tr>
<td>long</td>
<td>64位有符号整数，小端存储</td>
</tr>
<tr>
<td>ulong</td>
<td>64位无符号整数，小端存储</td>
</tr>
<tr>
<td>sleb128</td>
<td>有符号 LEB128，可变长度</td>
</tr>
<tr>
<td>uleb128</td>
<td>无符号 LEB128，可变长度</td>
</tr>
<tr>
<td>uleb128p1</td>
<td>无符号 LEB128 加 1，可变长度</td>
</tr>
</tbody>
</table>
<p>[<strong>注</strong>] 将一个数编码为 uleb128p1 时需要将 uleb128 加 1，而将一个已经编码好的 uleb128p1 解码为正常数字时需要将 uleb128 减 1。</p>
<h2 id="LEB128？"><a href="#LEB128？" class="headerlink" title="LEB128？"></a>LEB128？</h2><p>LEB128，全程 <strong>L</strong>ittle-<strong>E</strong>ndian <strong>B</strong>ase <strong>128</strong>，借鉴自 <a href="http://dwarfstd.org/Dwarf3Std.php" target="_blank" rel="external">DWARF3</a> (一种调试文件格式，广泛用于 Unix、Linux等操作系统，可扩展性强) 。在 .dex 文件中，LEB128 仅对 32 位数据编码。</p>
<p>每个 LEB128 编码的值由 1-5 个字节组成，合在一起表示一个 32 位的值。每个字节的有效位只有7位，最高位作为标记：最后一个字节的最高位设为0，其余设为1 。如果第 5 个字节的最高位为 1，说明这个 dex 文件是无效的。</p>
<p>sleb128 对最后一个字节的最高位进行了符号扩展(高位全补1，uleb128是高位全补0)，即作为符号位。</p>
<p>uleb128p1 + 1 就是 uleb128 的值，也就是说在无符号 LEB128 类型中，只有非负数和一个负数(-1 or 0xffffffff)。</p>
<p>下面是 2 个字节的 LEB128 值 - 图示：</p>
<table>
<thead>
<tr>
<th>First byte</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>bit6</td>
<td>bit5</td>
<td>bit4</td>
<td>bit3</td>
<td>bit2</td>
<td>bit1</td>
<td>bit0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Second byte</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>bit13</td>
<td>bit12</td>
<td>bit12</td>
<td>bit11</td>
<td>bit10</td>
<td>bit9</td>
<td>bit8</td>
<td>bit7</td>
</tr>
</tbody>
</table>
<p><strong>官方栗子：</strong></p>
<table>
<thead>
<tr>
<th>Encoded Sequence</th>
<th>As sleb128</th>
<th>As uleb128</th>
<th>As uleb128p1</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>0</td>
<td>-1</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>7f</td>
<td>-1</td>
<td>127</td>
<td>126</td>
</tr>
<tr>
<td>807f</td>
<td>-128</td>
<td>16256</td>
<td>16255</td>
</tr>
</tbody>
</table>
<p><strong>解析：</strong></p>
<table>
<thead>
<tr>
<th>7f</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制</td>
<td>0111,1111</td>
</tr>
<tr>
<td>有效值</td>
<td>111,1111</td>
</tr>
<tr>
<td>sleb128</td>
<td>1111,1111 = - 0000,0000,0000,0001  = -1</td>
</tr>
<tr>
<td>uleb128</td>
<td>0111,1111 = 127</td>
</tr>
<tr>
<td>uleb128p1</td>
<td>127-1=126</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>80 7f</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制</td>
<td>1000,0000,0111,1111</td>
</tr>
<tr>
<td>有效值</td>
<td>111,1111,000,0000</td>
</tr>
<tr>
<td>sleb128</td>
<td>1111,1111,1000,0000 = - 0000,0000,1000,0000  = -128</td>
</tr>
<tr>
<td>uleb128</td>
<td>0011,1111,1000,0000 = 16256</td>
</tr>
<tr>
<td>uleb128p1</td>
<td>16256-1=16255</td>
</tr>
</tbody>
</table>
<h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><p>位于 <code>/dalvik/libdex/Leb128.h</code> 文件中。</p>
<h3 id="读取无符号-LEB128-的源码"><a href="#读取无符号-LEB128-的源码" class="headerlink" title="读取无符号 LEB128 的源码"></a>读取无符号 LEB128 的源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Reads an unsigned LEB128 value, updating the given pointer to point</div><div class="line"> * just past the end of the read value. This function tolerates</div><div class="line"> * non-zero high-order bits in the fifth encoded byte.</div><div class="line"> */</div><div class="line">DEX_INLINE int readUnsignedLeb128(const u1** pStream) &#123;</div><div class="line">    const u1* ptr = *pStream;</div><div class="line">    int result = *(ptr++);      //取第一个字节</div><div class="line">    if (result &gt; 0x7f) &#123;        //如果大于 0x7f 表示第 1 字节最高位为 1</div><div class="line">        int cur = *(ptr++);     //取第二个字节</div><div class="line">        result = (result &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7);     // 两个字节组合，第二个字节为高位</div><div class="line">        if (cur &gt; 0x7f) &#123;        //如果大于 0x7f 表示第 2 字节最高位为 1</div><div class="line">            cur = *(ptr++);      //取第三个字节</div><div class="line">            result |= (cur &amp; 0x7f) &lt;&lt; 14;           //前三个字节组合，第三个字节为高位</div><div class="line">            if (cur &gt; 0x7f) &#123;        //如果大于 0x7f 表示第 3 字节最高位为 1</div><div class="line">                cur = *(ptr++);      //取第四个字节</div><div class="line">                result |= (cur &amp; 0x7f) &lt;&lt; 21;       //前四个字节组合，第四个字节为高位</div><div class="line">                if (cur &gt; 0x7f) &#123;       //如果大于 0x7f 表示第 4 字节最高位为 1</div><div class="line">                    /*</div><div class="line">                     * 这里不检查 ptr 指针是否越界</div><div class="line">                     * 也不检查第五个字节的最高位是否为0</div><div class="line">                     */</div><div class="line">                    cur = *(ptr++);                //取第五个字节</div><div class="line">                    result |= cur &lt;&lt; 28;           //前五个字节组合，第五个字节为高位</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    *pStream = ptr;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="读取有符号-LEB128-的源码"><a href="#读取有符号-LEB128-的源码" class="headerlink" title="读取有符号 LEB128 的源码"></a>读取有符号 LEB128 的源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Reads a signed LEB128 value, updating the given pointer to point</div><div class="line"> * just past the end of the read value. This function tolerates</div><div class="line"> * non-zero high-order bits in the fifth encoded byte.</div><div class="line"> */</div><div class="line">DEX_INLINE int readSignedLeb128(const u1** pStream) &#123;</div><div class="line">    const u1* ptr = *pStream;</div><div class="line">    int result = *(ptr++);</div><div class="line">    if (result &lt;= 0x7f) &#123;   //第2个字节最高位为0</div><div class="line">        result = (result &lt;&lt; 25) &gt;&gt; 25;  //最高位进行符号扩展</div><div class="line">    &#125; else &#123;</div><div class="line">        int cur = *(ptr++);</div><div class="line">        result = (result &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7); //前两个字节组合</div><div class="line">        if (cur &lt;= 0x7f) &#123;   //第2个字节最高位为0</div><div class="line">            result = (result &lt;&lt; 18) &gt;&gt; 18;   //最高位进行符号扩展</div><div class="line">        &#125; else &#123;</div><div class="line">            cur = *(ptr++);</div><div class="line">            result |= (cur &amp; 0x7f) &lt;&lt; 14;   //前3个字节组合</div><div class="line">            if (cur &lt;= 0x7f) &#123;   //第3个字节最高位为0</div><div class="line">                result = (result &lt;&lt; 11) &gt;&gt; 11;   //最高位进行符号扩展</div><div class="line">            &#125; else &#123;</div><div class="line">                cur = *(ptr++);</div><div class="line">                result |= (cur &amp; 0x7f) &lt;&lt; 21;    //前4个字节组合</div><div class="line">                if (cur &lt;= 0x7f) &#123;     //第4个字节最高位为0</div><div class="line">                    result = (result &lt;&lt; 4) &gt;&gt; 4;   //最高位进行符号扩展</div><div class="line">                &#125; else &#123;</div><div class="line">                    cur = *(ptr++);</div><div class="line">                    result |= cur &lt;&lt; 28;    //前5个字节组合</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    *pStream = ptr;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik Executable format</a></p>
<p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">《Android 软件安全与逆向分析》</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解析 dex 文件结构 - map_list]]></title>
      <url>/2015/11/18/parse-dex-file-part-map-list/</url>
      <content type="html"><![CDATA[<p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dex-file-general-structure-map-list.png" alt="map-list"></p>
<a id="more"></a>
<h2 id="什么是-map-list？"><a href="#什么是-map-list？" class="headerlink" title="什么是 map_list？"></a>什么是 map_list？</h2><p>整个 dex 文件的内容清单，位于数据段内，其文件偏移由 DexHeader 中的 mapOff 字段指定。</p>
<p>更加具体的解释在下面的 type 段落部分。</p>
<hr>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>来到 mapOff 指定的偏移处，首先是 DexMapList 结构，存储了 map_list 内 map_item (DexMapItem) 的个数和内容，也就是说在 size 之后，有 size 个DexMapItem 类型的数据。</p>
<h3 id="DexMapList"><a href="#DexMapList" class="headerlink" title="DexMapList"></a>DexMapList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;map_list&quot;.</div><div class="line"> */</div><div class="line">struct DexMapList &#123;</div><div class="line">    u4  size;               /* DexMapItem 的个数 */</div><div class="line">    DexMapItem list[1];     /* DexMapItem 数组 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="DexMapItem"><a href="#DexMapItem" class="headerlink" title="DexMapItem"></a>DexMapItem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Direct-mapped &quot;map_item&quot;.</div><div class="line"> */</div><div class="line">struct DexMapItem &#123;</div><div class="line">    u2 type;              /* 各 item 的类型，均以 kDexType 开头*/</div><div class="line">    u2 unused;            /* 未使用，用于字节对齐 */</div><div class="line">    u4 size;              /* 指定类型的个数 */</div><div class="line">    u4 offset;            /* 指定类型数据的起始文件偏移 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>在这些类型中，除了 0x0000 表示的就是 DexHeader 本身之外，0x0001 ~ 0x1000 部分与 DexHeader 中定义的类型是一致的；<br>而 0x1001 ~ 0x2006 部分是对 data 段的细分。<br>这样设计可以作为一种文件检验方式，一旦和 DexHeader 的数据有所不同就可以判定该 dex 是损坏的；而且 map_list 部分的内容更详细，以此作为整个文件的索引想必是极好的。<br>下面手动查找的例子可以证明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* map item type codes */</div><div class="line">enum &#123;</div><div class="line">    kDexTypeHeaderItem               = 0x0000,</div><div class="line">    kDexTypeStringIdItem             = 0x0001,</div><div class="line">    kDexTypeTypeIdItem               = 0x0002,</div><div class="line">    kDexTypeProtoIdItem              = 0x0003,</div><div class="line">    kDexTypeFieldIdItem              = 0x0004,</div><div class="line">    kDexTypeMethodIdItem             = 0x0005,</div><div class="line">    kDexTypeClassDefItem             = 0x0006,</div><div class="line">    kDexTypeMapList                  = 0x1000,</div><div class="line">    kDexTypeTypeList                 = 0x1001,</div><div class="line">    kDexTypeAnnotationSetRefList     = 0x1002,</div><div class="line">    kDexTypeAnnotationSetItem        = 0x1003,</div><div class="line">    kDexTypeClassDataItem            = 0x2000,</div><div class="line">    kDexTypeCodeItem                 = 0x2001,</div><div class="line">    kDexTypeStringDataItem           = 0x2002,</div><div class="line">    kDexTypeDebugInfoItem            = 0x2003,</div><div class="line">    kDexTypeAnnotationItem           = 0x2004,</div><div class="line">    kDexTypeEncodedArrayItem         = 0x2005,</div><div class="line">    kDexTypeAnnotationsDirectoryItem = 0x2006,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h2><p><strong>某 dex 文件的 map_list 部分</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">00001000  10 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|</div><div class="line">00001010  01 00 00 00 5c 00 00 00  70 00 00 00 02 00 00 00  |....\...p.......|</div><div class="line">00001020  19 00 00 00 e0 01 00 00  03 00 00 00 12 00 00 00  |................|</div><div class="line">00001030  44 02 00 00 04 00 00 00  01 00 00 00 1c 03 00 00  |D...............|</div><div class="line">00001040  05 00 00 00 2b 00 00 00  24 03 00 00 06 00 00 00  |....+...$.......|</div><div class="line">00001050  02 00 00 00 7c 04 00 00  02 20 00 00 5c 00 00 00  |....|.... ..\...|</div><div class="line">00001060  bc 04 00 00 01 10 00 00  0a 00 00 00 f8 09 00 00  |................|</div><div class="line">00001070  04 20 00 00 01 00 00 00  4e 0a 00 00 03 10 00 00  |. ......N.......|</div><div class="line">00001080  02 00 00 00 58 0a 00 00  06 20 00 00 01 00 00 00  |....X.... ......|</div><div class="line">00001090  64 0a 00 00 03 20 00 00  09 00 00 00 7c 0a 00 00  |d.... ......|...|</div><div class="line">000010a0  01 20 00 00 09 00 00 00  10 0c 00 00 00 20 00 00  |. ........... ..|</div><div class="line">000010b0  02 00 00 00 c2 0f 00 00  00 10 00 00 01 00 00 00  |................|</div><div class="line">000010c0  00 10 00 00                                       |....|</div></pre></td></tr></table></figure>
<p>前 4 字节表明接下来会有 <code>0x00000010</code> 个 DexMapItem 结构；</p>
<table>
<thead>
<tr>
<th>序数</th>
<th>binary</th>
<th>type</th>
<th>size</th>
<th>offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x01</td>
<td>00 00 00 00  01 00 00 00  00 00 00 00</td>
<td>kDexTypeHeaderItem</td>
<td>0x01</td>
<td>0x0</td>
</tr>
<tr>
<td>0x02</td>
<td>01 00 00 00  5c 00 00 00  70 00 00 00</td>
<td>kDexTypeStringIdItem</td>
<td>0x5c</td>
<td>0x70</td>
</tr>
<tr>
<td>0x03</td>
<td>02 00 00 00  19 00 00 00  e0 01 00 00</td>
<td>kDexTypeTypeIdItem</td>
<td>0x19</td>
<td>0x1e0</td>
</tr>
<tr>
<td>0x04</td>
<td>03 00 00 00  12 00 00 00  44 02 00 00</td>
<td>kDexTypeProtoIdItem</td>
<td>0x12</td>
<td>0x244</td>
</tr>
<tr>
<td>0x05</td>
<td>04 00 00 00  01 00 00 00  1c 03 00 00</td>
<td>kDexTypeFieldIdItem</td>
<td>0x01</td>
<td>0x3c1</td>
</tr>
<tr>
<td>0x06</td>
<td>05 00 00 00  2b 00 00 00  24 03 00 00</td>
<td>kDexTypeMethodIdItem</td>
<td>0x2b</td>
<td>0x324</td>
</tr>
<tr>
<td>0x07</td>
<td>06 00 00 00  02 00 00 00  7c 04 00 00</td>
<td>kDexTypeClassDefItem</td>
<td>0x02</td>
<td>0x47c</td>
</tr>
<tr>
<td>0x08</td>
<td>02 20 00 00  5c 00 00 00  bc 04 00 00</td>
<td>kDexTypeStringDataItem</td>
<td>0x5c</td>
<td>0x4bc</td>
</tr>
<tr>
<td>0x09</td>
<td>01 10 00 00  0a 00 00 00  f8 09 00 00</td>
<td>kDexTypeTypeList</td>
<td>0x0a</td>
<td>0x9f8</td>
</tr>
<tr>
<td>0x0a</td>
<td>04 20 00 00  01 00 00 00  4e 0a 00 00</td>
<td>kDexTypeAnnotationItem</td>
<td>0x01</td>
<td>0xa4e</td>
</tr>
<tr>
<td>0x0b</td>
<td>03 10 00 00  02 00 00 00  58 0a 00 00</td>
<td>kDexTypeAnnotationSetItem</td>
<td>0x02</td>
<td>0xa58</td>
</tr>
<tr>
<td>0x0c</td>
<td>06 20 00 00  01 00 00 00  64 0a 00 00</td>
<td>kDexTypeAnnotationsDirectoryItem</td>
<td>0x01</td>
<td>0xa64</td>
</tr>
<tr>
<td>0x0d</td>
<td>03 20 00 00  09 00 00 00  7c 0a 00 00</td>
<td>kDexTypeDebugInfoItem</td>
<td>0x09</td>
<td>0xa7c</td>
</tr>
<tr>
<td>0x0e</td>
<td>01 20 00 00  09 00 00 00  10 0c 00 00</td>
<td>kDexTypeCodeItem</td>
<td>0x09</td>
<td>0xc10</td>
</tr>
<tr>
<td>0x0f</td>
<td>00 20 00 00  02 00 00 00  c2 0f 00 00</td>
<td>kDexTypeClassDataItem</td>
<td>0x02</td>
<td>0xfc2</td>
</tr>
<tr>
<td>0x10</td>
<td>00 10 00 00  01 00 00 00  00 10 00 00</td>
<td>kDexTypeMapList</td>
<td>0x01</td>
<td>0x1000</td>
</tr>
</tbody>
</table>
<p>这里的各项值可以和上一节 <a href="http://kiya-z.github.io/2015/11/17/parse-dex-file-part-dex-header/" target="_blank" rel="external">解析 dex 文件结构 - DexHeader</a> 手动查找部分中的数据进行比对，发现是相同的。</p>
<hr>
<h2 id="写程序解析-map-list"><a href="#写程序解析-map-list" class="headerlink" title="写程序解析 map_list"></a>写程序解析 map_list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">class DexStruct(object):</div><div class="line">    DexMapList = &#123;</div><div class="line">        &quot;size&quot;: 0,</div><div class="line">        &quot;DexMapItem&quot;: []</div><div class="line">    &#125;</div><div class="line">    # DexMapItem = &#123;</div><div class="line">    #     &quot;type&quot; : 0</div><div class="line">    #     &quot;unused&quot; : 0</div><div class="line">    #     &quot;size&quot;  : 0</div><div class="line">    #     &quot;offset&quot; : 0</div><div class="line">    # &#125;</div><div class="line">    DexMapItemCode = &#123;</div><div class="line">        0x0000 : &quot;kDexTypeHeaderItem&quot;               ,</div><div class="line">        0x0001 : &quot;kDexTypeStringIdItem&quot;             ,</div><div class="line">        0x0002 : &quot;kDexTypeTypeIdItem&quot;               ,</div><div class="line">        0x0003 : &quot;kDexTypeProtoIdItem&quot;              ,</div><div class="line">        0x0004 : &quot;kDexTypeFieldIdItem&quot;              ,</div><div class="line">        0x0005 : &quot;kDexTypeMethodIdItem&quot;             ,</div><div class="line">        0x0006 : &quot;kDexTypeClassDefItem&quot;             ,</div><div class="line">        0x1000 : &quot;kDexTypeMapList&quot;                  ,</div><div class="line">        0x1001 : &quot;kDexTypeTypeList&quot;                 ,</div><div class="line">        0x1002 : &quot;kDexTypeAnnotationSetRefList&quot;     ,</div><div class="line">        0x1003 : &quot;kDexTypeAnnotationSetItem&quot;        ,</div><div class="line">        0x2000 : &quot;kDexTypeClassDataItem&quot;            ,</div><div class="line">        0x2001 : &quot;kDexTypeCodeItem&quot;                 ,</div><div class="line">        0x2002 : &quot;kDexTypeStringDataItem&quot;           ,</div><div class="line">        0x2003 : &quot;kDexTypeDebugInfoItem&quot;            ,</div><div class="line">        0x2004 : &quot;kDexTypeAnnotationItem&quot;           ,</div><div class="line">        0x2005 : &quot;kDexTypeEncodedArrayItem&quot;         ,</div><div class="line">        0x2006 : &quot;kDexTypeAnnotationsDirectoryItem&quot; ,</div><div class="line">    &#125;</div><div class="line">def parseMapList(map_data):</div><div class="line">    DexStruct.DexMapList[&apos;size&apos;] = struct.unpack(&apos;H&apos;,map_data[:2])[0]</div><div class="line">    curPos = 4</div><div class="line">    for x in range(DexStruct.DexMapList[&apos;size&apos;]):</div><div class="line">        tmpDexMapItem = &#123;</div><div class="line">            &quot;type&quot; : struct.unpack(&apos;H&apos;,map_data[curPos:curPos+2])[0],</div><div class="line">            &quot;unused&quot; : 0,</div><div class="line">            &quot;size&quot;  : struct.unpack(&apos;I&apos;,map_data[curPos+4:curPos+8])[0],</div><div class="line">            &quot;offset&quot; : struct.unpack(&apos;I&apos;,map_data[curPos+8:curPos+12])[0] &#125;</div><div class="line">        curPos += 12</div><div class="line">        DexStruct.DexMapList[&quot;DexMapItem&quot;].append(tmpDexMapItem)</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik Executable format</a></p>
<p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">《Android 软件安全与逆向分析》</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解析 dex 文件结构 - DexHeader]]></title>
      <url>/2015/11/17/parse-dex-file-part-dex-header/</url>
      <content type="html"><![CDATA[<p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dex-file-general-structure-header.png" alt="header"></p>
<h2 id="dex-简介"><a href="#dex-简介" class="headerlink" title="dex 简介"></a>dex 简介</h2><p>dex 文件是 dalvik 虚拟机的可执行文件。</p>
<a id="more"></a>
<hr>
<h2 id="dex-文件结构"><a href="#dex-文件结构" class="headerlink" title="dex 文件结构"></a>dex 文件结构</h2><p>该结构位于系统源码 <code>dalvik\libdex\DexFile.h</code> 中，描述的是 dex 文件被映射到内存中的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Structure representing a DEX file.</div><div class="line"> *</div><div class="line"> * Code should regard DexFile as opaque, using the API calls provided here</div><div class="line"> * to access specific structures.</div><div class="line"> */</div><div class="line">struct DexFile &#123;</div><div class="line">    /* directly-mapped &quot;opt&quot; header */</div><div class="line">    const DexOptHeader* pOptHeader;</div><div class="line">    /* pointers to directly-mapped structs and arrays in base DEX */</div><div class="line">    const DexHeader*    pHeader;</div><div class="line">    const DexStringId*  pStringIds;</div><div class="line">    const DexTypeId*    pTypeIds;</div><div class="line">    const DexFieldId*   pFieldIds;</div><div class="line">    const DexMethodId*  pMethodIds;</div><div class="line">    const DexProtoId*   pProtoIds;</div><div class="line">    const DexClassDef*  pClassDefs;</div><div class="line">    const DexLink*      pLinkData;</div><div class="line">    /*</div><div class="line">     * These are mapped out of the &quot;auxillary&quot; section, and may not be</div><div class="line">     * included in the file.</div><div class="line">     */</div><div class="line">    const DexClassLookup* pClassLookup;</div><div class="line">    const void*         pRegisterMapPool;       // RegisterMapClassPool</div><div class="line">    /* points to start of DEX file data */</div><div class="line">    const u1*           baseAddr;</div><div class="line">    /* track memory overhead for auxillary structures */</div><div class="line">    int                 overhead;</div><div class="line">    /* additional app-specific data structures associated with the DEX */</div><div class="line">    //void*               auxData;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>基本的文件结构只需关注:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct DexFile&#123;</div><div class="line">    DexHeader    Header;</div><div class="line">    DexStringId  StringIds[stringIdsSize];</div><div class="line">    DexTypeId    TypeIds[typeIdsSize];</div><div class="line">    DexFieldId   FieldIds[fieldIdsSize];</div><div class="line">    DexMethodId  MethodIds[methodIdsSize];</div><div class="line">    DexProtoId   ProtoIds[protoIdsSize];</div><div class="line">    DexClassDef  ClassDefs[classDefsSize];</div><div class="line">    DexData      Data[];</div><div class="line">    DexLink      LinkData;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="大体结构图"><a href="#大体结构图" class="headerlink" title="大体结构图"></a>大体结构图</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dex-file-general-structure.png" alt="dex-file-general-structure"></p>
<p>大致可以将 dex 文件分为三个部分：DexHeader 、Table 是索引结构区 、data 部分是数据区。<br>程序使用到的数据都在 data section 内， Tables 是指向 data section 中具体数据结构的索引。</p>
<hr>
<h2 id="DexHeader-结构"><a href="#DexHeader-结构" class="headerlink" title="DexHeader 结构"></a>DexHeader 结构</h2><p>头部记录了整个文件的索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 160-bit SHA-1 digest.</div><div class="line"> */</div><div class="line">enum &#123; kSHA1DigestLen = 20,</div><div class="line">       kSHA1DigestOutputLen = kSHA1DigestLen*2 +1 &#125;;</div><div class="line">/*</div><div class="line"> * Direct-mapped &quot;header_item&quot; struct.</div><div class="line"> */</div><div class="line">struct DexHeader &#123;</div><div class="line">    u1  magic[8];           /* 版本标识 */</div><div class="line">    u4  checksum;           /* adler32 检验 */</div><div class="line">    u1  signature[kSHA1DigestLen]; /* SHA-1 哈希值 */</div><div class="line">    u4  fileSize;           /* 整个文件大小 */</div><div class="line">    u4  headerSize;         /* DexHeader 大小 */</div><div class="line">    u4  endianTag;          /* 字节序标记 */</div><div class="line">    u4  linkSize;           /* 链接段大小 */</div><div class="line">    u4  linkOff;            /* 链接段偏移 */</div><div class="line">    u4  mapOff;             /* DexMapList 的文件偏移 */</div><div class="line">    u4  stringIdsSize;      /* DexStringId 的个数 */</div><div class="line">    u4  stringIdsOff;       /* DexStringId 的文件偏移 */</div><div class="line">    u4  typeIdsSize;        /* DexTypeId 的个数 */</div><div class="line">    u4  typeIdsOff;         /* DexTypeId 的文件偏移 */</div><div class="line">    u4  protoIdsSize;       /* DexProtoId 的个数 */</div><div class="line">    u4  protoIdsOff;        /* DexProtoId 的文件偏移 */</div><div class="line">    u4  fieldIdsSize;       /* DexFieldId 的个数 */</div><div class="line">    u4  fieldIdsOff;        /* DexFieldId 的文件偏移 */</div><div class="line">    u4  methodIdsSize;      /* DexMethodId 的个数 */</div><div class="line">    u4  methodIdsOff;       /* DexMethodId 的文件偏移 */</div><div class="line">    u4  classDefsSize;      /* DexClassDef 的个数 */</div><div class="line">    u4  classDefsOff;       /* DexClassDef 的文件偏移 */</div><div class="line">    u4  dataSize;           /* 数据段的大小 */</div><div class="line">    u4  dataOff;            /* 数据段的文件偏移 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h3><table>
<thead>
<tr>
<th>field</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>magic</strong></td>
<td>dex文件标识，值必须为常量 <code>DEX_FILE_MAGIC</code> = { 0x64 0x65 0x78 0x0a 0x30 0x33 0x35 0x00 } = “dex\n035\0”</td>
</tr>
<tr>
<td><strong>checkSum</strong></td>
<td>对除 magic 和 checkSum 外的剩余文件计算 adler32 校验值，目的是检测文件是否损坏</td>
</tr>
<tr>
<td><strong> signature</strong></td>
<td>对除 magic、checkSum 和 signature 外的剩余文件计算 SHA-1 校验值，用来确定文件的唯一性</td>
</tr>
<tr>
<td><strong> fileSize</strong></td>
<td>以字节为单位，整个文件（包括头部）的大小</td>
</tr>
<tr>
<td><strong> headerSize</strong></td>
<td>头部大小，0x70 字节，已经考虑到兼容性</td>
</tr>
<tr>
<td><strong> endianTag</strong></td>
<td>两种字节序取值: <code>uint ENDIAN_CONSTANT = 0x12345678</code> ; <code>uint REVERSE_ENDIAN_CONSTANT = 0x78563412</code></td>
</tr>
<tr>
<td><strong> linkSize</strong></td>
<td>链接段的大小，如果没有使用静态链接，值为0</td>
</tr>
<tr>
<td><strong> linkOff</strong></td>
<td>链接段的文件偏移，指向链接数据段内，如果 <code>linkSize</code> 为 0，则为 0</td>
</tr>
<tr>
<td><strong> mapOff</strong></td>
<td>map item 的文件偏移，指向数据段内，数据结构为 <code>mapList</code>，如果没有 map，值为 0</td>
</tr>
<tr>
<td><strong> stringIdsSize</strong></td>
<td>字符串 id 的个数</td>
</tr>
<tr>
<td><strong> stringIdsOff</strong></td>
<td>字符串 id 清单的文件偏移，指向 <code>stringIds</code> 的起始地址，如果 stringIdsSize 为 0，值为0</td>
</tr>
<tr>
<td><strong> typeIdsSize</strong></td>
<td>类型标识符的个数</td>
</tr>
<tr>
<td><strong> typeIdsOff</strong></td>
<td>类型标识符清单的文件偏移，指向 <code>typeIds</code> 的起始地址，如果 typeIdsSize 为 0，值为 0 (<em>这就很奇怪了哟</em>)</td>
</tr>
<tr>
<td><strong> protoIdsSize</strong></td>
<td>原型标识符的个数</td>
</tr>
<tr>
<td><strong> protoIdsOff</strong></td>
<td>原型标识符清单的文件偏移，指向 <code>protoIds</code> 的起始地址，如果 protoIdsSize 为 0，值为 0 (<em>这就很奇怪了哟</em>)</td>
</tr>
<tr>
<td><strong>  fieldIdsSize</strong></td>
<td>字段标识符的个数</td>
</tr>
<tr>
<td><strong> fieldIdsOff</strong></td>
<td>字段标识符清单的文件偏移，指向 <code>fieldIds</code> 的起始地址，如果 fieldIdsSize 为 0，值为 0</td>
</tr>
<tr>
<td><strong> methodIdsSize</strong></td>
<td>方法标识符的个数</td>
</tr>
<tr>
<td><strong> methodIdsOff</strong></td>
<td>方法标识符清单的文件偏移，指向 <code>methodIds</code> 的起始地址，如果 methodIdsSize 为 0，值为 0</td>
</tr>
<tr>
<td><strong> classDefsSize</strong></td>
<td>类的个数</td>
</tr>
<tr>
<td><strong> classDefsOff</strong></td>
<td>类清单的文件偏移，指向 <code>classDefs</code> 的起始地址，如果 classDefsSize 为 0，值为 0 (<em>这就很奇怪了哟</em>)</td>
</tr>
<tr>
<td><strong> dataSize</strong></td>
<td>数据段的大小，以字节为单位，并且是 sizeof(uint) 的偶数倍</td>
</tr>
<tr>
<td><strong> dataOff</strong></td>
<td>数据段的文件偏移</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h2><p>更方便的方式是使用 <a href="http://www.sweetscape.com/download/010editor/" target="_blank" rel="external">010 Editor</a>，下载其官网上可解析 dex 文件的<a href="http://www.sweetscape.com/010editor/templates/" target="_blank" rel="external">脚本文件</a>，可高亮相应的二进制。</p>
<p>linux 下可以使用 <code>hexdump</code> 查看某文件的二进制数据 -&gt; <code>hexdump -C classes.dex</code></p>
<p><a href="http://archive.oreilly.com/linux/cmd/cmd.csp?path=h/hexdump" target="_blank" rel="external">常用选项</a></p>
<table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>将每个字节显示为8进制</td>
</tr>
<tr>
<td>-c</td>
<td>将每个字节显示为ASCII字符</td>
</tr>
<tr>
<td>-C</td>
<td>每个字节显示为16进制和相应的ASCII字符</td>
</tr>
<tr>
<td>-d</td>
<td>每两个字节显示为10进制</td>
</tr>
<tr>
<td>-o</td>
<td>每两个字节显示为8进制</td>
</tr>
<tr>
<td>-x</td>
<td>每两个字节显示为16进制</td>
</tr>
</tbody>
</table>
<p><strong>某 dex 文件的头部：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00000000  64 65 78 0a 30 33 35 00  3b ba fe c3 83 7e aa be  |dex.035.;....~..|</div><div class="line">00000010  09 97 71 1e 17 96 9f e9  0c bd 01 60 b4 2a 1a c9  |..q........`.*..|</div><div class="line">00000020  c4 10 00 00 70 00 00 00  78 56 34 12 00 00 00 00  |....p...xV4.....|</div><div class="line">00000030  00 00 00 00 00 10 00 00  5c 00 00 00 70 00 00 00  |........\...p...|</div><div class="line">00000040  19 00 00 00 e0 01 00 00  12 00 00 00 44 02 00 00  |............D...|</div><div class="line">00000050  01 00 00 00 1c 03 00 00  2b 00 00 00 24 03 00 00  |........+...$...|</div><div class="line">00000060  02 00 00 00 7c 04 00 00  08 0c 00 00 bc 04 00 00  |....|...........|</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>binary</th>
<th>field</th>
</tr>
</thead>
<tbody>
<tr>
<td>64 65 78 0a 30 33 35 00</td>
<td>magic</td>
</tr>
<tr>
<td>3b ba fe c3</td>
<td>checksum</td>
</tr>
<tr>
<td>83 7e aa be 09 97 71 1e 17 96 9f e9 0c bd 01 60 b4 2a 1a c9</td>
<td>signature</td>
</tr>
<tr>
<td>c4 10 00 00</td>
<td>fileSize</td>
</tr>
<tr>
<td>70 00 00 00</td>
<td>headerSize</td>
</tr>
<tr>
<td>78 56 34 12</td>
<td>endianTag</td>
</tr>
<tr>
<td>00 00 00 00</td>
<td>linkSize</td>
</tr>
<tr>
<td>00 00 00 00</td>
<td>linkOff</td>
</tr>
<tr>
<td>00 10 00 00</td>
<td>mapOff</td>
</tr>
<tr>
<td>5c 00 00 00</td>
<td>stringIdsSize</td>
</tr>
<tr>
<td>70 00 00 00</td>
<td>stringIdsOff</td>
</tr>
<tr>
<td>19 00 00 00</td>
<td>typeIdsSize</td>
</tr>
<tr>
<td>e0 01 00 00</td>
<td>typeIdsOff</td>
</tr>
<tr>
<td>12 00 00 00</td>
<td>protoIdsSize</td>
</tr>
<tr>
<td>44 02 00 00</td>
<td>protoIdsOff</td>
</tr>
<tr>
<td>01 00 00 00</td>
<td>fieldIdsSize</td>
</tr>
<tr>
<td>1c 03 00 00</td>
<td>fieldIdsOff</td>
</tr>
<tr>
<td>2b 00 00 00</td>
<td>methodIdsSize</td>
</tr>
<tr>
<td>24 03 00 00</td>
<td>methodIdsOff</td>
</tr>
<tr>
<td>02 00 00 00</td>
<td>classDefsSize</td>
</tr>
<tr>
<td>7c 04 00 00</td>
<td>classDefsOff</td>
</tr>
<tr>
<td>08 0c 00 00</td>
<td>dataSize</td>
</tr>
<tr>
<td>bc 04 00 00</td>
<td>dataOff</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="写程序解析-DexHeader"><a href="#写程序解析-DexHeader" class="headerlink" title="写程序解析 DexHeader"></a>写程序解析 DexHeader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">class DexStruct(object):</div><div class="line">    DexHeader = &#123;</div><div class="line">          &quot;magic&quot;: 0,</div><div class="line">          &quot;checkSum&quot;: 0,</div><div class="line">          &apos;signature&apos;: 0,</div><div class="line">          &apos;fileSize&apos;: 0,</div><div class="line">          &quot;headerSize&quot;: 0,</div><div class="line">          &quot;endianTag&quot;: 0,</div><div class="line">          &quot;linkSize&quot;: 0,</div><div class="line">          &quot;linkOff&quot;: 0,</div><div class="line">          &quot;mapOff&quot;: 0,</div><div class="line">          &quot;stringIdsSize&quot;: 0,</div><div class="line">          &quot;stringIdsOff&quot;: 0,</div><div class="line">          &quot;typeIdsSize&quot;: 0,</div><div class="line">          &quot;typeIdsOff&quot;: 0,</div><div class="line">          &quot;protoIdsSize&quot;: 0,</div><div class="line">          &quot;protoIdsOff&quot;: 0,</div><div class="line">          &quot;fieldIdsSize&quot;: 0,</div><div class="line">          &quot;fieldIdsOff&quot;: 0,</div><div class="line">          &quot;methodIdsSize&quot;: 0,</div><div class="line">          &quot;methodIdsOff&quot;: 0,</div><div class="line">          &quot;classDefsSize&quot;: 0,</div><div class="line">          &quot;classDefsOff&quot;: 0,</div><div class="line">          &quot;dataSize&quot;: 0,</div><div class="line">          &quot;dataOff&quot;: 0,   &#125;</div><div class="line">def parseHeader(header_data):</div><div class="line">        header_list = [header_data[i:i+4] for i in range(32,112,4)]</div><div class="line">        header_list.insert(0,header_data[12:32])</div><div class="line">        header_list.insert(0,header_data[8:12])</div><div class="line">        header_list.insert(0,header_data[:8])</div><div class="line">        DexStruct.DexHeader[&apos;magic&apos;] = struct.unpack(&apos;8s&apos;,header_list[0])[0]</div><div class="line">        if DexStruct.DexHeader[&apos;magic&apos;] != &quot;dex\n035\0&quot;:</div><div class="line">            print &apos;invalid dex file.&apos;</div><div class="line">            exit(-1)</div><div class="line">        DexStruct.DexHeader[&apos;checkSum&apos;] = struct.unpack(&apos;I&apos;,header_list[1])[0]</div><div class="line">        DexStruct.DexHeader[&apos;signature&apos;] = struct.unpack(&apos;20s&apos;,header_list[2])[0]</div><div class="line">        DexStruct.DexHeader[&apos;fileSize&apos;] = struct.unpack(&apos;I&apos;,header_list[3])[0]</div><div class="line">        DexStruct.DexHeader[&apos;headerSize&apos;] = struct.unpack(&apos;I&apos;,header_list[4])[0]</div><div class="line">        DexStruct.DexHeader[&apos;endianTag&apos;] = struct.unpack(&apos;I&apos;,header_list[5])[0]</div><div class="line">        DexStruct.DexHeader[&apos;linkSize&apos;] = struct.unpack(&apos;I&apos;,header_list[6])[0]</div><div class="line">        DexStruct.DexHeader[&apos;linkOff&apos;] = struct.unpack(&apos;I&apos;,header_list[7])[0]</div><div class="line">        DexStruct.DexHeader[&apos;mapOff&apos;] = struct.unpack(&apos;I&apos;,header_list[8])[0]</div><div class="line">        DexStruct.DexHeader[&apos;stringIdsSize&apos;] = struct.unpack(&apos;I&apos;,header_list[9])[0]</div><div class="line">        DexStruct.DexHeader[&apos;stringIdsOff&apos;] = struct.unpack(&apos;I&apos;,header_list[10])[0]</div><div class="line">        DexStruct.DexHeader[&apos;typeIdsSize&apos;] = struct.unpack(&apos;I&apos;,header_list[11])[0]</div><div class="line">        DexStruct.DexHeader[&apos;typeIdsOff&apos;] = struct.unpack(&apos;I&apos;,header_list[12])[0]</div><div class="line">        DexStruct.DexHeader[&apos;protoIdsSize&apos;] = struct.unpack(&apos;I&apos;,header_list[13])[0]</div><div class="line">        DexStruct.DexHeader[&apos;protoIdsOff&apos;] = struct.unpack(&apos;I&apos;,header_list[14])[0]</div><div class="line">        DexStruct.DexHeader[&apos;fieldIdsSize&apos;] = struct.unpack(&apos;I&apos;,header_list[15])[0]</div><div class="line">        DexStruct.DexHeader[&apos;fieldIdsOff&apos;] = struct.unpack(&apos;I&apos;,header_list[16])[0]</div><div class="line">        DexStruct.DexHeader[&apos;methodIdsSize&apos;] = struct.unpack(&apos;I&apos;,header_list[17])[0]</div><div class="line">        DexStruct.DexHeader[&apos;methodIdsOff&apos;] = struct.unpack(&apos;I&apos;,header_list[18])[0]</div><div class="line">        DexStruct.DexHeader[&apos;classDefsSize&apos;] = struct.unpack(&apos;I&apos;,header_list[19])[0]</div><div class="line">        DexStruct.DexHeader[&apos;classDefsOff&apos;] = struct.unpack(&apos;I&apos;,header_list[20])[0]</div><div class="line">        DexStruct.DexHeader[&apos;dataSize&apos;] = struct.unpack(&apos;I&apos;,header_list[21])[0]</div><div class="line">        DexStruct.DexHeader[&apos;dataOff&apos;] = struct.unpack(&apos;I&apos;,header_list[22])[0]</div></pre></td></tr></table></figure>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik Executable format</a></p>
<p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">《Android 软件安全与逆向分析》</a></p>
<p><a href="http://www.blogfshare.com/dex-format.html" target="_blank" rel="external">Android安全–Dex文件格式详解</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何运行 .smali 程序]]></title>
      <url>/2015/11/16/how-to-run-file-ended-with-smali/</url>
      <content type="html"><![CDATA[<h2 id="准备-smali-程序"><a href="#准备-smali-程序" class="headerlink" title="准备 smali 程序"></a>准备 smali 程序</h2><a id="more"></a>
<p>从 《Android 软件安全与逆向》书中抠出一段，起名为 <code>FirstSmali.smali</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">.class public LFirstSmali;  # 定义类名</div><div class="line">.super Ljava/lang/Object;   # 定义父类</div><div class="line">.method public static main([Ljava/lang/String;)V     # 声明静态方法</div><div class="line">    .registers 4     # 寄存器</div><div class="line">    #.parameter      # 参数</div><div class="line">    .prologue      # 代码起始</div><div class="line">    nop</div><div class="line">    nop</div><div class="line">    nop</div><div class="line">    nop</div><div class="line">    #数据定义</div><div class="line">    const/16 v0,0x8</div><div class="line">    const/4 v1,0x5</div><div class="line">    const/4 v2,0x3</div><div class="line">    #数据操作</div><div class="line">    move v1,v2</div><div class="line">    #数组操作</div><div class="line">    new-array v0,v0,[I</div><div class="line">    array-length v1,v0</div><div class="line">    #实例操作</div><div class="line">    new-instance v1,Ljava/lang/StringBuilder;</div><div class="line">    #方法调用</div><div class="line">    invoke-direct &#123;v1&#125;,Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</div><div class="line">    #跳转</div><div class="line">    if-nez v0, :cond_0</div><div class="line">    goto :goto_0</div><div class="line">    :cond_0</div><div class="line">    #数据转换</div><div class="line">    int-to-float v2,v2</div><div class="line">    #运算</div><div class="line">    add-float v2,v2,v2</div><div class="line">    #比较</div><div class="line">    cmpl-float v0,v2,v2</div><div class="line">    #字段操作</div><div class="line">    sget-object v0,Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line">    const-string v1,&quot;Hello Smali&quot;</div><div class="line">    #调用</div><div class="line">    invoke-virtual &#123;v0,v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</div><div class="line">    #返回</div><div class="line">    :goto_0</div><div class="line">    return-void</div><div class="line">    return-void     # 返回空</div><div class="line">.end method</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="编译-smali-程序"><a href="#编译-smali-程序" class="headerlink" title="编译 smali 程序"></a>编译 smali 程序</h2><p>将 <code>.smali</code> 文件编译为 <code>.dex</code> 文件 :<br><code>java -jar smali.jar -o FirstSmali.dex FirstSmali.smali</code></p>
<hr>
<h2 id="执行-smali-程序"><a href="#执行-smali-程序" class="headerlink" title="执行 smali 程序"></a>执行 smali 程序</h2><p>打开 <code>adb</code> 环境，连上手机，在命令行下<br>执行 <code>adb devices</code> 查看手机是否连接成功；<br>执行 <code>adb push FirstSmali.dex /sdcard/</code> 将 dex 文件推到手机上；<br>执行如下命令就 OK 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dalvikvm -cp /sdcard/FirstSmali.dex FirstSmali</div></pre></td></tr></table></figure></p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p><code>-cp</code> 是 <code>classpath</code>  的意思，<code>dalvikvm</code> 命令第一个参数指定类路径，第二个指定类名。</p>
<p>另外，如果想要 push 到如 <code>data/local</code> 之类的目录下是没有权限的，可以先 push 到 sdcard，进入 <code>adb shell</code> 执行 <code>su</code> 获得 root 权限之后，就可以复制到 <code>data</code> 目录了。</p>
<p>本文程序只有一个 dex 文件，多个的话需要打包为 <code>zip</code> ，将此 zip 文件作为 <code>dalvikvm</code> 的第一个参数便可。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> smali </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[校验数字签名防止 apk 被二次打包 - Java层校验]]></title>
      <url>/2015/11/12/check-signature-for-avoiding-fake-app-java-level-check/</url>
      <content type="html"><![CDATA[<blockquote>
<p>测试环境<br>Ubuntu 14.04<br>Lenovo Android 5.1<br>Lenovo Android 4.2.2<br>Android Studio</p>
</blockquote>
<a id="more"></a>
<h2 id="普及签名包名知识"><a href="#普及签名包名知识" class="headerlink" title="普及签名包名知识"></a>普及签名包名知识</h2><p>包名 (Package Name) 相当于「应用的身份证」，是系统用来<strong>区分不同应用</strong>的字段，重复的包名会被认为是同一款应用。<br>签名文件相当于「开发者的身份证」，目的是为了<strong>检验应用是否被人更改过</strong>（应用必须签名过才能正常安装）。</p>
<p>包名相同签名相同时，会发生 替换安装 / 应用升级；<br>包名相同签名不同时，安装失败；<br>包名不同签名相同时，相当于同一开发者的两个应用，互相不冲突。</p>
<blockquote>
<p>签名的注意事项<br>所有的Android应用都必须有数字签名，没有不存在数字签名的应用，包括模拟器上运行的。Android系统不会安装没有数字证书的应用。<br>签名的数字证书不需要权威机构来认证，是开发者自己产生的数字证书，即所谓的自签名。<br>正式发布一个Android应用时，必须使用一个合适的私钥生成的数字证书来给程序签名，不能使用ADT插件或者ANT工具生成的调试证书来发布。<br>Android将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，而不是用来决定最终用户可以安装哪些应用程序。</p>
</blockquote>
<hr>
<h2 id="为大众点评换签名"><a href="#为大众点评换签名" class="headerlink" title="为大众点评换签名"></a>为大众点评换签名</h2><p>按照常规步骤使用 <code>apktool</code> + <code>signapk</code> 反编译、编译、签名并安装到手机上（没有修改任何代码），打开 app 选择城市后界面如下图并很快退出：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/images/github-io/Android/dianping-crash.jpeg-style1" alt="dianping-crash"></p>
<p>说明点评对签名进行了校验 。</p>
<hr>
<h2 id="分析校验方法"><a href="#分析校验方法" class="headerlink" title="分析校验方法"></a>分析校验方法</h2><h3 id="怎么退出的？"><a href="#怎么退出的？" class="headerlink" title="怎么退出的？"></a>怎么退出的？</h3><p>打开 apktool 反编译得到的文件夹下的 <code>AndroidManifest.xml</code> ，得到程序包名：<code>com.dianping.v1</code> 。<br>清除大众点评的数据，打开 as，连上手机，log 的过滤条件设为 com.dianping ，在选择城市之前清一下 log ，在 log 里搜索 “die”，比较明显的是有四处：</p>
<p>进程死亡：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Process com.dianping.v1 (pid 19182) has died</div><div class="line">Process com.dianping.v1 (pid 19586) has died</div><div class="line">Process com.dianping.v1 (pid 19650) has died</div></pre></td></tr></table></figure></p>
<p>app 死亡：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Force removing ActivityRecord&#123;266e5efd u0 com.dianping.v1/.NovaMainActivity t14010&#125;: app died, no saved state</div></pre></td></tr></table></figure></p>
<p>其中前两个进程死亡之后都有开启进程的操作，说明第一次校验失败后重试了两次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startProcess: name=com.dianping.v1 app=null knownToBeDead=true thread=null pid=-1</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startProcess: name=com.dianping.v1 app=null knownToBeDead=true thread=null pid=-1</div></pre></td></tr></table></figure>
<p>最后一个直接杀死了 app，没有再继续创建进程。</p>
<p>在进程结束之前，发生错误的调用记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">9586-19586/? D/AccessibilityManager:     at com.dianping.base.app.NovaActivity.setContentView(NovaActivity.java:722)</div><div class="line"> 9586-19586/? D/AccessibilityManager:     at com.dianping.main.guide.MainActivity.setOnContentView(MainActivity.java:339)</div><div class="line"> 9586-19586/? D/AccessibilityManager:     at com.dianping.base.basic.FragmentTabActivity.onCreate(FragmentTabActivity.java:51)</div><div class="line"> 9586-19586/? D/AccessibilityManager:     at com.dianping.base.widget.NovaFragmentTabActivity.onCreate(NovaFragmentTabActivity.java:26)</div><div class="line"> 9586-19586/? D/AccessibilityManager:     at com.dianping.main.guide.MainActivity.onCreate(MainActivity.java:169)</div><div class="line"> 9586-19586/? D/AccessibilityManager:     at com.dianping.v1.NovaMainActivity.onCreate(NovaMainActivity.java:15)</div></pre></td></tr></table></figure></p>
<h3 id="代码探索"><a href="#代码探索" class="headerlink" title="代码探索"></a>代码探索</h3><p>解压 apk 文件，发现有 3 个 dex 文件，先拿第一个下手，JD-GUI 打开发现代码没有混淆！</p>
<p>调用记录中的文件从上往下过一遍，发现在 <code>com.dianping.main.guide.MainActivity.onCreate()</code> 方法中有校验签名的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!checkSignature()) &#123;    </div><div class="line">      Process.killProcess(Process.myPid());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>checkSignature</code> 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private boolean checkSignature()</div><div class="line">&#123;</div><div class="line"> try</div><div class="line"> &#123;</div><div class="line">   Signature[] arrayOfSignature = getPackageManager().getPackageInfo(getPackageName(), 64).signatures;     //获得签名数组</div><div class="line">   if (arrayOfSignature != null)</div><div class="line">   &#123;</div><div class="line">     if (arrayOfSignature.length == 0) &#123;</div><div class="line">       return false;</div><div class="line">     &#125;</div><div class="line">     int j = arrayOfSignature.length;</div><div class="line">     int i = 0;</div><div class="line">     while (i &lt; j)   //如果数组中的某个元素值与 &apos;ac6fc3fe&apos; 相等，返回校验成功；如果直到结束也没有相等的元素，返回失败</div><div class="line">     &#123;               //只比较一个特定的元素，可能也是为了不把整个签名泄露出来，同时也做到了一定程度的校验</div><div class="line">       String str = Integer.toHexString(arrayOfSignature[i].toCharsString().hashCode());</div><div class="line">       if (!&quot;ac6fc3fe&quot;.equalsIgnoreCase(str))   </div><div class="line">       &#123;</div><div class="line">         boolean bool = &quot;600cf559&quot;.equalsIgnoreCase(str);       //这个比较好像没用</div><div class="line">         if (!bool) &#123;&#125;</div><div class="line">       &#125;</div><div class="line">       else</div><div class="line">       &#123;</div><div class="line">         return true;</div><div class="line">       &#125;</div><div class="line">       i += 1;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return false;</div><div class="line"> &#125;</div><div class="line"> catch (Exception localException) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关 API：</p>
<p><code>public Signature[] signatures</code><br>Array of all signatures read from the package file. This is only filled in if the flag GET_SIGNATURES was set.</p>
<p><code>public static final int GET_SIGNATURES</code><br>PackageInfo flag: return information about the signatures included in the package.<br>Constant Value: 64 (0x00000040)</p>
<p><code>public boolean equalsIgnoreCase (String string)</code><br>Compares the given string to this string ignoring case.<br>The strings are compared one char at a time.</p>
<h3 id="流程修改"><a href="#流程修改" class="headerlink" title="流程修改"></a>流程修改</h3><p>在 <code>smali/com/dianping/main/guide/MainActivity.smali</code> 中搜索 <code>ac6fc3fe</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.line 358</div><div class="line">    .local v4, &quot;myHash&quot;:Ljava/lang/String;</div><div class="line">    const-string v9, &quot;ac6fc3fe&quot;</div><div class="line">    invoke-virtual &#123;v9, v4&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</div><div class="line">    move-result v9</div><div class="line">    if-nez v9, :cond_2      //if(!equal(..)) return 1</div></pre></td></tr></table></figure></p>
<p>找到 <code>con_2</code> 的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.line 359</div><div class="line">:cond_2</div><div class="line">const/4 v8, 0x1</div><div class="line">goto :goto_0</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:goto_0</div><div class="line">    return v8</div></pre></td></tr></table></figure>
<p>所以把 <code>if-nez v9, :cond_2</code> 改成 <code>if-eqz v9, :cond_2</code> 就可以了，当然，修改方法还有很多。</p>
<h3 id="打包签名"><a href="#打包签名" class="headerlink" title="打包签名"></a>打包签名</h3><p>点评可以正常打开，正常登录，正常使用了。</p>
<hr>
<blockquote>
<p>番外：<br>而另一台手机 (Lenovo Android 4.2.2) 测试进程会不断重新创建。<br>应用 crash 之后 App 对应的 Process 都被杀死，然后安排重启 Service，重新启动 Task 栈顶的 Activity 。</p>
</blockquote>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ituring.com.cn/book/1131" target="_blank" rel="external">Android软件安全与逆向分析</a><br><a href="http://www.wandoujia.com/blog/xibaibai-diary-3" target="_blank" rel="external">洗白白手记：绕开 Android 应用开发的那些「坑」</a><br><a href="http://www.oschina.net/question/163910_27292#tags_nav" target="_blank" rel="external">给 Android 应用程序签名</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 安全工具包（持续更新）]]></title>
      <url>/2015/11/12/Android-security-tools/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>工具清单</strong></p>
<ul>
<li>Apktool/SHakaApktool</li>
<li>smali &amp; baksmali</li>
<li>dex2jar</li>
<li>JD-GUI</li>
<li>signapk</li>
<li>dx &amp; ddx</li>
</ul>
</blockquote>
<p>以上工具可点击 <a href="https://github.com/kiya-z/Android/tree/master/tools" target="_blank" rel="external">这里</a> 打包下载</p>
<p><strong>本文环境：<code>Ubuntu 14.04.3 LTS 64-bit</code></strong></p>
<a id="more"></a>
<hr>
<p><strong>工具使用场景</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">java-&gt;class: javac</div><div class="line">smali-&gt;dex: smali.jar</div><div class="line">class-&gt;dex: dx</div><div class="line">dex-&gt;arm: execute</div><div class="line">dex-&gt;smali: baksmali</div><div class="line">dex-&gt;class: dex2jar</div><div class="line">class-&gt;java: JD-GUI</div></pre></td></tr></table></figure>
<hr>
<h1 id="Apktool"><a href="#Apktool" class="headerlink" title="Apktool"></a><strong>Apktool</strong></h1><p>点击 <a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="external">官网</a> 下载，里面也有详细的安装步骤。</p>
<p><strong>中文步骤及注意事项:</strong></p>
<p>（<em>此处为 Apktool 2.x 版本</em>）</p>
<ol>
<li>右键另存 <a href="https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" target="_blank" rel="external">脚本文件</a>，名为 <code>apktool</code> 。如果不能另存，打开 <a href="https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool" target="_blank" rel="external">脚本文件</a>， 复制全部内容到新建文件 <code>apktool</code> 中；</li>
<li>下载 <a href="https://bitbucket.org/iBotPeaches/apktool/downloads" target="_blank" rel="external">apktool</a>，将其重命名为 <code>apktool.jar</code> 。</li>
<li>如果是系统是 64 位，需要安装 32 位的库文件。如何安装可参考 <a href="http://stackoverflow.com/questions/23182765/how-to-install-ia32-libs-in-ubuntu-14-04-lts-trusty-tahr" target="_blank" rel="external">How to install ia32-libs in Ubuntu 14.04 LTS (Trusty Tahr)</a> . 或者直接执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo -i</div><div class="line">cd /etc/apt/sources.list.d</div><div class="line">echo &quot;deb http://old-releases.ubuntu.com/ubuntu/ raring main restricted universe multiverse&quot; &gt;ia32-libs-raring.list</div><div class="line">apt-get update</div><div class="line">apt-get install ia32-libs</div><div class="line">rm ia32-libs-raring.list /etc/apt/sources.list.d</div><div class="line">apt-get update</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行完成可按 <code>Ctrl+D</code> 注销 root .</p>
<ol>
<li>把 <code>apktool</code> 和 <code>apktool.jar</code> 两个文件移动到 <code>usr/local/bin</code> . 此步骤需要 <code>sudo</code> .</li>
<li>为这两个文件加上可执行权限。</li>
<li>执行 <code>apktool</code> 测试效果。如果提示 <code>can&#39;t find file apktool.jar</code> ，可能是因为当前用户没有 <code>apktool.jar</code> 的读权限，试试用 <code>sudo apktool</code> 或者为其加上读权限。</li>
</ol>
<hr>
<h1 id="ShakaApktool"><a href="#ShakaApktool" class="headerlink" title="ShakaApktool"></a>ShakaApktool</h1><p>ShakaApktool是一个比apktool更强大的工具,源代码在此<a href="https://github.com/rover12421/ShakaApktool" target="_blank" rel="external">https://github.com/rover12421/ShakaApktool</a>.<br>尽情享用. :p</p>
<hr>
<h1 id="smali-amp-baksmali"><a href="#smali-amp-baksmali" class="headerlink" title="smali &amp; baksmali"></a><strong>smali &amp; baksmali</strong></h1><p>Apktool 中内置了 smali 和 baksmali，<a href="https://bitbucket.org/JesusFreke/smali/downloads" target="_blank" rel="external">下载链接</a></p>
<hr>
<h1 id="dex2jar"><a href="#dex2jar" class="headerlink" title="dex2jar"></a><strong>dex2jar</strong></h1><p>下载 <a href="https://bitbucket.org/pxb1988/dex2jar/downloads" target="_blank" rel="external">dex2jar</a> 解压，你可以选择为所有的 <code>.sh</code> 文件加上执行权限，目前我只加了 <code>d2j-dex2jar.sh</code> 和 <code>d2j_invoke.sh</code> 。如果报错找不到命令，就是因为你没有加执行权限。</p>
<hr>
<h1 id="JD-GUI"><a href="#JD-GUI" class="headerlink" title="JD-GUI"></a><strong>JD-GUI</strong></h1><p>去 <a href="http://jd.benow.ca/" target="_blank" rel="external">官网</a> 下载相应版本。<br>我下载的是 <code>.deb</code> 文件，安装命令为 <code>sudo dpkg -i filename</code> .</p>
<hr>
<h1 id="signapk"><a href="#signapk" class="headerlink" title="signapk"></a><strong>signapk</strong></h1><p>进行签名需要 <code>sianapk.sh</code> 、<code>signapk.jar</code> 和两个签名文件 <code>testkey.pk8</code> 、<code>testkey.x509.pem</code> 。<br><a href="https://github.com/kiya-z/Android/tree/master/tools/signapk" target="_blank" rel="external">点击下载</a></p>
<hr>
<h1 id="dx-amp-ddx"><a href="#dx-amp-ddx" class="headerlink" title="dx &amp; ddx"></a><strong>dx &amp; ddx</strong></h1><p><code>dx</code> 是整个编译过程的一部分，将 Java 字节码转换为 Dalvik 字节码（class 文件变成 dex 文件），<code>ddx</code> 则正好相反。<br>你可以在 SDK 中找到它们，或者 <a href="https://github.com/kiya-z/Android/tree/master/tools" target="_blank" rel="external">下载</a> 。</p>
<hr>
<h1 id="010-editor"><a href="#010-editor" class="headerlink" title="010 editor"></a><strong>010 editor</strong></h1><p>查看二进制数据的神器，具体在这里 -&gt; <a href="http://kiya-z.github.io/2015/11/19/tools-010-editor/" target="_blank" rel="external">号称 Edit Everything 的 010 Editor</a></p>
<hr>
<h1 id="adb"><a href="#adb" class="headerlink" title="adb"></a><strong>adb</strong></h1><p>全程 android debug bridge，位于 SDK 中的 platform-tools 中。</p>
<hr>
<h1 id="fastboot"><a href="#fastboot" class="headerlink" title="fastboot"></a><strong>fastboot</strong></h1><p>位于 SDK 中的 platform-tools,可用来刷recovery文件</p>
<hr>
<h1 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a><strong>jadx</strong></h1><p>dex2java工具,网址:<a href="https://github.com/skylot/jadx" target="_blank" rel="external">https://github.com/skylot/jadx</a></p>
<hr>
<blockquote>
<p>to be continued.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 之 接口和多态引发的血案]]></title>
      <url>/2015/11/11/Python-a-murder-about-interface-and-polymorphism/</url>
      <content type="html"><![CDATA[<h1 id="事故发生地"><a href="#事故发生地" class="headerlink" title="事故发生地"></a>事故发生地</h1><p>在学习<a href="http://www.maiziedu.com/course/python/545-7480/" target="_blank" rel="external"> Python 面向对象视频 之 鸭子类型与多态 </a>时看到这样两句话不得其解：</p>
<blockquote>
<p>非动态语言必须通过继承和接口实现多态<br>动态语言不需要实现接口</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="菜鸟的问题"><a href="#菜鸟的问题" class="headerlink" title="菜鸟的问题"></a>菜鸟的问题</h1><p>(非动态语言以 Java 为例，动态语言以 Python 为例)</p>
<ol>
<li>接口和多态是什么关系？</li>
<li>Python 为什么没有接口？没有接口怎么实现接口对应的设计模式</li>
<li>Python 为什么没有重载？</li>
<li>Python 的多态是什么样的？</li>
</ol>
<hr>
<h2 id="接口和多态是什么关系？"><a href="#接口和多态是什么关系？" class="headerlink" title="接口和多态是什么关系？"></a>接口和多态是什么关系？</h2><p>  在我的理解中，多态具有两种形式，重载和重写：</p>
<blockquote>
<p><strong>重载</strong>：<em>在同一个类中</em>，相同的方法名对应着不同的方法实现，其区别在于他们需要的参数和返回值不同。<br><strong>重写</strong>：<em>用于父类和子类间</em>，子类重写父类的方法，只是对应的方法实现不同，其方法名和参数都相同。</p>
</blockquote>
<p>这样看来，重写是基于继承的。那么接口呢？好像除了强制要求子类实现某些方法，我不知道还有什么别的作用。<br>正因如此，接口只是一个规范。在多个类都实现一个接口的时候他的作用就体现出来了，我们不需要知道在某个类中这个方法的具体实现，只需要这个类中有这个方法而我们可以直接调用就可以了。有了这样一个统一的标准，我们就不必担心同样功能的方法被起了各种各样的名字了。<br>所以，我觉得可以用这么一句话回答这个问题，<strong>接口不是实现多态的，而是基于多态的，有了多态接口才能发挥作用</strong>。</p>
<hr>
<h2 id="Python-为什么没有接口？没有接口怎么实现接口对应的设计模式"><a href="#Python-为什么没有接口？没有接口怎么实现接口对应的设计模式" class="headerlink" title="Python 为什么没有接口？没有接口怎么实现接口对应的设计模式"></a>Python 为什么没有接口？没有接口怎么实现接口对应的设计模式</h2><p>接口的作用就是规范，规范参数类型，返回值等等，从而使相同的调用能够实现不同的效果；并且接口也是为了用来弥补语言自己表达能力的不足，如：Java 只支持单继承，为了使类拥有更多的特性，使用了多实现来弥补。静态的语言必须全部都规定好才能正确使用。<br>而在 Python  中，变量是没有类型的，不需要事先规定，不管调用者传入什么类型的对象，被调用者就会认为那就是我所需要的对象(鸭子类型)，如果在运行时传入的对象不具备需要的属性或方法，程序会直接报错。需要实现这个方法的话，就照实现就是了，返回和形参不限制类型，比如：在创建了类的实例后，动态地给该实例加上一个函数属性。这就是动态类型的优势。<br>这种风格被称为“<strong>鸭子类型</strong>”：</p>
<blockquote>
<p>在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。<br>在我想成为鸭子的时候，不是我必须真的是个鸭子，而是我的行为表现的像是个鸭子，那我就是个鸭子</p>
</blockquote>
<p>相关概念 - “<strong>鸭子测试</strong>”：</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”<br>“换言之，不要检查它是不是一个鸭子：检查它像不像一个鸭子地叫，等等。取决于你需要哪个像鸭子的行为的子集来使用语言。”</p>
</blockquote>
<hr>
<h2 id="Python-为什么没有重载？"><a href="#Python-为什么没有重载？" class="headerlink" title="Python 为什么没有重载？"></a>Python 为什么没有重载？</h2><blockquote>
<p>函数重载主要是为了解决两个问题：</p>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。</li>
</ol>
</blockquote>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。<br><em>对于情况 1</em>，函数功能相同，但是参数类型不同，Python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 Python 中很可能是相同的代码，没有必要做成两个不同函数。<br><em>对于情况 2</em> ，函数功能相同，但参数个数不同，Python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。<br>好了，鉴于情况 1 跟 情况 2 都有了解决方案，Python 自然就不需要函数重载了。</p>
<hr>
<h2 id="Python-的多态是什么样的？"><a href="#Python-的多态是什么样的？" class="headerlink" title="Python 的多态是什么样的？"></a>Python 的多态是什么样的？</h2><p>多态即多种形态，在运行时确定其状态，在编译阶段无法确定其类型，这就是多态。<br>1）Python是解释性语言。不进行预编译，因此它就只在运行时确定其状态；<br>2）Python中变量是弱类型的。在定义时不用指明其类型，它会根据需要在运行时确定变量的类型。</p>
<hr>
<blockquote>
<p>结语：一些粗浅之语，有长进再补充。</p>
</blockquote>
<hr>
<h1 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h1><p><a href="http://www.zhihu.com/question/20111251" target="_blank" rel="external"> Java 中的接口有什么作用？</a><br><a href="http://www.zhihu.com/question/20685467" target="_blank" rel="external"> Python 里没有接口，如何写设计模式？</a><br><a href="http://www.zhihu.com/question/20053359" target="_blank" rel="external">为什么 Python  不支持函数重载？</a><br><a href="http://www.cnblogs.com/dolphin0520/archive/2013/04/03/2997499.html" target="_blank" rel="external"> Python面向对象编程(二)</a><br><a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">鸭子类型</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Github Pages + Hexo + 多说 搭建博客全过程 - 基础篇]]></title>
      <url>/2015/11/10/use-Github-Pages-Hexo-duoshuo-to-set-up-a-blog-basic-steps/</url>
      <content type="html"><![CDATA[<p>看了很多博客，最后发现官方文档才是最可靠的！谨记！<br>本文只是自己尝试过程的记录，并非全部搭建方法。<br>&lt; 假设 git 已安装，Github 已注册 &gt;</p>
<blockquote>
<p>搭建环境：<br>os: Ubuntu 14.04.3 LTS<br>node: 4.2.2<br>hexo: 3.1.1<br>hexo theme: NexT<br>git: 1.9.1</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="Step-1-安装-Node-js"><a href="#Step-1-安装-Node-js" class="headerlink" title="Step 1 安装 Node.js"></a>Step 1 安装 Node.js</h2><ul>
<li>从<a href="https://nodejs.org/en/download/" target="_blank" rel="external">官网</a>下载系统对应的源码</li>
<li>依次执行以下命令解压编译安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xzvf node-v4.2.2.tar.gz</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Step-2-安装-Hexo"><a href="#Step-2-安装-Hexo" class="headerlink" title="Step 2 安装 Hexo"></a>Step 2 安装 Hexo</h2><ul>
<li>执行以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Step-3-搭建本地博客"><a href="#Step-3-搭建本地博客" class="headerlink" title="Step 3 搭建本地博客"></a>Step 3 搭建本地博客</h2><ul>
<li><p>初始化一枚目录存放博客, 进入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init blog</div><div class="line">cd blog</div></pre></td></tr></table></figure>
</li>
<li><p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时一个默认主题默认配置的 Hexo 博客就搭建完成了</p>
<ul>
<li><p>安装 Hexo 关于启动服务器的插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-server --save</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务器, 本地查看效果, 如果不指定端口，默认为4000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure>
</li>
<li><p>打开 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 查看效果</p>
</li>
<li>使用 <strong>Ctrl+c</strong> 停止服务</li>
</ul>
<hr>
<h2 id="Step-4-主题和配置"><a href="#Step-4-主题和配置" class="headerlink" title="Step 4 主题和配置"></a>Step 4 主题和配置</h2><p>在 <a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a> 选择某个喜欢的主题，以 NexT 为例，假设当前目录为 “blog”。</p>
<ul>
<li>前往<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="external">NexT主题发布页面</a>下载主题的压缩包<br>(这是 Next 的稳定版本，我试用了最新版本，有一些问题故转为稳定版本)</li>
<li>解压并将目录更名为next</li>
<li>将 next 移动至 <strong>blog/themes/</strong> 目录下</li>
<li>将 blog 目录下的 <strong>_config.yml</strong> 文件中的 theme 属性值改为 next</li>
<li>此时主题更换成功，可启动 server 验证效果</li>
<li>对于 _config.yml 中的其他属性可根据情况自行修改，基本的有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: 网站大标题</div><div class="line">subtitle: 网站小标题</div><div class="line">description: 你对于自己的描述</div><div class="line">author: 昵称</div><div class="line">avatar: 头像 (如:/images/avatar.jpg, images目录位于source目录下)</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Step-5-Github-的操作"><a href="#Step-5-Github-的操作" class="headerlink" title="Step 5 Github 的操作"></a>Step 5 Github 的操作</h2><ul>
<li>新建仓库名为 <strong>github用户名.github.io</strong><br>进入仓库，点击右侧 settings，在 Github Pages 标签下可看到  <em>Your site is published at <a href="http://你的用户名.github.io" target="_blank" rel="external">http://你的用户名.github.io</a>.</em> 这句话。 这时便可直接访问，如我的就是 <a href="http://kiya-z.github.io" target="_blank" rel="external">kiya-z.github.io</a>.</li>
</ul>
<hr>
<h2 id="Step-6-将博客部署到Github"><a href="#Step-6-将博客部署到Github" class="headerlink" title="Step 6 将博客部署到Github"></a>Step 6 将博客部署到Github</h2><ul>
<li><p>安装 hexo 关于 git 的组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
</li>
<li><p>在_config.yml 中为 git 添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git</div><div class="line">    repository: 你的仓库地址(https://github.com/用户名/用户名.github.io.git)</div><div class="line">    branch: master</div></pre></td></tr></table></figure>
</li>
<li><p>执行(每次修改都要执行这些命令才能在github pages看到效果)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
</li>
</ul>
<p>输入 github 的用户名和密码，部署完成之后访问你的如 <a href="http://kiya-z.github.io" target="_blank" rel="external">kiya-z.github.io</a> 的网址即可看到和本地一样的效果。</p>
<hr>
<h2 id="Step-7-关于写博客"><a href="#Step-7-关于写博客" class="headerlink" title="Step 7 关于写博客"></a>Step 7 关于写博客</h2><ul>
<li><p>新建博客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;文章名&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>使用编辑器写好文章后执行生成+部署(那两个～)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
</li>
<li><p>删除文章<br>直接删掉 <em>source/_post</em> 下对应文章的文件，然后重新生成+部署即可。有时可能要多刷新几次才能看到效果。</p>
</li>
</ul>
<hr>
<h2 id="Step-8-评论系统"><a href="#Step-8-评论系统" class="headerlink" title="Step 8 评论系统"></a>Step 8 评论系统</h2><ul>
<li>登录 <a href="http://duoshuo.com/" target="_blank" rel="external">http://duoshuo.com/</a> 点击我要安装，创建站点。站点地址是 Github Pages 的地址，多说域名自己填写。</li>
<li>由于 NexT 主题已经支持了多说，我们不需要添加其他代码，只需要在 <strong>_config.yml</strong> 中添加一个名为 <strong>duoshuo_shortname</strong> 的字段，其值为<strong>多说域名中自己填写的那部分</strong>，并不是全部多说域名。</li>
</ul>
<hr>
<blockquote>
<p>结语：欢迎指正交流。Aha～</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Cool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> instruction </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
