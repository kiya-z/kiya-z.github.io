<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kiya</title>
  <subtitle>世界は今日も平和ですねー</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kiya.studio/"/>
  <updated>2017-06-21T14:45:42.000Z</updated>
  <id>http://kiya.studio/</id>
  
  <author>
    <name>kiya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 逆向技巧总结</title>
    <link href="http://kiya.studio/2333/03/03/android-reversing-skills/"/>
    <id>http://kiya.studio/2333/03/03/android-reversing-skills/</id>
    <published>2333-03-02T19:03:03.000Z</published>
    <updated>2017-06-21T14:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>以代表性的 crackme 为例总结相关知识点。一緒に頑張りましょう！github 仓库<a href="https://github.com/kiya-z/android-reversing-challenges" target="_blank" rel="external">在此</a>。<br><a id="more"></a><br>[TOC]</p>
<h1 id="mobicrackNDK-apk"><a href="#mobicrackNDK-apk" class="headerlink" title="mobicrackNDK.apk"></a><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/mobicrackNDK.apk" target="_blank" rel="external">mobicrackNDK.apk</a></h1><h2 id="JNI-Onload-中通过-RegisterNatives-动态注册-jni-函数"><a href="#JNI-Onload-中通过-RegisterNatives-动态注册-jni-函数" class="headerlink" title="JNI_Onload 中通过 RegisterNatives 动态注册 jni 函数"></a>JNI_Onload 中通过 RegisterNatives 动态注册 jni 函数</h2><p><strong>相关函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">signed int __fastcall JNI_OnLoad(_JavaVM *a1)</div><div class="line"></div><div class="line">((int (__fastcall *)(_JavaVM *, _JNIEnv **, signed int))v1-&gt;functions-&gt;GetEnv)(v1, &amp;v8, 65540)  </div><div class="line">    /*  v1:JavaVM  v8:JniEnv  65540:jni version */</div><div class="line"></div><div class="line">((int (__fastcall *)(_JNIEnv *, char *))v3-&gt;functions-&gt;FindClass)(v3, v4)   </div><div class="line">    /*  v3:JNIEnv  v4:类名    */</div><div class="line"></div><div class="line">((int (__fastcall *)(_JNIEnv *, int, char **, signed int))v3-&gt;functions-&gt;RegisterNatives)(v3, v5, off_400C, 2)</div><div class="line">    /*  v3:JniEnv  v5:FindClass得到的jclass对象  off_400C:要注册的methods  2:注册的methods个数</div><div class="line">        method的格式为：函数名 函数描述(smali格式) 函数指针</div><div class="line">        例如(in ida)：</div><div class="line">            DCD aHello              ; &quot;hello&quot;</div><div class="line">            DCD aLjavaLangStr_1     ; &quot;()Ljava/lang/String;&quot;</div><div class="line">            DCD native_hello+1</div><div class="line">    */</div></pre></td></tr></table></figure>
<h2 id="init-array"><a href="#init-array" class="headerlink" title=".init_array"></a>.init_array</h2><p>根据 linker 源码, section 的执行顺序为 <code>.preinit_array</code> -&gt; <code>.init</code> -&gt; <code>.init_array</code> 。但 so 是不会执行 <code>.preinit_array</code> 的, 可以忽略。</p>
<p><code>.init_array</code> 是一个函数指针数组。编写代码时在函数声明时加上 <code>__attribute__((constructor))</code> 使之成为共享构造函数，即可使该函数出现在 <code>.init_array</code> section 中。</p>
<p>IDA 动态调试时 ‘ctrl+s’ 查看 section 信息即可定位这两个 setction，特别的，对于 <code>.init_array</code>，可通过搜索 <code>Calling %s @ %p for &#39;%s&#39;</code> 定位。</p>
<p><strong>部分源码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void soinfo::CallConstructors() &#123;</div><div class="line">    ...</div><div class="line">    // DT_INIT should be called before DT_INIT_ARRAY if both are present.</div><div class="line">    CallFunction(&quot;DT_INIT&quot;, init_func);</div><div class="line">    CallArray(&quot;DT_INIT_ARRAY&quot;, init_array, init_array_count, false);    // CallArray 中也会调用 CallFunction 函数</div><div class="line">&#125;</div><div class="line"></div><div class="line">void soinfo::CallFunction(const char* function_name UNUSED, linker_function_t function) &#123;</div><div class="line">  if (function == NULL || reinterpret_cast&lt;uintptr_t&gt;(function) == static_cast&lt;uintptr_t&gt;(-1)) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  TRACE(&quot;[ Calling %s @ %p for &apos;%s&apos; ]&quot;, function_name, function, name);</div><div class="line">  function();</div><div class="line">  TRACE(&quot;[ Done calling %s @ %p for &apos;%s&apos; ]&quot;, function_name, function, name);</div><div class="line"></div><div class="line">  // The function may have called dlopen(3) or dlclose(3), so we need to ensure our data structures</div><div class="line">  // are still writable. This happens with our debug malloc (see http://b/7941716).</div><div class="line">  set_soinfo_pool_protection(PROT_READ | PROT_WRITE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="misc-apk"><a href="#misc-apk" class="headerlink" title="misc.apk"></a><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/misc.apk" target="_blank" rel="external">misc.apk</a></h1><h2 id="dex-结构（修复dex）"><a href="#dex-结构（修复dex）" class="headerlink" title="dex 结构（修复dex）"></a>dex 结构（修复dex）</h2><p>快速简记：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>单位结构体占字节</th>
<th>共计字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>DexHeader</td>
<td>-</td>
<td>0x70h</td>
</tr>
<tr>
<td>String Table</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>Type Table</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>Proto Table</td>
<td>12</td>
<td>-</td>
</tr>
<tr>
<td>Field Table</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td>Method Table</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td>Class Def Table</td>
<td>32</td>
<td>-</td>
</tr>
<tr>
<td>Data Section(含Map Section)</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h1 id="simple-apk"><a href="#simple-apk" class="headerlink" title="simple.apk"></a><a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/simple.apk" target="_blank" rel="external">simple.apk</a></h1><h2 id="hook-系统函数"><a href="#hook-系统函数" class="headerlink" title="hook 系统函数"></a>hook 系统函数</h2><p>常规方法静态分析</p>
<h2 id="dump-内存搜索-flag"><a href="#dump-内存搜索-flag" class="headerlink" title="dump 内存搜索 flag"></a>dump 内存搜索 flag</h2><h3 id="1-利用-ddms-的-dump-HPROF-file-功能-带箭头的油桶图标"><a href="#1-利用-ddms-的-dump-HPROF-file-功能-带箭头的油桶图标" class="headerlink" title="1. 利用 ddms 的 dump HPROF file 功能 (带箭头的油桶图标)"></a>1. 利用 ddms 的 <code>dump HPROF file</code> 功能 (带箭头的油桶图标)</h3><p>搜索：<code>strings easyre.sjl.gossip.easyre.hprof | grep 0ctf</code></p>
<h3 id="2-利用-gore"><a href="#2-利用-gore" class="headerlink" title="2. 利用 gore"></a>2. 利用 gore</h3><p>gdb 附加进程后直接执行 <code>gcore</code> dump，搜索：<code>strings core.7967 | grep 0ctf</code></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://github.com/toToCW/CTF-Mobile" target="_blank" rel="external">CTF-Mobile</a></p>
<p><a href="https://github.com/ctfs/write-ups-2015" target="_blank" rel="external">write-ups-2015</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以代表性的 crackme 为例总结相关知识点。一緒に頑張りましょう！github 仓库&lt;a href=&quot;https://github.com/kiya-z/android-reversing-challenges&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="reversing" scheme="http://kiya.studio/tags/reversing/"/>
    
      <category term="CTF" scheme="http://kiya.studio/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>gdb 调试 Android app</title>
    <link href="http://kiya.studio/2017/06/21/android-gdb/"/>
    <id>http://kiya.studio/2017/06/21/android-gdb/</id>
    <published>2017-06-21T05:38:46.000Z</published>
    <updated>2017-06-21T13:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android NDK 在 r11 之后去掉了 toolchain 中的 gdb 工具，无奈下载了 r10 的 arm-linux-androideabi-gdb 和 gdbserver。<a id="more"></a></p>
<p>把  arm-linux-androideabi-gdb 放在 ndk 的 <code>toolchains/arm-linux-androideabi-4.9/prebuilt/*platform*-x86_64/bin</code> 目录下，把 <code>gdbserver</code> push 到手机的 <code>system/bin</code> 下并添加执行权限。</p>
<blockquote>
<p>本次测试用 crackme 来自 0CTF 2015 Quals : <a href="https://github.com/kiya-z/android-reversing-challenges/tree/master/apks/simple.apk" target="_blank" rel="external">simple.apk</a></p>
</blockquote>
<p>在手机上打开 app 并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ps | grep easy</div><div class="line">gdbserver :1234 --attach 7967   // 1234 为端口，可随意指定；7967位 pid。</div></pre></td></tr></table></figure>
<p>在电脑端执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb forward tcp:1234 tcp:1234</div><div class="line">arm-linux-androideabi-gdb</div><div class="line">(gdb) target remote :1234</div></pre></td></tr></table></figure>
<p>此时调试算是已经开始了。</p>
<p><strong>扩展</strong>：</p>
<p>为了找到该 crackme 的 flag，我们可以接着执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) gcore</div></pre></td></tr></table></figure>
<p>等 gore dump 出内存后，在电脑端的当前目录下使用<code>strings</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strings core.7967 | grep 0CTF</div></pre></td></tr></table></figure>
<p>即可得到 flag ，省去了静态分析和动态调试的繁琐。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android NDK 在 r11 之后去掉了 toolchain 中的 gdb 工具，无奈下载了 r10 的 arm-linux-androideabi-gdb 和 gdbserver。
    
    </summary>
    
    
      <category term="debug" scheme="http://kiya.studio/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>翻译 - 多种特征检测 Frida</title>
    <link href="http://kiya.studio/2017/05/08/detect-frida/"/>
    <id>http://kiya.studio/2017/05/08/detect-frida/</id>
    <published>2017-05-08T09:10:02.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Frida 在逆向工程狮中很受欢迎，你基本可以在运行时访问到你能想到的任何东西，内存地址、native 函数、Java 实例对象等。在 OWASP 的移动测试指南里就提到了 Frida。<a id="more"></a>但是啊，每出来个好用的注入工具，都会有反注入、反反注入、反反反注入、反…注入。这篇文章要介绍的是 Android APP 检测 Frida 的方法。</p>
<h2 id="检查-Frida-的痕迹"><a href="#检查-Frida-的痕迹" class="headerlink" title="检查 Frida 的痕迹"></a>检查 Frida 的痕迹</h2><p>一种简易方法是检测 Frida 的运行痕迹，也适用于同类工具的检测，比如包文件、二进制文件、库文件、进程、临时文件等等。本例中针对的对象是 fridaserver，它通过 TCP 对外与 frida 通信，此时可以用 Java 遍历运行的进程列表从而检查 fridaserver 是否在运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public boolean checkRunningProcesses() &#123;</div><div class="line"></div><div class="line">  boolean returnValue = false;</div><div class="line"></div><div class="line">  // Get currently running application processes</div><div class="line">  List&lt;RunningServiceInfo&gt; list = manager.getRunningServices(300);</div><div class="line"></div><div class="line">  if(list != null)&#123;</div><div class="line">    String tempName;</div><div class="line">    for(int i=0;i&lt;list.size();++i)&#123;</div><div class="line">      tempName = list.get(i).process;</div><div class="line"></div><div class="line">      if(tempName.contains(&quot;fridaserver&quot;)) &#123;</div><div class="line">        returnValue = true;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return returnValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若 Frida 运行在默认配置时此法有效，若是遇到个笨拙的脚本小子，在第一步就能绊倒他。绕过也是相当简单，只需重命名 fridaserver，我们得找个更好的方法。</p>
<p>fridaserver 默认的 TCP 端口是 27047，可以检查这个端口是否开放。native 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">boolean is_frida_server_listening() &#123;</div><div class="line">    struct sockaddr_in sa;</div><div class="line"></div><div class="line">    memset(&amp;sa, 0, sizeof(sa));</div><div class="line">    sa.sin_family = AF_INET;</div><div class="line">    sa.sin_port = htons(27047);</div><div class="line">    inet_aton(&quot;127.0.0.1&quot;, &amp;(sa.sin_addr));</div><div class="line"></div><div class="line">    int sock = socket(AF_INET , SOCK_STREAM , 0);</div><div class="line"></div><div class="line">    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123;</div><div class="line">      /* Frida server detected. Do something… */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，这也得要求 fridaserver 是默认配置运行，命令行指定参数就可以改变它的监听端口，绕过也太不麻烦了。不过我们可以用’ nmap -sV’ 找到开放端口来改善这个方法。因为 fridaserver 使用 D-Bus 协议通信，我们为每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Mini-portscan to detect frida-server on any local port.</div><div class="line"> */</div><div class="line"></div><div class="line">for(i = 0 ; i &lt;= 65535 ; i++) &#123;</div><div class="line"></div><div class="line">    sock = socket(AF_INET , SOCK_STREAM , 0);</div><div class="line">    sa.sin_port = htons(i);</div><div class="line"></div><div class="line">    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123;</div><div class="line"></div><div class="line">        __android_log_print(ANDROID_LOG_VERBOSE, APPNAME,  &quot;FRIDA DETECTION [1]: Open Port: %d&quot;, i);</div><div class="line"></div><div class="line">        memset(res, 0 , 7);</div><div class="line"></div><div class="line">        // send a D-Bus AUTH message. Expected answer is “REJECT&quot;</div><div class="line"></div><div class="line">        send(sock, &quot;\x00&quot;, 1, NULL);</div><div class="line">        send(sock, &quot;AUTH\r\n&quot;, 6, NULL);</div><div class="line"></div><div class="line">        usleep(100);</div><div class="line"></div><div class="line">        if (ret = recv(sock, res, 6, MSG_DONTWAIT) != -1) &#123;</div><div class="line"></div><div class="line">            if (strcmp(res, &quot;REJECT&quot;) == 0) &#123;</div><div class="line">               /* Frida server detected. Do something… */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    close(sock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在好像有了个非常好用的方法了呢，但是还存在问题。Frida 提供不需要 fridaserver 运行的模式！怎么检测？！</p>
<p>Frida 的各个模式都是用来注入的，我们可以利用的点就是 frida 运行时映射到内存的库。最直接的是挨个检查加载的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">char line[512];</div><div class="line">FILE* fp;</div><div class="line"></div><div class="line">fp = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;);</div><div class="line"></div><div class="line">if (fp) &#123;</div><div class="line">    while (fgets(line, 512, fp)) &#123;</div><div class="line">        if (strstr(line, &quot;frida&quot;)) &#123;</div><div class="line">            /* Evil library is loaded. Do something… */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">       /* Error opening /proc/self/maps. If this happens, something is off. */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码检测名字含有“frida”的库，表明上有用，实际上：</p>
<ul>
<li><p>还记得为什么检测名字是“fridaserver”的方法为什么不可靠吧？这里也是一样，稍微改一下 frida 就能重命名代理库名。</p>
</li>
<li><p>这段代码依赖的是标准库的<code>fopen()</code>和<code>strstr()</code>函数，可笑的是，我们竟想用能被 frida 轻而易举就 hook 的函数来检测 frida ！</p>
</li>
</ul>
<p>问题1可以用经典的病毒扫描法解决，在内存中扫描 frida 的库特征 “gadgets”。我选择字符串 “LIBFRIDA”，它在所有 frida-gadget 和 frida-agent 的版本中都有出现。下面的代码扫描了在 <code>/proc/sel/maps</code> 里找到的所有的可执行段，为了简洁我放了部分代码，完整的在 <a href="https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/native-lib.cpp" target="_blank" rel="external">https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/native-lib.cpp</a> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static char keyword[] = &quot;LIBFRIDA&quot;;</div><div class="line">num_found = 0;</div><div class="line"></div><div class="line">int scan_executable_segments(char * map) &#123;</div><div class="line">    char buf[512];</div><div class="line">    unsigned long start, end;</div><div class="line"></div><div class="line">    sscanf(map, &quot;%lx-%lx %s&quot;, &amp;start, &amp;end, buf);</div><div class="line"></div><div class="line">    if (buf[2] == &apos;x&apos;) &#123;</div><div class="line">        return (find_mem_string(start, end, (char*)keyword, 8) == 1);</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void scan() &#123;</div><div class="line"></div><div class="line">    if ((fd = my_openat(AT_FDCWD, &quot;/proc/self/maps&quot;, O_RDONLY, 0)) &gt;= 0) &#123;</div><div class="line"></div><div class="line">    while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123;</div><div class="line">        if (scan_executable_segments(map) == 1) &#123;</div><div class="line">            num_found++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (num_found &gt; 1) &#123;</div><div class="line"></div><div class="line">        /* Frida Detected */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 <code>my_openat()</code> 等函数，它们并非平常的 libc 库函数，是自定义实现的，但是功能和 libc 中的一样，设置了系统调用的参数，执行了软中断。因为直接调用公共 API 并不可靠，这样不容易被 hook。完整的实现在 <a href="https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/syscall.S" target="_blank" rel="external">https://github.com/b-mueller/frida-detection-demo/blob/master/AntiFrida/app/src/main/cpp/syscall.S</a> 。下面是 my_openat 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &quot;bionic_asm.h&quot;</div><div class="line"></div><div class="line">.text</div><div class="line">    .globl my_openat</div><div class="line">    .type my_openat,function</div><div class="line">my_openat:</div><div class="line">    .cfi_startproc</div><div class="line">    mov ip, r7</div><div class="line">    .cfi_register r7, ip</div><div class="line">    ldr r7, =__NR_openat</div><div class="line">    swi #0</div><div class="line">    mov r7, ip</div><div class="line">    .cfi_restore r7</div><div class="line">    cmn r0, #(4095 + 1)</div><div class="line">    bxls lr</div><div class="line">    neg r0, r0</div><div class="line">    b __set_errno_internal</div><div class="line">    .cfi_endproc</div><div class="line"></div><div class="line">    .size my_openat, .-my_openat;</div></pre></td></tr></table></figure>
<p>到这里总算是有效的方法了，只用 frida 的话也不容易绕过，加了混淆更难。即使这样，依然有很多办法可以绕过，直接能想到的就是打补丁、hook 系统调用。但是记住，逆向工程永远胜利！</p>
<p>想要试验，可以在这里 <a href="https://github.com/b-mueller/frida-detection-demo/" target="_blank" rel="external">https://github.com/b-mueller/frida-detection-demo/</a> 下载 Android studio 工程。frida 注入时的运行结果如下：</p>
<p><img src="https://vp-web.s3.amazonaws.com/uploads/ckeditor/pictures/73/content_fridadetection.jpg" alt=""></p>
<hr>
<p>原文链接：<a href="http://www.vantagepoint.sg/blog/90-the-jiu-jitsu-of-detecting-frida" target="_blank" rel="external">http://www.vantagepoint.sg/blog/90-the-jiu-jitsu-of-detecting-frida</a></p>
<p>本文首发于<a href="http://bbs.pediy.com/thread-217482.htm" target="_blank" rel="external">看雪</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Frida 在逆向工程狮中很受欢迎，你基本可以在运行时访问到你能想到的任何东西，内存地址、native 函数、Java 实例对象等。在 OWASP 的移动测试指南里就提到了 Frida。
    
    </summary>
    
    
      <category term="translation" scheme="http://kiya.studio/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>翻译 - 用 VirtualBox 调试 macOS 内核</title>
    <link href="http://kiya.studio/2017/04/14/debug-macos-kernel/"/>
    <id>http://kiya.studio/2017/04/14/debug-macos-kernel/</id>
    <published>2017-04-14T06:57:51.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>重大更新</strong>：awalton 在 Hacker News 上的讨论中提到：VMWare 里可以设置 CPUID 标志来禁用 SMAP，只需要在 vmx 文件中加上cpuid.7.ebx = “———–0——————–”.<a id="more"></a></p>
<hr>
<p>上年，我给我的老 MBP 升级了2016年的 Skylake Intel 处理器。我在调试一个内核漏洞时，发现我的 VMWare 开启了“SMAP”(防止超级用户访问)机制。我找不到怎么关闭 SMAP，还好 VirtualBox 目前好像不支持 SMAP？</p>
<p>这篇文章会手把手教你如何用 VirtualBox 进行 macOS 内核的源码级调试。虽然这些步骤都是在 VirtualBox上进行的，但在 VMWare 上也是通用的，甚至更简单。</p>
<h1 id="安装-VirtualBox-和-Sierra"><a href="#安装-VirtualBox-和-Sierra" class="headerlink" title="安装 VirtualBox 和 Sierra"></a>安装 VirtualBox 和 Sierra</h1><p>如果你还没在 VirtualBox 上安装 macOS 镜像，你可以复用 VMWare 的 vmdk，也可以装个新的。重新安装系统需要 ISO 镜像，下面的命令可以将从<a href="https://itunes.apple.com/us/app/macos-sierra/id1127487414?ls=1&amp;mt=12" target="_blank" rel="external">Mac app store</a>下载的 Sierra 转成 ISO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ hdiutil attach /Applications/Install\ macOS\ Sierra.app/Contents/SharedSupport/InstallESD.dmg -noverify -nobrowse -mountpoint /Volumes/installesd</div><div class="line">$ hdiutil create -o /tmp/Sierra -size 8g -type SPARSE -layout SPUD -fs HFS+J</div><div class="line">$ hdiutil attach /tmp/Sierra.sparseimage -noverify -nobrowse -mountpoint /Volumes/install</div><div class="line">$ asr restore -source /Volumes/installesd/BaseSystem.dmg -target /Volumes/install -noprompt -noverify -erase</div><div class="line">$ rm /Volumes/OS\ X\ Base\ System/System/Installation/Packages</div><div class="line">$ cp -rp /Volumes/installesd/Packages /Volumes/OS\ X\ Base\ System/System/Installation/</div><div class="line">$ cp -rp /Volumes/installesd/BaseSystem.dmg /Volumes/OS\ X\ Base\ System/BaseSystem.dmg</div><div class="line">$ cp -rp /Volumes/installesd/BaseSystem.chunklist /Volumes/OS\ X\ Base\ System/BaseSystem.chunklist</div><div class="line">$ hdiutil detach /Volumes/installesd</div><div class="line">$ hdiutil detach /Volumes/OS\ X\ Base\ System/</div><div class="line">$ hdiutil resize -sectors min /tmp/Sierra.sparseimage</div><div class="line">$ hdiutil convert /tmp/Sierra.sparseimage -format UDTO -o /tmp/Sierra</div><div class="line">$ rm /tmp/Sierra.sparseimage</div><div class="line">$ mv /tmp/Sierra.cdr /tmp/Sierra.iso</div></pre></td></tr></table></figure>
<h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>如果你用了桥接，可以跳过这部分。</p>
<p>如果用的是 NAT，需要为 KDP 开启端口转发。点击“网络”，选择“高级” -&gt; “端口转发”，将 localhost 41139/UDP 转发到虚拟机的 41139/UDP，就能够访问到虚拟机的 41139 端口了。</p>
<h1 id="安装-XCode"><a href="#安装-XCode" class="headerlink" title="安装 XCode"></a>安装 XCode</h1><p>在你的主机上安装 XCode，通过 App store 安装最简单。 可以直接打开 XCode，也可以执行 <code>sudo xcodebuild -license accept</code> 接受 XCode license。</p>
<h1 id="安装内核调试组件-KDK"><a href="#安装内核调试组件-KDK" class="headerlink" title="安装内核调试组件(KDK)"></a>安装内核调试组件(KDK)</h1><p>根据我们要调试的 macOS 版本从 Apple 开发者中心安装 KDK ，这里我的是10.12 build 16A323.</p>
<p>KDK 的安装目录是<code>/Library/Developer/KDKs</code>，提供的内核版本、符号、内核扩展都有 RELEASE、DEVELOPMENT、DEBUG 三种版本。不同之处在于 DEVELOPMENT 和 DEBUG 版比 RELEASE 版多了些断言和错误检查，DEBUG 版的最丰富。</p>
<p>注意：被调试的系统不需要安装 KDK。</p>
<h1 id="修改-nvram-boot-args"><a href="#修改-nvram-boot-args" class="headerlink" title="修改 nvram boot-args"></a>修改 nvram boot-args</h1><p>为了能够调试虚拟机，需要设置虚拟机上 nvram 中的 debug 项。除了 debug 的值外其他值也能被我们所用。下面是一些因垂斯挺的选项：</p>
<ul>
<li>-v：以 verbose 模式启动系统。</li>
<li>kcsuffix：填写后缀以指定启动的内核。</li>
<li>pmuflags：貌似大家都推荐把这项值设为1。然而 Apple’s Kernel Programming Guide 已经明确指出管理电源的看门狗定时器“只在台式机、笔记本的 G4 版本和台式机的 G5 版本及之前有作用”，其他的看门狗定时器“只在 OS X Server 中启用”。所以，虽然设置了也不影响，但这个选项真没什么卵用。</li>
<li>debug：允许远程内核调试。 Apple docs 里有列出可用的标志。我常用的是<code>DB_LOG_PI_SCRN | DB_ARP | DB_NMI</code>。另外，<code>control + option + command + shift + escape</code> 可以触发不可屏蔽中断（NMI），继而引发调试器中断，超级方便。这对组合键跟 host key 的组合键冲突的时候用起来很难受，所以我把 host key 重新绑定成<code>command + right</code>了。</li>
</ul>
<h2 id="修改-nvram"><a href="#修改-nvram" class="headerlink" title="修改 nvram"></a>修改 nvram</h2><p>在 VMware 里，可用这样修改 nvram：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo nvram boot-args=&quot;-v debug=0x144&quot;</div></pre></td></tr></table></figure></p>
<p>在 virtualbox 里没那么简单，因为一重启修改的值就没了。还好从 virtualbox 手册的 3.13.2 看到了希望：</p>
<blockquote>
<p>不能在运行的虚拟机内部操作 EFI 变量了（如：在Mac OS X 虚拟机里运行 nvram 来设置“boot-args”不管用了）。不过，可以通过给虚拟机发送附加数据”VBoxInternal2/EfiBootArgs” 来设置“boot-args”。…</p>
</blockquote>
<p>因此，我们需要关闭虚拟机，在主机上运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ VBoxManage list vms # 列出下条命令使用的 UUID</div><div class="line">&quot;macOS 10.12.0&quot; &#123;9ad936f8-9360-44a6-ba3e-c4d92b4243e8&#125;</div><div class="line">$ VBoxManage setextradata 9ad936f8-9360-44a6-ba3e-c4d92b4243e8 VBoxInternal2/EfiBootArgs &quot;-v debug=0x144&quot;</div></pre></td></tr></table></figure></p>
<h1 id="交换内核"><a href="#交换内核" class="headerlink" title="交换内核"></a>交换内核</h1><p>前面我提到可以指定<code>kcsuffix</code>选项以调试不同版本的内核。内核文件在虚拟机的<code>/System/Library/Kernels</code>目录，然而这个目录受“系统完整性保护”机制保护（SIP）。所以要想使用 KDK 或者自己编译的内核，必须启动进入 recovery，把目标内核拷进<code>/System/Library/Kernels</code>目录，使 kextcache 失效，然后重新启动。</p>
<h2 id="启动进入-recovery"><a href="#启动进入-recovery" class="headerlink" title="启动进入 recovery"></a>启动进入 recovery</h2><p>在 VMware 里，<code>cmd + R</code>就能进入 recovery 模式。virtualbox 要多几步。</p>
<p>启动虚拟机时，按住<code>F12</code>，然后选择<code>Boot Manager -&gt; EFI Internal Shell</code>，就会看到 EFI Shell 的欢迎界面。输入命令进入 recovery：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS2:\com.apple.recovery.boot\boot.efi</div></pre></td></tr></table></figure></p>
<p>进入 recovery 的界面，打开终端，操作目标内核，并将 kextcache 设置为无效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># mv /path/to/kernels/kernel.development /System/Library/Kernels</div><div class="line"># kextcache -invalidate /Volumes/Macintosh\ HD</div><div class="line"># reboot</div></pre></td></tr></table></figure></p>
<p>如果需要禁用 SIP，在重启之前执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># csrutil disable</div><div class="line">Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.</div></pre></td></tr></table></figure></p>
<h1 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h1><p>下载要调试的版本的 XNU 源码。调试时，LLDB 会去 <code>/Library/Caches/com.apple.xbs/Sources/xnu/xnu-...</code>目录寻找内核源码，所以可以把下载的源码放这个目录，也可以建一个符号链接指向源码目录。还有个方法是 设置 LLDB 的<code>target.source-map</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lldb&gt; settings set target.source-map /Library/Caches/com.apple.xbs/Sources/xnu/xnu-3789.1.32 /Users/kedy/Downloads/xnu-3789.1.32</div></pre></td></tr></table></figure>
<p>早一些的 macOS 版本比如 Yosemite 就只能把源码放在 <code>/SourceCache/xnu/</code>里。</p>
<h1 id="安装-LLDB"><a href="#安装-LLDB" class="headerlink" title="安装 LLDB"></a>安装 LLDB</h1><p>终于到调试器了。下面会举例用的是 RELEASE 内核。</p>
<p>为了在 Sierra KDK 里用 XNU LLDB 宏，执行<code>pip install macholib</code>安装<code>macholib</code>模块。粘贴执行加载内核文件时提示我们要执行的命令。（如下）</p>
<p>触发 NMI 后（或者等待设置了<code>DB_HALT</code>的调试器暂停启动进程时），执行<code>kdp-remote &lt;ip&gt;</code>连接到调试进程（若使用的是 NAT 端口转发，ip 是 localhost）。（如下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">$ lldb /Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel</div><div class="line">(lldb) target create &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel&quot;</div><div class="line">warning: &apos;kernel&apos; contains a debug script. To run this script in this debug session:</div><div class="line"></div><div class="line">    command script import &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/kernel.py&quot;</div><div class="line"></div><div class="line">To run all discovered debug scripts in this session:</div><div class="line"></div><div class="line">    settings set target.load-script-from-symbol-file true</div><div class="line"></div><div class="line">Current executable set to &apos;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel&apos; (x86_64).</div><div class="line">(lldb) command script import &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/kernel.py&quot;</div><div class="line">Loading kernel debugging from /Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/kernel.py</div><div class="line">LLDB version lldb-370.0.40</div><div class="line">  Swift-3.1</div><div class="line">settings set target.process.python-os-plugin-path &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/lldbmacros/core/operating_system.py&quot;</div><div class="line">settings set target.trap-handler-names hndl_allintrs hndl_alltraps trap_from_kernel hndl_double_fault hndl_machine_check _fleh_prefabt _ExceptionVectorsBase _ExceptionVectorsTable _fleh_undef _fleh_dataabt _fleh_irq _fleh_decirq _fleh_fiq_generic _fleh_dec</div><div class="line">command script import &quot;/Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel.dSYM/Contents/Resources/DWARF/../Python/lldbmacros/xnu.py&quot;</div><div class="line">xnu debug macros loaded successfully. Run showlldbtypesummaries to enable type summaries.</div><div class="line"></div><div class="line"></div><div class="line">(lldb) kdp-remote 192.168.149.184</div><div class="line">Version: Darwin Kernel Version 15.2.0: Fri Nov 13 19:56:56 PST 2015; root:xnu-3248.20.55~2/RELEASE_X86_64; UUID=17EA3101-D2E4-31BF-BDA9-931F51049F93; stext=0xffffff8007a00000</div><div class="line">Kernel UUID: 17EA3101-D2E4-31BF-BDA9-931F51049F93</div><div class="line">Load Address: 0xffffff8007a00000</div><div class="line">Kernel slid 0x7800000 in memory.</div><div class="line">Loaded kernel file /Library/Developer/KDKs/KDK_10.11.2_15C50.kdk/System/Library/Kernels/kernel</div><div class="line">Target arch: x86_64</div><div class="line">Instantiating threads completely from saved state in memory.</div><div class="line">Loading 82 kext modules warning: Can&apos;t find binary/dSYM for com.apple.kec.corecrypto (491718F5-B509-31DC-92B5-6BAC95E3F494)</div><div class="line">.warning: Can&apos;t find binary/dSYM for com.apple.kec.pthread (0888BA0A-49EE-394A-AEB1-1E5C6838A1F2)</div><div class="line"></div><div class="line">(omitted...)</div><div class="line"></div><div class="line">. done.</div><div class="line">kernel was compiled with optimization - stepping may behave oddly; variables may not be available.</div><div class="line">Process 1 stopped</div><div class="line">* thread #2, name = &apos;0xffffff800db8b000&apos;, queue = &apos;0x0&apos;, stop reason = signal SIGSTOP</div><div class="line">    frame #0: 0xffffff8007bd655e kernel`Debugger(message=&lt;unavailable&gt;) at model_dep.c:1020 [opt]</div><div class="line">   1017</div><div class="line">   1018		doprnt_hide_pointers = old_doprnt_hide_pointers;</div><div class="line">   1019		__asm__(&quot;int3&quot;);</div><div class="line">-&gt; 1020		hw_atomic_sub(&amp;debug_mode, 1);</div><div class="line">   1021	&#125;</div><div class="line">   1022</div><div class="line">   1023	char *</div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>瞧，macOS 内核源码调试这就开始了！</p>
<hr>
<p>原文链接: <a href="https://klue.github.io/blog/2017/04/macos_kernel_debugging_vbox/" target="_blank" rel="external">Securing Browsers Through Isolation Versus Mitigation</a></p>
<p>本文首发于<a href="http://bbs.pediy.com/thread-217023.htm" target="_blank" rel="external">看雪</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;重大更新&lt;/strong&gt;：awalton 在 Hacker News 上的讨论中提到：VMWare 里可以设置 CPUID 标志来禁用 SMAP，只需要在 vmx 文件中加上cpuid.7.ebx = “———–0——————–”.
    
    </summary>
    
    
      <category term="translation" scheme="http://kiya.studio/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>翻译 - “隔离”与“缓解” - Chrome、Edge 在浏览器防护上的终极对决！</title>
    <link href="http://kiya.studio/2017/03/10/chromeVSie/"/>
    <id>http://kiya.studio/2017/03/10/chromeVSie/</id>
    <published>2017-03-10T08:30:07.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天微软发布了一篇关于“<a href="https://blogs.windows.com/msedgedev/2017/02/23/mitigating-arbitrary-native-code-execution/" target="_blank" rel="external">新旧隔离机制</a>”的文章[<em>译者注</em>:隔离任意 native 代码的执行]，我个人非常赞同他们给 Edge 整上这个机制，但外面有些个反应简直夸张的不真实。<a id="more"></a>来看看 Dan Guido 的 Twitter (对不住了 Dan ~😉):</p>
<blockquote>
<p>毫无争议, Edge 一跃超过 Chrome 成为了最安全的浏览器！ <a href="https://t.co/JeE08LHBBv" target="_blank" rel="external">https://t.co/JeE08LHBBv</a> ——<a href="https://twitter.com/dguido/status/834846901191204864" target="_blank" rel="external">@dguido</a></p>
</blockquote>
<p>在这件事上，我认为对比 Chrome 来反观微软这次的动作，弄清楚浏览器的世界里发生了什么更为重要。当然，作为 Chrome 安全的工程指导我可能会偏心。但是，我的工作要求我客观的评价各种安全机制从而指导我的团队的努力方向，所以理论上我要作出的结论还是挺“清白”的。</p>
<p><img src="http://bmob-cdn-1754.b0.upaiyun.com/2017/03/10/801c119140181489806cb2d2ed2d8216.jpeg" alt="EvsC"></p>
<h2 id="缓解远程代码执行-RCE"><a href="#缓解远程代码执行-RCE" class="headerlink" title="缓解远程代码执行(RCE)"></a>缓解远程代码执行(RCE)</h2><p>对于前端的远程代码执行，微软可是下了大功夫。它试图通过防止攻击者获得可靠的代码而打破漏洞利用的第一环，如果成功的话就可以完全阻止攻击者。但最后仍然会演变成猫捉老鼠的游戏，缓解虽然可以消耗攻击者更多精力，却不能从根本上阻止漏洞利用。</p>
<p>个人来说，我认为微软此次的着眼点仅仅是放在了 IE 和 Edge 最常受到的攻击类型上，“让数据说话”也的确不失为一种合逻辑的策略。这样的话就有一大堆新的 RCE 缓解技术，连同着其与 chrome 类似技术的对比，我在下面列了写值得注意的几项:</p>
<ul>
<li><p>内存回收<br>通过回收 DOM 对象、在 free 操作时作缓解，内存回收降低了可利用的 use-after-free 漏洞出现的可能性。这能与 Chrome 的 <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/WebKit/Source/platform/heap/BlinkGCAPIReference.md" target="_blank" rel="external">use of Oilpan</a> 类似，通过回收 DOM 对象、分块分配内存，采用不同的缓解措施，来对抗发生中的 use-after-free 利用。总的来说，内存回收只是 Chrome 在这块儿的一个小特点，相对来说 Chrome 没有那么多可利用的漏洞，这局打平。</p>
</li>
<li><p>执行流保护(CFG)</p>
</li>
</ul>
<p>CFG 提供完整的执行流表，在“预防直接执行非法路径”上作了增强，Edge 在内部代码和系统库都用了 CFG。而Chrome 只在系统 DLL 用了 CFG， 另一方面不是 Chrome 内部而是用在了 Clang/LLVM  工具链上，使得我们可以使用 Clang 的 CFI 检查，非常好地契合了 Chrome 的需求。CFI/CFG 是未经过实际检验的技术，未来还可能出现重大的弱点和设计缺陷，总的来说是 Edge 占了上风。</p>
<ul>
<li>JavaScript JIT 加强</li>
</ul>
<p>微软在“防止漏洞利用时利用 JIT ”方面做了很多工作，其中最创新的莫过于将 JIT 移出进程，不让沙盒中的进程直接创建可执行页面。攻击者必须完整编译 RCE 成 ROP 链，这可要费大工夫了。无可否认，虽然 v8 要推出 JavaScript 解释器（ignition）和 JIT 的替代品（turbofan），Chrome 的性能会大幅提升，但是 Chrome 当前的 JIT 缓解措施还是比微软弱。这方面 Edge 遥遥领先了 Chrome。</p>
<h2 id="安全隔离机制"><a href="#安全隔离机制" class="headerlink" title="安全隔离机制"></a>安全隔离机制</h2><p>微软在 RCE 缓解方面比 Chrome 投入更多，Chrome 更专注于在浏览网页时定义和加强持续可用的隔离边界。像微软一样，Chrome 也是受暴露的漏洞类型驱动的。然而，两家是有不同的理念和实施约束的，通过长期观察，我们发现隔离机制反而是更有效的策略，跨平台也更方便。</p>
<p>首先，从安全机制的长期有效性来看，我们在 Chrome 上发现，随着时间的推移，底层 OS 平台倾向于提升安全隔离原语。比如说 Linux 的衍生系统会使用 <a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="external">seccomp-bpf 机制</a>，修改系统调用表，Windows 系统会使用<a href="https://msdn.microsoft.com/en-us/library/bb625957.aspx" target="_blank" rel="external">integrity level(IL)</a>， 锁定 win32k 上的进程缓解策略。在安全隔离方面，我们现在有能力利用这些操作系统作出的安全上的改进。</p>
<p>说到可移植性，拿微软最近的 JIT 加强来说，它依赖于 Windows 10 上 Edge 的新特性，并且受限于微软的签名文件。现在这种 OS 限制已经不常见，工程师们也可以找到替代方法解决，但是考虑到这项功能涉及修改主架构，必须确定这对其他平台是否友好，或者解释说是安全上作了重大改进，然而这两种说法都不现实。</p>
<blockquote>
<p>比起 Edge， Chrome 的渲染器处在更强有力的沙箱保护中。</p>
</blockquote>
<p>Chrome 在创建更强的隔离原语（如 Chrome 的渲染器比 Edge 处在更强的沙箱保护中）和扩展其应用方面（如 GPU 沙盒、网络沙盒）做出了更大努力。</p>
<p>这方面我们的王牌是今年推出的<a href="https://www.chromium.org/developers/design-documents/site-isolation" target="_blank" rel="external">站点隔离项目</a>，站点隔离是数十年的工程成果，为 web 源加上限制，从而阻止渲染器沙盒 RCE 操作其他 web 源。这比现今其他任何浏览器的安全保证都更强壮有力。</p>
<h2 id="这篇文章的点在哪？"><a href="#这篇文章的点在哪？" class="headerlink" title="这篇文章的点在哪？"></a>这篇文章的点在哪？</h2><p>浏览器安全是个复杂的话题。所以我想为 Chrome 现在的决策作一些说明，以及为什么我认为这些决策仍然可以捍卫 Chrome 在各个平台作为最安全浏览器的地位（事实证明）。</p>
<p>现在问题是有一些现象把安全研究降低成简单地划划清单，或者是互相比较安全特征/CVE 的游戏，这些东西对评估真实的安全没一点用处。浏览器的架构是软件里最复杂的，背后的决策对我们也是不透明的。我确实认为我们做了正确的决定，优先解决着 Chrome 最要紧的问题。我承认如果我负责的是 Edge 的安全，我会针对不同的用户拿出不同的数据，最后做出个不一样的结论。</p>
<h2 id="以我们的共同点结束如何？"><a href="#以我们的共同点结束如何？" class="headerlink" title="以我们的共同点结束如何？"></a>以我们的共同点结束如何？</h2><p>微软的博客里关于 Edge 如何防止第三方代码注入这点非常有意思，这也是所有浏览器大头的点。第三方应用使用不当操作插入代码不仅会造成稳定性问题和性能问题，也妨害着浏览器安全。我一直说我们为什么一直不能在 Chrome 沙盒里启用 Lowbox Token（App 容器安全限制）和 CSRSS 限制，因为那时第三方的反病毒程序会造成 Chrome 崩溃。</p>
<p>很高兴看到微软利落的切入了 Edge，为阻止第三方注入开了先河。Chrome 和 Firefox 今年也准备部署类似的方案，在这一点上为了最好的帮助用户我们达成了结盟。</p>
<p><img src="http://bmob-cdn-1754.b0.upaiyun.com/2017/03/10/6ed3e9394075934e805505708887b01b.jpeg" alt=""></p>
<hr>
<p>原文链接: <a href="https://medium.com/@justin.schuh/securing-browsers-through-isolation-versus-mitigation-15f0baced2c2#.l2srshz32" target="_blank" rel="external">Securing Browsers Through Isolation Versus Mitigation</a></p>
<p>本文首发于<a href="http://bbs.pediy.com/thread-216267.htm" target="_blank" rel="external">看雪</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天微软发布了一篇关于“&lt;a href=&quot;https://blogs.windows.com/msedgedev/2017/02/23/mitigating-arbitrary-native-code-execution/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;新旧隔离机制&lt;/a&gt;”的文章[&lt;em&gt;译者注&lt;/em&gt;:隔离任意 native 代码的执行]，我个人非常赞同他们给 Edge 整上这个机制，但外面有些个反应简直夸张的不真实。
    
    </summary>
    
    
      <category term="translation" scheme="http://kiya.studio/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>编译 lua 5.3.3 源码</title>
    <link href="http://kiya.studio/2016/08/31/compile-lua-5-3-3/"/>
    <id>http://kiya.studio/2016/08/31/compile-lua-5-3-3/</id>
    <published>2016-08-31T14:57:56.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>lua 源码直接 <code>make platform</code> 编译没什么好说的，这里就说一下需要注意的地方。</p>
<a id="more"></a>
<h1 id="编译为so库"><a href="#编译为so库" class="headerlink" title="编译为so库"></a>编译为so库</h1><p>默认的编译只有 .a 库, so 库只能自己动手了.</p>
<h2 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h2><p>将根目录中的Makefile作如下修改:</p>
<p>将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TO_LIB= liblua.a</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TO_LIB= liblua.a liblua.so</div></pre></td></tr></table></figure></p>
<p>在src/Makefile中寻找合适的位置添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LUA_SO=liblua.so</div><div class="line"></div><div class="line">$(LUA_SO): $(CORE_O) $(LIB_O)</div><div class="line">    $(CC) -o $@ -shared $? -ldl -lm</div></pre></td></tr></table></figure></p>
<p>将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T) $(LUA_SO)</div></pre></td></tr></table></figure></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>编译完成后有两个主要的可执行文件<code>lua</code> 和 <code>luac</code> 和两个库 <code>liblua.a</code> 和 <code>liblua.so</code>.</p>
<p><code>lua</code> : 虚拟机，用来执行 lua 代码<br><code>luac</code> : 编译器，用来为 lua 代码做一些优化什么的 (并不是说脚本语言就不需要编译器了啊啊啊啊)<br><code>liblua.a</code> : 静态库<br><code>liblua.so</code> : 动态库</p>
<h1 id="为Android平台编译"><a href="#为Android平台编译" class="headerlink" title="为Android平台编译"></a>为Android平台编译</h1><p>新建 <code>liblua.mk</code> 和 <code>Android.mk</code>, 写入:</p>
<p><strong>liblua.mk</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">LIB_VERSION:=lua-5.3.3-src</div><div class="line">SRC_ROOT_PATH:= ../../$(LIB_VERSION)</div><div class="line"></div><div class="line">LOCAL_PATH:= $(call my-dir)</div><div class="line">include $(CLEAR_VARS)</div><div class="line"></div><div class="line">LOCAL_MODULE := liblua</div><div class="line">LOCAL_CFLAGS := -D&quot;lua_getlocaledecpoint() =&apos;.&apos;&quot; -DLUA_USE_C89</div><div class="line"></div><div class="line">LOCAL_SRC_FILES := \</div><div class="line"> $(SRC_ROOT_PATH)/src/lapi.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lauxlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lbaselib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lbitlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lcode.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lcorolib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lctype.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldblib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldebug.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldo.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ldump.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lfunc.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lgc.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/linit.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/liolib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/llex.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lmathlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lmem.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/loadlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lobject.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lopcodes.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/loslib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lparser.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lstate.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lstring.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lstrlib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ltable.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ltablib.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/ltm.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lua.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lundump.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lvm.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lzio.c \</div><div class="line"> $(SRC_ROOT_PATH)/src/lutf8lib.c\</div><div class="line"></div><div class="line">include $(BUILD_SHARED_LIBRARY)</div><div class="line">#include $(BUILD_STATIC_LIBRARY)</div><div class="line">#include $(BUILD_EXECUTABLE)</div></pre></td></tr></table></figure></p>
<p><strong>Android.mk</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH:= $(call my-dir)</div><div class="line">include $(LOCAL_PATH)/liblua.mk</div></pre></td></tr></table></figure></p>
<p>此时文件结构如图 (lua-5.5.5-src文件夹为下载的源码,其他是新建的):</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/30/1.png-styleOnlyWatermark" alt=""></p>
<p>进入<code>jni</code>文件夹执行<code>ndk-build</code>编译, 成功后的文件结构如图:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/30/2.png-styleOnlyWatermark" alt=""></p>
<h1 id="错误列表"><a href="#错误列表" class="headerlink" title="错误列表"></a>错误列表</h1><h2 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file not recognized: 不可识别的文件格式</div></pre></td></tr></table></figure>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make clean</div></pre></td></tr></table></figure></p>
<h2 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ld: lapi.o: relocation R_X86_64_32 against `luaO_nilobject_&apos; can not be used when making a shared object; recompile with -fPIC</div><div class="line">lapi.o: error adding symbols: 错误的值</div></pre></td></tr></table></figure>
<p>将src/Makefile文件中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) $(MYCFLAGS)</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) -fPIC $(MYCFLAGS)</div></pre></td></tr></table></figure></p>
<h2 id="错误3"><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: &apos;struct lconv&apos; has no member named &apos;decimal_point&apos;</div></pre></td></tr></table></figure>
<p>将<code>luaconf.h</code>中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define lua_getlocaledecpoint()		(localeconv()-&gt;decimal_point[0])</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define lua_getlocaledecpoint()		&apos;.&apos;</div></pre></td></tr></table></figure></p>
<p><strong>或者</strong> 在makefile加上选项 <code>-D&quot;lua_getlocaledecpoint() =&#39;.&#39;&quot;</code>. (完整makefile内容见上)</p>
<h2 id="错误4"><a href="#错误4" class="headerlink" title="错误4"></a>错误4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">undefined reference to &apos;log2&apos;</div></pre></td></tr></table></figure>
<p>在 <code>makefile</code> 加上选项 <code>-DLUA_USE_C89</code> . (完整makefile内容见上)</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lua 源码直接 &lt;code&gt;make platform&lt;/code&gt; 编译没什么好说的，这里就说一下需要注意的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="compile" scheme="http://kiya.studio/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 调试 smali 代码</title>
    <link href="http://kiya.studio/2016/08/07/use-studio-debug-smali/"/>
    <id>http://kiya.studio/2016/08/07/use-studio-debug-smali/</id>
    <published>2016-08-07T14:57:52.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 java 层逆向来说，动态调试可比打 log 方便多了 :p</p>
<a id="more"></a>
<p>开始之前先供出一个大神（此处献上膝盖），smali、baksmali、smalidea 全套都可以在这里 -&gt; <a href="https://bitbucket.org/JesusFreke/smali/downloads" target="_blank" rel="external">下载</a>，今天用到的是 smalidea 插件，目前版本是 0.03 .</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><ul>
<li><strong>File -&gt; Settings</strong> 点击 <strong>Plugins</strong> :</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/1.png-styleOnlyWatermark" alt=""></p>
<h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><ul>
<li>使用 baksmali 将 dex 文件反编译为 smali .</li>
<li><strong>File -&gt; New -&gt; Import Project…</strong>，选中反编译过的 smali 目录。</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/2.png-styleOnlyWatermark" alt=""></p>
<p>之后一路 next 即可。</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><ul>
<li>右键源代码根目录 <strong>Mark Directory As -&gt; Sources Root</strong> </li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/5.png-styleOnlyWatermark" alt=""></p>
<ul>
<li><strong>File -&gt; Project Structure…</strong> 设置 jdk</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/3.png-styleOnlyWatermark" alt=""></p>
<ul>
<li><strong>Run -&gt; Edit Configurations…</strong> 新建一个 remote，设置端口为8700，命名为 smali</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/7.png-styleOnlyWatermark" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/8.png-styleOnlyWatermark" alt=""></p>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><ul>
<li>确保选择的 app 是可调试的/修改过设备环境</li>
<li><p>安装 apk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb install xxx.apk</div></pre></td></tr></table></figure>
</li>
<li><p>启动 Android Device Monitor （开启调试端口用）</p>
</li>
<li><p>启动 app</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -D -n package_name/main_activity_name</div></pre></td></tr></table></figure>
</li>
<li><p>下好断点</p>
</li>
<li>开始 Debug</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/9.png-styleOnlyWatermark" alt=""></p>
<ul>
<li>断下</li>
</ul>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/07/6.png-styleOnlyWatermark" alt=""></p>
<hr>
<p>over~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 java 层逆向来说，动态调试可比打 log 方便多了 :p&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kiya.studio/categories/Android/"/>
    
    
      <category term="debug" scheme="http://kiya.studio/tags/debug/"/>
    
      <category term="smali" scheme="http://kiya.studio/tags/smali/"/>
    
  </entry>
  
  <entry>
    <title>如何重新编译 uiautomatorviewer</title>
    <link href="http://kiya.studio/2016/08/06/recompile-uiautomatorviewer/"/>
    <id>http://kiya.studio/2016/08/06/recompile-uiautomatorviewer/</id>
    <published>2016-08-06T15:38:16.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用uiautomatorviewer时可能会想用到其本身没有的功能，或者想修改一下它的逻辑，这时候就需要重新编译一个jar包了。</p>
<a id="more"></a>
<p>好在Android是开源的，所以不用反编译原来的jar包直接下载源代码就可以了，我是在这里clone了一份 -&gt; <a href="https://github.com/android-ia/platform_tools_swt" target="_blank" rel="external">链接</a> ~ 当然只需要用到其中的<a href="https://github.com/android-ia/platform_tools_swt/tree/master/uiautomatorviewer" target="_blank" rel="external">uiautomatorviewer</a>这一个源码文件夹就够了。</p>
<p>因为google使用eclipse rcp来开发这些个工具的，所以我们需要使用eclipse建立e4项目。</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/1.png-styleOnlyWatermark" alt=""></p>
<p>建立的过程中一直next就好。</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/2.png-styleOnlyWatermark" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/3.png-styleOnlyWatermark" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/4.png-styleOnlyWatermark" alt=""></p>
<p>将uiautomatorviewer的源码中src/main/java文件夹下的 <strong>com 和 image</strong> 文件夹复制到工程中的src中，下载 <strong>ddmlib.jar</strong> 和 <strong>common.jar</strong> 复制到 libs 文件夹下(没有就创建一个)，再将这两个 jar 包右键 <strong>“Build Path” -&gt; “Add to Build Path”</strong>。<br>附上 <a href="http://www.java2s.com/Code/JarDownload/ddmlib/ddmlib-22.2.0.jar.zip" target="_blank" rel="external">ddmlib.jar</a> 和 <a href="http://www.java2s.com/Code/JarDownload/common/common.jar.zip" target="_blank" rel="external">common.jar</a> 的下载地址。<br>这是完成的项目目录：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/5.png-styleOnlyWatermark" alt=""></p>
<p>根据自己的需求修改过代码后，在项目根节点右键 <strong>“export…”</strong>，选择 <strong>“JAR file”</strong>:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/6.png-styleOnlyWatermark" alt=""></p>
<p>选择导出要包括的项目文件，只选 <strong>src</strong> 即可，并填入导出路径:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/7.png-styleOnlyWatermark" alt=""></p>
<p>一直next，在最后一步记得填入 <strong>Main class</strong>:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/2016/08/06/8.png-styleOnlyWatermark" alt=""></p>
<p><strong>finish</strong> 之后即可在导出路径下看到jar文件，替换掉sdk tools中的uiautomatorviewer.jar就可以使用我们自定义的工具了~</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用uiautomatorviewer时可能会想用到其本身没有的功能，或者想修改一下它的逻辑，这时候就需要重新编译一个jar包了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kiya.studio/categories/Android/"/>
    
    
      <category term="compile" scheme="http://kiya.studio/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title>升级站长秘籍：使用flarum框架搭建一个有逼格的轻论坛</title>
    <link href="http://kiya.studio/2016/04/14/install-flarum/"/>
    <id>http://kiya.studio/2016/04/14/install-flarum/</id>
    <published>2016-04-14T12:59:34.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来个成品图观赏观赏：</p>
<a id="more"></a>
<p>手机版：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/21/10/30-style1" alt=""></p>
<p>电脑版：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/21/05/53-style1" alt=""></p>
<hr>
<p>我的环境：ubuntu 14.06 x64 VPS</p>
<h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><p>依次安装 apache2、php5、mysql-server、php5-mysql .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install apache2</div><div class="line">sudo apt-get install php5</div><div class="line">sudo apt-get install mysql-server</div><div class="line">sudo apt-get install php5-mysql</div></pre></td></tr></table></figure>
<p>安装composer.(这一步直接在官网下载可执行文件加上可执行权限复制到/usr/local/bin中就行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">php -r &quot;readfile(&apos;https://getcomposer.org/installer&apos;);&quot; &gt; composer-setup.php</div><div class="line">php -r &quot;if (hash(&apos;SHA384&apos;, file_get_contents(&apos;composer-setup.php&apos;)) === &apos;7228c001f88bee97506740ef0888240bd8a760b046ee16db8f4095c0d8d525f2367663f22a46b48d072c816e7fe19959&apos;) &#123; echo &apos;Installer verified&apos;; &#125; else &#123; echo &apos;Installer corrupt&apos;; unlink(&apos;composer-setup.php&apos;); &#125; echo PHP_EOL;&quot;</div><div class="line">php composer-setup.php --install-dir=bin --filename=composer</div><div class="line">php -r &quot;unlink(&apos;composer-setup.php&apos;);&quot;</div></pre></td></tr></table></figure>
<h1 id="创建flarum工程"><a href="#创建flarum工程" class="headerlink" title="创建flarum工程"></a>创建flarum工程</h1><p>一定要在空目录里执行create-object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir V2NB_forum</div><div class="line">cd V2NB_forum/</div><div class="line">composer create-project flarum/flarum . --stability=beta</div></pre></td></tr></table></figure>
<p>安装过程中可能会出现错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Installing flarum/flarum (v0.1.0-beta.5)</div><div class="line">  - Installing flarum/flarum (v0.1.0-beta.5)</div><div class="line">    Downloading: 100%         </div><div class="line"></div><div class="line">Created project in .</div><div class="line">Loading composer repositories with package information</div><div class="line">Updating dependencies (including require-dev)</div><div class="line">Your requirements could not be resolved to an installable set of packages.</div><div class="line"></div><div class="line">  Problem 1</div><div class="line">    - flarum/flarum-ext-akismet v0.1.0-beta.3 requires tijsverkoyen/akismet ^1.1 -&gt; satisfiable by tijsverkoyen/akismet[1.1.0].</div><div class="line">    - flarum/flarum-ext-akismet v0.1.0-beta.5 requires tijsverkoyen/akismet ^1.1 -&gt; satisfiable by tijsverkoyen/akismet[1.1.0].</div><div class="line">    - tijsverkoyen/akismet 1.1.0 requires ext-curl * -&gt; the requested PHP extension curl is missing from your system.</div><div class="line">    - Installation request for flarum/flarum-ext-akismet ^0.1.0 -&gt; satisfiable by flarum/flarum-ext-akismet[v0.1.0-beta.3, v0.1.0-beta.5].</div><div class="line"></div><div class="line">  To enable extensions, verify that they are enabled in those .ini files:</div><div class="line">    - /etc/php5/cli/php.ini</div><div class="line">    - /etc/php5/cli/conf.d/05-opcache.ini</div><div class="line">    - /etc/php5/cli/conf.d/10-pdo.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-json.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-mysql.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-mysqli.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-pdo_mysql.ini</div><div class="line">    - /etc/php5/cli/conf.d/20-readline.ini</div><div class="line">  You can also run `php --ini` inside terminal to see which files are used by PHP in CLI mode.</div></pre></td></tr></table></figure>
<p>这时需要安装php-curl后，删除目录中的所有文件(包括.开头的隐藏文件)再执行<code>composer create-project flarum/flarum . --stability=beta</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install php5-curl</div></pre></td></tr></table></figure>
<p>正常的安装日志应该好长好长。</p>
<p>这时工程目录中的文件如下：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/21/35/27-style1" alt=""></p>
<h1 id="一些修改和设置"><a href="#一些修改和设置" class="headerlink" title="一些修改和设置"></a>一些修改和设置</h1><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>将工程目录全部文件和文件夹的权限修改为777.<br>如我的是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod -R 777 /home/kiya/v2nb</div></pre></td></tr></table></figure>
<h2 id="开启rewrite"><a href="#开启rewrite" class="headerlink" title="开启rewrite"></a>开启rewrite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /etc/apache2/mods-enabled</div><div class="line">sudo ln -s ../mods-available/rewrite.load</div></pre></td></tr></table></figure>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>修改<code>/etc/apache2/sites-available/000-default.conf</code>文件中的DocumentRoot项为你的项目文件夹路径. 如<code>DocumentRoot /home/kiya/v2nb</code>.<br>并在该文件中的<code>VirtualHost</code>节点之间添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Directory /home/kiya/V2NB&gt;</div><div class="line">    AllowOverride All</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<p>在<code>/etc/apache2/apache2.conf</code>文件中找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Directory /&gt;</div><div class="line">        Options FollowSymLinks</div><div class="line">        AllowOverride None</div><div class="line">        Require all denied</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<p>将<code>Require all denied</code>改为<code>Require all granted</code>,将<code>AllowOverride None</code>改为<code>AllowOverride All</code>.</p>
<h2 id="修改host"><a href="#修改host" class="headerlink" title="修改host"></a>修改host</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/hosts</div></pre></td></tr></table></figure>
<p>打开hosts新增加一行<code>23.105.197.243 v2nb.today</code>. 这里的ip是vps的ip，域名随便写. 本机的话可以ip可以写成<code>127.0.0.1</code>.<br>如果这里不加在启动apache服务时会警告:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AH00558: apache2: Could not reliably determine the server&apos;s fully qualified domain name, using v2nb.today. Set the &apos;ServerName&apos; directive globally to suppress this message</div></pre></td></tr></table></figure>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>命令行创建一个论坛用的数据库,user和pass时安装mysql时填写的账号密码. 待会要用到.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql -u user -p</div><div class="line">pass</div><div class="line">create database v2nb;</div></pre></td></tr></table></figure>
<h1 id="安装flarum"><a href="#安装flarum" class="headerlink" title="安装flarum"></a>安装flarum</h1><p>重启apache服务.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure>
<p>用浏览器访问<code>23.105.197.243</code>. 如果是本地测试则访问<code>localhost</code>.</p>
<p>如果出现的是：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/23/39/41-style1" alt=""></p>
<p>则需要安装<code>gd</code>模块,执行<code>sudo apt-get install php5-gd</code>重启apache即可.</p>
<p>正确的话会出现下图页面用以填写信息：</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/23/43/21-style1" alt=""></p>
<p>其中的<code>MySQL Database</code>是上面我们自己创建的数据库名字. 填好之后点击<code>Install Flarum</code>.</p>
<p>出现下图就安装好啦~</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/14/23/47/54-style1" alt=""></p>
<p>管理员界面:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/04/15/00/11/45-style1" alt=""></p>
<h1 id="访问oops"><a href="#访问oops" class="headerlink" title="访问oops"></a>访问oops</h1><p>在使用域名打开论坛时如果经常出现<code>Oops! Something went wrong. Please reload the page and try again</code>并且资源也加载不出,可能是说明请求的url和配置的url不一样.<br>需要修改工程目录下的<code>config.php</code>文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim config.php</div></pre></td></tr></table></figure>
<p>如将<code>&#39;url&#39; =&gt; &#39;23.105.197.243&#39;</code>改为<code>&#39;url&#39; =&gt; &#39;v2nb.today&#39;</code>.</p>
<h1 id="enjoy"><a href="#enjoy" class="headerlink" title="enjoy !"></a>enjoy !</h1><p>累煞我也.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来个成品图观赏观赏：&lt;/p&gt;
    
    </summary>
    
      <category term="flarum" scheme="http://kiya.studio/categories/flarum/"/>
    
    
      <category term="instruction" scheme="http://kiya.studio/tags/instruction/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu启动ida报错找不到libgthread-2.0.so.0</title>
    <link href="http://kiya.studio/2016/03/20/install-ia32-libs/"/>
    <id>http://kiya.studio/2016/03/20/install-ia32-libs/</id>
    <published>2016-03-20T08:32:52.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>换了电脑新装了ubuntu 15.04 64位，启动ida时报错“Error while loading shared libraries: libgthread-2.0.so.0”。<br>这是因为ida需要32位的库而我的系统是64位的，所以要安装32位的库。</p>
<a id="more"></a>
<p>说缺少libgthread-2.0.so.0那我就先安装libgthread-2.0.so.0呗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dpkg -S libgthread-2.0.so.0</div><div class="line">sudo apt-get install libglib2.0-0:i386</div></pre></td></tr></table></figure>
<p>完了启动ida又提示缺少另一个，再安又提示..<br>得了，直接把32位的库都安了吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install ia32-libs</div></pre></td></tr></table></figure>
<p>然而并没有成功，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">正在读取软件包列表...完成</div><div class="line">正在分析软件包的依赖关系树</div><div class="line">正在读取状态信息...完成</div><div class="line">现在没有可用的软件包 ia32-libs，但是它被其它的软件包引用了。</div><div class="line">这可能意味着这个缺失的软件包可能已经被废弃，</div><div class="line">或者只能在其他发布源中找到</div><div class="line">....</div></pre></td></tr></table></figure>
<p>最终：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dpkg --print-architecture</div><div class="line">dpkg --add-architecture i386</div><div class="line">apt-get update</div><div class="line">apt-get install iceweasel:i386</div></pre></td></tr></table></figure>
<p><strong>Reference</strong></p>
<p><a href="http://blog.tshine.me/ubuntu14-04-64%E4%BD%8D-%E5%AE%89%E8%A3%85-ia32-libs%E5%BA%93.html" target="_blank" rel="external">ubuntu14.04 64位 安装 ia32-libs库</a></p>
<p><a href="http://askubuntu.com/questions/427496/error-while-loading-shared-libraries-libgthread-2-0-so-0" target="_blank" rel="external">Error while loading shared libraries: libgthread-2.0.so.0</a></p>
<p><a href="http://blog.csdn.net/u011500307/article/details/11933739" target="_blank" rel="external">64位Ubuntu系统安装32位兼容库</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;换了电脑新装了ubuntu 15.04 64位，启动ida时报错“Error while loading shared libraries: libgthread-2.0.so.0”。&lt;br&gt;这是因为ida需要32位的库而我的系统是64位的，所以要安装32位的库。&lt;/p&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="http://kiya.studio/categories/Ubuntu/"/>
    
    
      <category term="ida" scheme="http://kiya.studio/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>某加固中的反调试</title>
    <link href="http://kiya.studio/2016/01/12/anti-debug-in-jiagubao/"/>
    <id>http://kiya.studio/2016/01/12/anti-debug-in-jiagubao/</id>
    <published>2016-01-12T02:23:31.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>以某厨房为例.</p>
<a id="more"></a>
<h1 id="反调试函数"><a href="#反调试函数" class="headerlink" title="反调试函数"></a>反调试函数</h1><p>（jiagu.so基址5287d000）</p>
<p>在library load/unload断下,在mmap函数尾部下断点,断下后f8执行几句,可找到<code>libjiagu.so:528855E4 BL      loc_5288308C</code>,进入反调试.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/12/35/50" alt=""></p>
<p>往下执行的关键跳转有<br><strong>libjiagu.so:528830D0 BLX     LR     ; debug079:5287C000</strong><br><strong>debug079:5287C014 BLX     LR         ; loc_5288042C</strong><br><strong>debug079:5287C038 BLX     LR ; loc_52880614</strong></p>
<p><code>5287C000</code>是一个反调试模块的起始.</p>
<p><code>libjiagu.so:loc_5288042C</code>函数作用是打开status文件获得TracerPid,此函数地址不变 其中的 <strong>libjiagu.so:52880528 BL      open_0</strong> 是调用<code>open</code>打开<code>/proc/self/status</code>的.</p>
<p><code>loc_52880614</code>是第二种反调试.</p>
<hr>
<h1 id="具体的反调试过程"><a href="#具体的反调试过程" class="headerlink" title="具体的反调试过程"></a>具体的反调试过程</h1><h2 id="解析status文件"><a href="#解析status文件" class="headerlink" title="解析status文件"></a>解析status文件</h2><h3 id="找出-TracerPid"><a href="#找出-TracerPid" class="headerlink" title="找出 TracerPid"></a>找出 TracerPid</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/33/10-style1" alt=""></p>
<h3 id="转换-TracerPid"><a href="#转换-TracerPid" class="headerlink" title="转换 TracerPid"></a>转换 TracerPid</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/19/37/38-style1" alt=""></p>
<h3 id="比较-TracerPid"><a href="#比较-TracerPid" class="headerlink" title="比较 TracerPid"></a>比较 TracerPid</h3><p>如果<code>TracerPid</code>不为0,kill!</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/34/28-style1" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/34/47-style1" alt=""></p>
<h2 id="解析-proc-net-tcp文件"><a href="#解析-proc-net-tcp文件" class="headerlink" title="解析/proc/net/tcp文件"></a>解析/proc/net/tcp文件</h2><p>在比较过<code>tracerid</code>后,接着又解析了<code>tcp</code>文件.</p>
<h3 id="调用处"><a href="#调用处" class="headerlink" title="调用处"></a>调用处</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/35/12-style1" alt=""></p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/35/33-style1" alt=""></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2016/01/12/15/35/49-style1" alt=""></p>
<p>逐行比较是否含有<code>00000000:5D8A</code>,5d8a就是23946,<code>android_server</code>监听端口即为23946,0A状态表示监听.<br>这里r0会被赋为1，返回调用处时进程就会被kill.</p>
<p>如本机tcp文件中的内容为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode                                                     </div><div class="line"> 0: 00000000:5D8A 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 42138 1 00000000 100 0 0 10 -1                            </div><div class="line"> 1: 00000000:15B3 00000000:0000 0A 00000000:00000000 00:00000000 00000000  2000        0 20426 1 00000000 100 0 0 10 -1                            </div><div class="line"> 2: 0100007F:91AF 0100007F:5D8A 01 00000000:00000000 00:00000000 00000000  2000        0 43283 1 00000000 21 4 2 10 -1                             </div><div class="line"> 3: ED01A8C0:15B3 EE01A8C0:E1B6 01 00000018:00000000 01:00000018 00000000  2000        0 20427 2 00000000 24 4 28 8 6                              </div><div class="line"> 4: 0100007F:5D8A 0100007F:91AF 01 00000000:00000000 02:00083C35 00000000     0        0 42634 2 00000000 22 4 3 10 -1</div></pre></td></tr></table></figure>
<hr>
<h1 id="绕过反调试"><a href="#绕过反调试" class="headerlink" title="绕过反调试"></a>绕过反调试</h1><p>关键断点是:<code>libjiagu.so:loc_5288042C</code>,返回之后就是cmp.<br>第二种反调试<code>libjiagu.so:52880614</code>在cmp下面(若有).</p>
<p>断下之后在lr对应的地址下断点,f9，将两个反调试函数下面的比较的r0值修改就可以了.</p>
<hr>
<h1 id="反调试的patch"><a href="#反调试的patch" class="headerlink" title="反调试的patch"></a>反调试的patch</h1><p>但是不止一次反调试,每次的地址也不同,而且每个采用这种加固的app都要如此,这样也太不划算了吧.既然如此,为什么不patch一下呢?</p>
<p>将<code>libjiagu.so</code>作如下修改即可去掉反调试:(返回值r0改为0,mov r0,#0)<br>文件偏移<code>35EC</code>处 -&gt; <code>04 00 A0 E1</code>改为<code>00 00 A0 E3</code><br>文件偏移<code>3720</code>处 -&gt; <code>01 00 A0 E3</code>改为<code>00 00 A0 E3</code></p>
<hr>
<p>本文小白鼠: <a href="https://github.com/kiya-z/Android/blob/master/lab-mouse/com.xiachufang_138.apk" target="_blank" rel="external">here</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.52pojie.cn/thread-435746-1-1.html" target="_blank" rel="external">xxx加固 之 动态脱壳</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以某厨房为例.&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
      <category term="某加固" scheme="http://kiya.studio/categories/Android-Security/%E6%9F%90%E5%8A%A0%E5%9B%BA/"/>
    
    
      <category term="anti-debug" scheme="http://kiya.studio/tags/anti-debug/"/>
    
      <category term="enforce" scheme="http://kiya.studio/tags/enforce/"/>
    
  </entry>
  
  <entry>
    <title>第一个xposed模块中的“Class ref in pre-verified class resolved to unexpected implementation”错误原因</title>
    <link href="http://kiya.studio/2016/01/03/xposed-class-ispreverified/"/>
    <id>http://kiya.studio/2016/01/03/xposed-class-ispreverified/</id>
    <published>2016-01-03T14:43:53.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我的<a href="http://kiya.space/2015/12/28/hello-xposed/" target="_blank" rel="external">第一个 Xposed 模块</a>中曾出现<code>Class ref in pre-verified class resolved to unexpected implementation</code>错误,Xposed log如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">01-03 19:42:03.974 134-134/? I/Xposed: Loading modules from /data/app/space.kiya.xposedtest-1.apk</div><div class="line">01-03 19:42:04.285 134-134/? I/Xposed:   Loading class space.kiya.xposedtest.ChangeStatusBar</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed: java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.DexFile.defineClass(Native Method)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.DexFile.loadClassBinaryName(DexFile.java:211)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.DexPathList.findClass(DexPathList.java:313)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:51)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at java.lang.ClassLoader.loadClass(ClassLoader.java:501)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at java.lang.ClassLoader.loadClass(ClassLoader.java:461)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at de.robv.android.xposed.XposedBridge.loadModule(XposedBridge.java:421)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at de.robv.android.xposed.XposedBridge.loadModules(XposedBridge.java:386)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:120)</div><div class="line">01-03 19:42:04.298 134-134/? I/Xposed:     at dalvik.system.NativeStart.main(Native Method)</div></pre></td></tr></table></figure>
<p>从中可以看到,因为XposedBridge的main函数调用了loadModules,而loadModules又调用了loadModule,loadModule调用loadClass,这样一层一层下去最终导致了现在的错误.<br>我们就从案发现场<code>loadclass</code>和错误信息<code>Class ref in pre-verified class resolved to unexpected implementation</code>入手吧！</p>
<h1 id="案发现场-loadclass"><a href="#案发现场-loadclass" class="headerlink" title="案发现场 loadclass"></a>案发现场 loadclass</h1><p>把<a href="https://github.com/rovo89/XposedBridge" target="_blank" rel="external">XposedBridge的代码</a>clone下来,找到<code>de/robv/android/xposed/XposedBridge</code>文件.</p>
<p>我们知道<code>Xposed Installer</code>的界面有一个模块列表,在写Xposed模块时也需要新建文件<code>xposed_init</code>写入实现了Xposed接口的类名.</p>
<p>main函数的作用就是初始化Xposed框架和模块,模块是怎么初始化的呢?来看loadModules函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Try to load all modules defined in &lt;code&gt;BASE_DIR/conf/modules.list&lt;/code&gt;</div><div class="line"> */</div><div class="line">private static void loadModules() throws IOException &#123;</div><div class="line">	final String filename = BASE_DIR + &quot;conf/modules.list&quot;;</div><div class="line">	BaseService service = SELinuxHelper.getAppDataFileService();</div><div class="line">	if (!service.checkFileExists(filename)) &#123;</div><div class="line">		Log.e(TAG, &quot;Cannot load any modules because &quot; + filename + &quot; was not found&quot;);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	InputStream stream = service.getFileInputStream(filename);</div><div class="line">	BufferedReader apks = new BufferedReader(new InputStreamReader(stream));</div><div class="line">	String apk;</div><div class="line">	while ((apk = apks.readLine()) != null) &#123;</div><div class="line">		loadModule(apk);</div><div class="line">	&#125;</div><div class="line">	apks.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Xposed Installer</code>的安装目录<code>/data/data/de.robv.android.xposed.installer</code>下的<code>conf</code>文件夹下有一个<code>modules.list</code>文件,记录着每个xposed模块的apk的路径.<br><code>loadModules</code>对每行(一行对应一个apk路径)调用<code>loadModule</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Load a module from an APK by calling the init(String) method for all classes defined</div><div class="line"> * in &lt;code&gt;assets/xposed_init&lt;/code&gt;.</div><div class="line"> */</div><div class="line">@SuppressWarnings(&quot;deprecation&quot;)</div><div class="line">private static void loadModule(String apk) &#123;</div><div class="line">	log(&quot;Loading modules from &quot; + apk);</div><div class="line"></div><div class="line">	if (!new File(apk).exists()) &#123;</div><div class="line">		log(&quot;  File does not exist&quot;);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ClassLoader mcl = new PathClassLoader(apk, BOOTCLASSLOADER);</div><div class="line">	InputStream is = mcl.getResourceAsStream(&quot;assets/xposed_init&quot;);</div><div class="line">	if (is == null) &#123;</div><div class="line">		log(&quot;assets/xposed_init not found in the APK&quot;);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	BufferedReader moduleClassesReader = new BufferedReader(new InputStreamReader(is));</div><div class="line">	try &#123;</div><div class="line">		String moduleClassName;</div><div class="line">		while ((moduleClassName = moduleClassesReader.readLine()) != null) &#123;</div><div class="line">			moduleClassName = moduleClassName.trim();</div><div class="line">			if (moduleClassName.isEmpty() || moduleClassName.startsWith(&quot;#&quot;))</div><div class="line">				continue;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				log (&quot;  Loading class &quot; + moduleClassName);</div><div class="line">				Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</div><div class="line"></div><div class="line">				if (!IXposedMod.class.isAssignableFrom(moduleClass)) &#123;</div><div class="line">					log (&quot;    This class doesn&apos;t implement any sub-interface of IXposedMod, skipping it&quot;);</div><div class="line">					continue;</div><div class="line">				&#125; else if (disableResources &amp;&amp; IXposedHookInitPackageResources.class.isAssignableFrom(moduleClass)) &#123;</div><div class="line">					log (&quot;    This class requires resource-related hooks (which are disabled), skipping it.&quot;);</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				final Object moduleInstance = moduleClass.newInstance();</div><div class="line">				if (isZygote) &#123;</div><div class="line">					if (moduleInstance instanceof IXposedHookZygoteInit) &#123;</div><div class="line">						IXposedHookZygoteInit.StartupParam param = new IXposedHookZygoteInit.StartupParam();</div><div class="line">						param.modulePath = apk;</div><div class="line">						param.startsSystemServer = startsSystemServer;</div><div class="line">						((IXposedHookZygoteInit) moduleInstance).initZygote(param);</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					if (moduleInstance instanceof IXposedHookLoadPackage)</div><div class="line">						hookLoadPackage(new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance));</div><div class="line"></div><div class="line">					if (moduleInstance instanceof IXposedHookInitPackageResources)</div><div class="line">						hookInitPackageResources(new IXposedHookInitPackageResources.Wrapper((IXposedHookInitPackageResources) moduleInstance));</div><div class="line">				&#125; else &#123;</div><div class="line">					if (moduleInstance instanceof IXposedHookCmdInit) &#123;</div><div class="line">						IXposedHookCmdInit.StartupParam param = new IXposedHookCmdInit.StartupParam();</div><div class="line">						param.modulePath = apk;</div><div class="line">						param.startClassName = startClassName;</div><div class="line">						((IXposedHookCmdInit) moduleInstance).initCmdApp(param);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; catch (Throwable t) &#123;</div><div class="line">				log(t);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; catch (IOException e) &#123;</div><div class="line">		log(e);</div><div class="line">	&#125; finally &#123;</div><div class="line">		try &#123;</div><div class="line">			is.close();</div><div class="line">		&#125; catch (IOException ignored) &#123;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loadModule</code>读取每个apk文件中的<code>assets/xposed_init</code>,使用<code>PathClassLoader</code>的<code>loadclass</code>方法加载每个注册的类,然后将类的实例作为相应xposed模块的回调.</p>
<p>那么<code>Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</code>这句代码是怎么会出错的呢?</p>
<h1 id="何方神圣-CLASS-ISPREVERIFIED"><a href="#何方神圣-CLASS-ISPREVERIFIED" class="headerlink" title="何方神圣 CLASS_ISPREVERIFIED"></a>何方神圣 CLASS_ISPREVERIFIED</h1><p><code>CLASS_ISPREVERIFIED</code>是虚拟机在对dex文件优化时的一个<code>ClassFlags</code>,表示某个类是否已经被预验证过.<br>也就是说当某个类中引用的方法全部来自所在的dex文件中时,这个类就会被打上这个标记.<br>若app有多个dex文件时,当引用了某个带有这个标记的类时,虚拟机不需要在全部的dex文件中查找,从而帮助提高dalvik虚拟机的性能.</p>
<p>关于如何验证的细节稍后分析.</p>
<p>我们写的<code>ChangeStatusBar</code>类实现了<code>IXposedHookLoadPackage</code>,同时jar包的引用方式为<code>compile</code>,所以也把XposedBridge.jar编译进dex了,因此在验证<code>ChangeStatusBar</code>类时在本dex中可以找到<code>IXposedHookLoadPackage</code>从而被标记了<code>CLASS_ISPREVERIFIED</code>.</p>
<p><strong>那么是在哪里检查是否有CLASS_ISPREVERIFIED标记的呢？</strong></p>
<p>源代码文件<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Resolve.cpp#119" target="_blank" rel="external">/dalvik/vm/oo/Resolve.cpp</a>的<code>dvmResolveClass</code>函数中:有这么一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (!fromUnverifiedConstant &amp;&amp; IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))</div><div class="line">&#123;</div><div class="line">    ClassObject* resClassCheck = resClass;</div><div class="line">    if (dvmIsArrayClass(resClassCheck))</div><div class="line">        resClassCheck = resClassCheck-&gt;elementClass;</div><div class="line"></div><div class="line">    if (referrer-&gt;pDvmDex != resClassCheck-&gt;pDvmDex &amp;&amp;</div><div class="line">        resClassCheck-&gt;classLoader != NULL)</div><div class="line">    &#123;</div><div class="line">        ALOGW(&quot;Class resolved by unexpected DEX:&quot;</div><div class="line">             &quot; %s(%p):%p ref [%s] %s(%p):%p&quot;,</div><div class="line">            referrer-&gt;descriptor, referrer-&gt;classLoader,</div><div class="line">            referrer-&gt;pDvmDex,</div><div class="line">            resClass-&gt;descriptor, resClassCheck-&gt;descriptor,</div><div class="line">            resClassCheck-&gt;classLoader, resClassCheck-&gt;pDvmDex);</div><div class="line">        ALOGW(&quot;(%s had used a different %s during pre-verification)&quot;,</div><div class="line">            referrer-&gt;descriptor, resClass-&gt;descriptor);</div><div class="line">        dvmThrowIllegalAccessError(</div><div class="line">            &quot;Class ref in pre-verified class resolved to unexpected &quot;</div><div class="line">            &quot;implementation&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当虚拟机找到需要引用的类时,如果引用者已经被预验证过,且引用者所在的dex和被引用者所在的dex不同时,抛出<code>Class ref in pre-verified class ...</code>异常!</p>
<p>而在我的<a href="http://kiya.space/2015/12/28/hello-xposed/" target="_blank" rel="external">第一个 Xposed 模块</a>出现错误时dalvik的log如下(经过剪切):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">01-04 20:11:03.463 134-134/? W/dalvikvm: Class resolved by unexpected DEX: Lspace/kiya/xposedtest/ChangeStatusBar;(0x40e59fc8):0x5028f000 ref [Lde/robv/android/xposed/IXposedHookLoadPackage;] Lde/robv/android/xposed/IXposedHookLoadPackage;(0x40da2fd0):0x4f2f8000</div><div class="line">01-04 20:14:06.184 134-134/? W/dalvikvm: (Lspace/kiya/xposedtest/ChangeStatusBar; had used a different Lde/robv/android/xposed/IXposedHookLoadPackage; during pre-verification)</div><div class="line"></div><div class="line">01-04 20:11:03.467 134-134/? W/dalvikvm: Class resolved by unexpected DEX: Lspace/kiya/xposedtest/GetQQPassword;(0x40e59fc8):0x5028f000 ref [Lde/robv/android/xposed/IXposedHookLoadPackage;] Lde/robv/android/xposed/IXposedHookLoadPackage;(0x40da2fd0):0x4f2f8000</div><div class="line">01-04 20:14:06.187 134-134/? W/dalvikvm: (Lspace/kiya/xposedtest/GetQQPassword; had used a different Lde/robv/android/xposed/IXposedHookLoadPackage; during pre-verification)</div></pre></td></tr></table></figure>
<p>这里可以看出在<code>loadclass</code>时的引用者是<code>Lspace/kiya/xposedtest/ChangeStatusBar</code>,被引用者是<code>Lde/robv/android/xposed/IXposedHookLoadPackage</code>.<br>(解析类的过程包括类的所有引用的检查,这里问题是出在模块类引用其他类时而非xposed加载模块类时,故引用者是被加载的模块类)</p>
<p>dalvik解析的时候发现<code>IXposedHookLoadPackage</code>和<code>ChangeStatusBar</code>不在一个dex文件内,但是<code>ChangeStatusBar</code>类已经被校验过了呀,里面所有的方法都在本dex内,现在又告诉我不在一起了,那肯定要报错了!</p>
<p>和上一小节的问题结合起来,必然是<code>loadclass</code>加载类的同时做了验证!是否是这样我们随后再验证.</p>
<p>现在的问题是明明<code>ChangeStatusBar</code>已经通过了校验,<code>IXposedHookLoadPackage</code>和<code>ChangeStatusBar</code>在同一个dex中,怎么加载时<code>IXposedHookLoadPackage</code>又不在这里了?</p>
<h1 id="罪魁祸首-PathClassLoader"><a href="#罪魁祸首-PathClassLoader" class="headerlink" title="罪魁祸首 PathClassLoader"></a>罪魁祸首 PathClassLoader</h1><p>这就要说说PathClassLoader了.</p>
<p><code>XposedBridge</code>源码中使用的类加载器就是PathClassLoader.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static final ClassLoader BOOTCLASSLOADER = ClassLoader.getSystemClassLoader();</div><div class="line">ClassLoader mcl = new PathClassLoader(apk, BOOTCLASSLOADER);</div></pre></td></tr></table></figure>
<p>其中apk是模块apk的路径;BOOTCLASSLOADER是系统类加载器的实例,从classpath中加载类.</p>
<blockquote>
<p>loadClass方法在加载一个类的实例的时候，<br>会先查询当前ClassLoader实例是否加载过此类，有就返回；<br>如果没有。查询Parent是否已经加载过此类，如果已经加载过，就直接返回Parent加载的类；<br>如果继承路线上的ClassLoader都没有加载，才由Child执行类的加载工作；</p>
</blockquote>
<p>也就是说我们的<code>apk</code>是最后一个被查找的路径.</p>
<p>而在<code>Xposed</code>源码中的<code>app_main.cpp</code>(被修改过的app_process)调用了<code>xposed::initialize(zygote, startSystemServer, className, argc, argv)</code>,<code>initialize</code>中又调用了<code>addJarToClasspath()</code>,功能就是将<code>XposedBridge.jar</code>添加到Java classpath!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#define XPOSED_JAR               &quot;/system/framework/XposedBridge.jar&quot;</div><div class="line">/** Add XposedBridge.jar to the Java classpath. */</div><div class="line">bool addJarToClasspath() &#123;</div><div class="line">    ALOGI(&quot;-----------------&quot;);</div><div class="line"></div><div class="line">    if (access(XPOSED_JAR, R_OK) == 0) &#123;</div><div class="line">        if (!addPathToEnv(&quot;CLASSPATH&quot;, XPOSED_JAR))</div><div class="line">            return false;</div><div class="line"></div><div class="line">        ALOGI(&quot;Added Xposed (%s) to CLASSPATH&quot;, XPOSED_JAR);</div><div class="line">        return true;</div><div class="line">    &#125; else &#123;</div><div class="line">        ALOGE(&quot;ERROR: Could not access Xposed jar &apos;%s&apos;&quot;, XPOSED_JAR);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以<code>loadclass</code>在检查<code>apk</code>路径之前系统类加载器就在系统类路径中的<code>XposedBridge.jar</code>中找到了<code>IXposedHookLoadPackage</code>,虽然我们的apk中也有这个函数,但是还没有等到加载就已经结束了.</p>
<p>到这里就可以理清错误为什么发生了:</p>
<ol>
<li>编写模块时我们把<code>XposedBridge.jar</code>编译进了dex文件中;</li>
<li>dalvik在优化dex时为模块类打上了<code>CLASS_ISPREVERIFIED</code>标记,表示没有引用的类全部来自本dex;</li>
<li>xposed框架修改后的app_process会在开机时将<code>/system/framework/XposedBridge.jar</code>加入类路径;</li>
<li>随后xposed要加载我们注册的模块类,在事先为其准备好的jar包中找到了引用的类;</li>
<li>但是模块类被打上标记了,xposed发现模块就没打算用自己准备好的类,反而要自给自足,这哪是框架和模块的关系!简直是造反!于是愤而报错.</li>
</ol>
<p>前面也提到解决方法就是不将<code>XposedBridge.jar</code>编译进dex即可,这样不会被打上标记,万事ok.<br>现在app的热修复原理也是这样.</p>
<h1 id="凌晨4点-startvm"><a href="#凌晨4点-startvm" class="headerlink" title="凌晨4点 startvm"></a>凌晨4点 startvm</h1><p>到了现在,如果不在意一些细节,本案已经被破!</p>
<p>之前说到,当类加载器调用<code>loadclass</code>加载类时发现<code>ChangeStatusBar</code>类已经被校验过…<br>等等!我们的XposedBridge加载模块类的代码是在app_process中呀,而校验是属于dexopt(dex优化)的步骤哇,难道dex优化比app_process这个启动代码还要早?</p>
<p>那么问题就清晰多了: <strong>app_process 和 dexopt 的关系</strong>.</p>
<p>一个app实质上就是一个app_process进程,app_process的作用如下:</p>
<ol>
<li>创建jvm</li>
<li>执行startClass的main方法</li>
</ol>
<p><code>app_main.cpp</code>中的部分添加代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define XPOSED_CLASS_DOTS_ZYGOTE &quot;de.robv.android.xposed.XposedBridge&quot;</div><div class="line">isXposedLoaded = xposed::initialize(zygote, startSystemServer, className, argc, argv);</div><div class="line">if (zygote) &#123;</div><div class="line">    runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : &quot;com.android.internal.os.ZygoteInit&quot;,</div><div class="line">            startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>initialize</code>在上面提到过,而<code>runtime.start</code>就是android源码<a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/jni/AndroidRuntime.cpp#805" target="_blank" rel="external">/frameworks/base/core/jni/AndroidRuntime.cpp</a>中的<code>AndroidRuntime::start</code>函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Start the Android runtime.  This involves starting the virtual machine</div><div class="line"> * and calling the &quot;static void main(String[] args)&quot; method in the class</div><div class="line"> * named by &quot;className&quot;.</div><div class="line"> *</div><div class="line"> * Passes the main function two arguments, the class name and the specified</div><div class="line"> * options string.</div><div class="line"> */</div><div class="line">void AndroidRuntime::start(const char* className, const char* options)</div></pre></td></tr></table></figure>
<p><strong>此函数主要功能是:</strong> 启动虚拟机,执行传入类的main函数<br><strong>流程:</strong> AndroidRuntime::start -&gt; startvm -&gt; 执行传入的类的main函数<br>本案中传入的类是<code>de.robv.android.xposed.XposedBridge</code>.</p>
<p>而startvm中又执行了什么呢?<br>startvm -&gt; JNI_CreateJavaVM -&gt; dvmStartup -&gt; dvmClassStartup -&gt; … -&gt; 直到优化dex时验证class</p>
<p>====&gt; 因此当XposedBridge的main函数执行时,dex中的各个类已经被verify过了.我们的猜想是对哩.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://bugly.qq.com/blog/?p=781" target="_blank" rel="external">【新技能get】让App像Web一样发布新版本</a></p>
<p><a href="http://gold.xitu.io/entry/564ab7eb60b259caed3827f1" target="_blank" rel="external">Android 热补丁动态修复框架小结</a></p>
<p><a href="http://segmentfault.com/a/1190000004062880" target="_blank" rel="external">Android动态加载基础 ClassLoader工作机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的&lt;a href=&quot;http://kiya.space/2015/12/28/hello-xposed/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第一个 Xposed 模块&lt;/a&gt;中曾出现&lt;code&gt;Class ref in pre-verified class resolved to unexpected implementation&lt;/code&gt;错误,Xposed log如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="Xposed" scheme="http://kiya.studio/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>第一个 Xposed 模块</title>
    <link href="http://kiya.studio/2015/12/28/hello-xposed/"/>
    <id>http://kiya.studio/2015/12/28/hello-xposed/</id>
    <published>2015-12-28T15:43:37.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境:<br>已root手机一枚(Android 4.4.4)<br>Android Studio一枚</p>
<a id="more"></a>
<p>官方文档参考<a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial-style1" target="_blank" rel="external">这里</a>.</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>我们需要事先下载一个<a href="http://dl-xda.xposed.info/modules/de.robv.android.xposed.installer_v33_36570c.apk-style1" target="_blank" rel="external">Xposed installer</a>安装在手机上,用来管理所有的模块.</p>
<p>安装完成后打开:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/53/02-style1" alt=""></p>
<p>点击<code>框架</code>,</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/53/32-style1" alt=""></p>
<p>点击<code>安装/更新</code>安装框架,</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/53/49-style1" alt=""></p>
<p>点击确定重启,框架界面是这样的:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/54/11-style1" alt=""></p>
<h1 id="编写新模块"><a href="#编写新模块" class="headerlink" title="编写新模块"></a>编写新模块</h1><p>打开android studio,新建工程,选择<code>Add no activity</code></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/09/54/35-style1" alt=""></p>
<p>新建完成后,找到<code>app</code>目录下的<code>build.gradle</code>文件,将<code>dependencies</code>中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div></pre></td></tr></table></figure>
<p>改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">provided fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div></pre></td></tr></table></figure>
<p>下载<a href="http://forum.xda-developers.com/attachment.php?attachmentid=2748878&amp;d=1400342298-style1" target="_blank" rel="external">XposedBridgeApi-54.jar</a>并放入app目录下的libs文件夹.</p>
<p>在<code>AndroidManifest.xml</code>文件的<code>application</code>中添加如下代码,其中的54是前面下载的文件中的号码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">    android:name=&quot;xposedmodule&quot;</div><div class="line">    android:value=&quot;true&quot; /&gt;</div><div class="line">&lt;meta-data</div><div class="line">    android:name=&quot;xposeddescription&quot;</div><div class="line">    android:value=&quot;kiya&apos;s test module&quot; /&gt;</div><div class="line">&lt;meta-data</div><div class="line">    android:name=&quot;xposedminversion&quot;</div><div class="line">    android:value=&quot;54&quot; /&gt;</div></pre></td></tr></table></figure>
<p>新建一个<code>Test</code>类,写入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package space.kiya.xposedtest;</div><div class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</div><div class="line">import de.robv.android.xposed.XposedBridge;</div><div class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</div><div class="line"></div><div class="line">public class Test implements IXposedHookLoadPackage&#123;</div><div class="line">    @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123;</div><div class="line">        XposedBridge.log(&quot;loaded: &quot; + loadPackageParam.packageName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建<code>assets</code>文件夹,在里面新建文件名为<code>xposed_init</code>,写入刚刚的类名,此处应为<code>space.kiya.xposedtest.Test</code>.</p>
<p>这时就可以编译安装了.</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>因为工程没有activity,所以在桌面上看不到该应用。<br>来到<code>xposed installer</code>的<code>模块</code>中,可以看到我们的模块出现在这里,现在勾选它:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/10/17/03-style1" alt=""></p>
<p>在重启使之生效之前,我们在logcat新建一个tag为<code>Xposed</code>的过滤器,这样就可以过滤出模块输出的log.<br>大概是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Loading Xposed v54(for Zygote)...</div><div class="line">Loading modules from /data/app/space.kiya.xposedtest-1.apk</div><div class="line">  Loading class space.kiya.xposedtest.Test</div><div class="line">Loaded: android</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样的日志在<code>xposed installer</code>的<code>日志</code>中也是可以看到的.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/10/16/42-style1" alt=""></p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><p>如果输出的log中出现了如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation</div></pre></td></tr></table></figure>
<p>说明是前面步骤中没有修改<code>build.gradle</code>导致的.</p>
<p>具体原因见<a href="http://kiya.space/2016/01/03/xposed-class-ispreverified/" target="_blank" rel="external">另一篇博客</a>.</p>
<h1 id="xposed怎样工作"><a href="#xposed怎样工作" class="headerlink" title="xposed怎样工作?"></a>xposed怎样工作?</h1><p>开机时,<code>./init.rc</code>脚本文件会启动<code>Zygote</code>进程,Zygote对应的具体程序是<code>/system/bin/app_process</code>,然后加载需要的类,调用初始化的方法,之后启动的每个应用都是Zygote的拷贝,所以Zygote进程是十分重要的.</p>
<p>通过在类路径中添加一个jar包,在<code>app_process</code>的特定位置调用jar包中的方法,Xposed框架实现了带扩展功能的<code>app_process</code>,然后将原有的<code>app_process</code>替换掉.<br>在<code>/data/data/de.robv.android.xposed.installer/bin/</code>目录下有一个<code>XposedBridge.jar</code>文件,它就是被引用的jar包,源码在<a href="https://github.com/rovo89/XposedBridge-style1" target="_blank" rel="external">github</a>,main函数在<code>/src/de/robv/android/xposed/XposedBridge.java</code>中,每个进程每次启动时都会被调用.加载模块的功能也是在这里实现.</p>
<p>Xposed真正强大的是它可以hook调用的方法.当你反编译修改apk时,你可以在里面插入xposed的命令,于是你就可以在方法调用前后注入自己的代码.</p>
<p>XposedBridge有一个私有的本地方法<code>hookMethodNative</code>,代码实现放在<code>app_process</code>中.在调用被hook的方法前会先调用此方法,<code>hookMethodNative</code>有一个<code>handleHookedMethod</code>方法,可以修改传递给被hook函数的参数,变量甚至是调用其他方法.</p>
<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>以上仅仅是证明了我们的xposed模块是可以工作的.现在来修改点什么,比如状态栏上的时间?</p>
<p>在安装源码下的<a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/Clock.java#42" target="_blank" rel="external">/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/Clock.java</a>文件中有一个<code>updateClock</code>函数用来更新时间.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final void updateClock() &#123;</div><div class="line">    if (mDemoMode) return;</div><div class="line">    mCalendar.setTimeInMillis(System.currentTimeMillis());</div><div class="line">    setText(getSmallTime());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码中使用<code>findAndHookMethod</code>函数找到这一函数,并在updateClock函数执行后将<code>TextView</code>的内容重新设置即可.注意在使用前需要这样将其导入:<code>import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</code>.<br>我们的效果是将时间后面加上一个笑脸,颜色设为红色.<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package space.kiya.xposedtest;</div><div class="line"></div><div class="line">import android.graphics.Color;</div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line">import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</div><div class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</div><div class="line">import de.robv.android.xposed.XC_MethodHook;</div><div class="line">import de.robv.android.xposed.XposedBridge;</div><div class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</div><div class="line"></div><div class="line">public class Test implements IXposedHookLoadPackage&#123;</div><div class="line">    @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123;</div><div class="line">        if(loadPackageParam.packageName.equals(&quot;com.android.systemui&quot;))&#123;</div><div class="line">            findAndHookMethod(&quot;com.android.systemui.statusbar.policy.Clock&quot;, loadPackageParam.classLoader, &quot;updateClock&quot;, new XC_MethodHook() &#123;</div><div class="line">                @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</div><div class="line">                    TextView tv = (TextView)param.thisObject;</div><div class="line">                    String text = tv.getText().toString();</div><div class="line">                    tv.setText(text + &quot;:)&quot;);</div><div class="line">                    tv.setTextColor(Color.RED);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/29/15/34/49-style1" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境:&lt;br&gt;已root手机一枚(Android 4.4.4)&lt;br&gt;Android Studio一枚&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="Xposed" scheme="http://kiya.studio/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>hook - Android ARM下的的so注入</title>
    <link href="http://kiya.studio/2015/12/23/hook-call-function-in-so/"/>
    <id>http://kiya.studio/2015/12/23/hook-call-function-in-so/</id>
    <published>2015-12-23T10:11:33.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对<a href="http://www.weibo.com/zhengmin1989" target="_blank" rel="external">大犇蒸米spark</a>的<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a>的实践记录以及知识整理!原文请戳<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">链接</a>.</p>
<a id="more"></a>
<p><strong>被测试代码:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int count = 0;</div><div class="line"></div><div class="line">void print()</div><div class="line">&#123;</div><div class="line">	printf(&quot;hello,%d\n&quot;,count);</div><div class="line">        sleep(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">	while(1)&#123;</div><div class="line">		print();</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注入方法都是通过ptrace实现的.<br>本文代码在<a href="https://github.com/kiya-z/Android/tree/master/hook" target="_blank" rel="external">github</a>.</p>
<h1 id="调用系统so库中的函数"><a href="#调用系统so库中的函数" class="headerlink" title="调用系统so库中的函数"></a>调用系统so库中的函数</h1><p>目标函数是<code>libc.so</code>中的<code>sleep</code>函数.<br>正常情况是每输出一次暂停一秒,现在我们让它暂停10秒.</p>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><ul>
<li>获取目标进程sleep函数地址</li>
<li>在目标进程内执行sleep函数</li>
</ul>
<h2 id="如何获取函数地址"><a href="#如何获取函数地址" class="headerlink" title="如何获取函数地址"></a>如何获取函数地址</h2><ul>
<li><p><strong>已知条件</strong>: 本进程的基址、目标进程的基址、本进程中sleep函数的地址(当然,这些已知条件也是需要获得的 :p)<br><code>/proc/&lt;pid&gt;/maps</code>文件中存储的是进程内存映射详情,我们可以在这个文件中查询进程中so的基址;<br><code>sleep</code>函数在本进程中的地址直接可以获得(<code>void*</code>)</p>
</li>
<li><p><strong>求解</strong>: 目标进程中sleep函数地址</p>
</li>
<li><p><strong>计算</strong>: 本进程sleep地址 - 本进程基址 + 目标进程基址</p>
</li>
</ul>
<h3 id="获取so库的加载基址"><a href="#获取so库的加载基址" class="headerlink" title="获取so库的加载基址"></a>获取so库的加载基址</h3><p>打开<code>/proc/&lt;pid&gt;/maps</code>文件找到基址.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">void* get_module_base(int pid, const char* module_name)</div><div class="line">&#123;</div><div class="line">    FILE *f;		//文件指针</div><div class="line">    long addr = 0;	//模块地址</div><div class="line">    char filename[32];	//maps路径</div><div class="line">    char *pch;</div><div class="line">    char line[1024];	//每行</div><div class="line">    if(pid == 0)&#123;</div><div class="line">        snprintf(filename, sizeof(filename), &quot;/proc/self/maps&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        snprintf(filename, sizeof(filename), &quot;/proc/%d/maps&quot;, pid);</div><div class="line">    &#125;</div><div class="line">    f = fopen(filename, &quot;r&quot;);</div><div class="line">    if(f != NULL)&#123;</div><div class="line">        while(fgets(line,sizeof(line),f))&#123;</div><div class="line">           if(strstr(line, module_name)) &#123;  //找到该行是否含有module_name</div><div class="line">               pch = strtok(line,&quot;-&quot;);  //分割出基址字符串</div><div class="line">               addr = strtoul(pch,NULL,0x10); //转换为16进制数</div><div class="line">               if(addr == 0x8000)   //32位linux程序中默认的text加载地址为0x08408000,64位的改为0x00400000,此时计算base地址就没什么用了</div><div class="line">                   addr = 0;</div><div class="line">               break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fclose(f);</div><div class="line">    &#125;</div><div class="line">    return (void*)addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="计算目标进程中sleep函数地址"><a href="#计算目标进程中sleep函数地址" class="headerlink" title="计算目标进程中sleep函数地址"></a>计算目标进程中sleep函数地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">long get_remote_addr(int target_pid, const char* module_name, void* local_addr)</div><div class="line">&#123;</div><div class="line">    void* local_handle = get_module_base(0,module_name);</div><div class="line">    void* remote_handle = get_module_base(target_pid,module_name);</div><div class="line"></div><div class="line">    printf(&quot;local_handle:%p  remote_handle:%p\n&quot;, local_handle, remote_handle);</div><div class="line"></div><div class="line">    //计算公式</div><div class="line">    long remote_addr = (long)((uint32_t)local_addr - (uint32_t)local_handle + (uint32_t)remote_handle);</div><div class="line"></div><div class="line">    printf(&quot;remote_addr:%p\n&quot;, remote_addr);</div><div class="line">    return remote_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何执行sleep函数"><a href="#如何执行sleep函数" class="headerlink" title="如何执行sleep函数"></a>如何执行sleep函数</h2><ul>
<li>设置函数参数,如果参数个数小于等于4,参数按顺序放入R0~R4寄存器中;如果参数个数大于4,多余的部分需要入栈.</li>
<li>设置pc寄存器的值,设置当前指令集标志位.</li>
<li>应用以上寄存器的修改使之生效.</li>
<li>等待函数执行.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//目标进程id,参数地址,参数个数,寄存器地址</div><div class="line">int ptrace_call(int pid, long addr, long *params, uint32_t params_num, struct pt_regs* regs)</div><div class="line">&#123;</div><div class="line">    uint32_t i;</div><div class="line">    for (i = 0; i &lt; params_num &amp;&amp; i &lt; 4; i++) &#123;     //设置少于4个的参数</div><div class="line">        regs-&gt;uregs[i] = params[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //设置多于4个的参数</div><div class="line">    if (i &lt; params_num) &#123;</div><div class="line">        regs-&gt;ARM_sp -= (params_num - i) * long_size;    //抬高栈顶指针(分配空间)</div><div class="line">        writeData(pid, (long)regs-&gt;ARM_sp, (char*)&amp;params[i], (params_num - i) * long_size); //写入</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    regs-&gt;ARM_pc = addr;    //设置pc</div><div class="line">    if (regs-&gt;ARM_pc &amp; 1) &#123;     //判断是否是Thumb指令</div><div class="line">        regs-&gt;ARM_pc &amp;= (~1u);  //Thumb的pc最后一位总是0</div><div class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;  //T标志位为1</div><div class="line">    &#125; else &#123;    //arm</div><div class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;  //T标志位为0</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    regs-&gt;ARM_lr = 0;   //为了使sleep函数执行完毕后产生“内存访问错误”,这样我们就知道什么时候执行完了</div><div class="line"></div><div class="line">    if(ptrace_setregs(pid,regs)==-1 || ptrace_continue(pid)==-1)&#123;   //目标进程继续执行</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int stat = 0;                   //WUNTRACED表示如果pid进程进入暂停状态，那么waitpid函数立即返回</div><div class="line">    waitpid(pid,&amp;stat,WUNTRACED);   //等待sleep函数执行,等待过程中本进程暂停执行</div><div class="line">    printf(&quot;%d\n&quot;, stat);</div><div class="line">    while (stat != 0xb7f) &#123;     //0xb7f表示目标进程进入暂停状态</div><div class="line">        printf(&quot;%d\n&quot;, stat);</div><div class="line">        if (ptrace_continue(pid) == -1) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        waitpid(pid,&amp;stat,WUNTRACED);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何注入"><a href="#如何注入" class="headerlink" title="如何注入"></a>如何注入</h2><ul>
<li>保存寄存器的值</li>
<li>获得sleep函数地址</li>
<li>执行sleep函数</li>
<li>恢复寄存器的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void inject(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs old_regs,regs;</div><div class="line">    long sleep_addr;</div><div class="line">    //保存寄存器</div><div class="line">    ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs);</div><div class="line">    memcpy(&amp;regs, &amp;old_regs, sizeof(regs));</div><div class="line"></div><div class="line">    long parameters[1];</div><div class="line">    parameters[0] = 10;</div><div class="line">    sleep_addr = get_remote_addr(pid, &quot;libc.so&quot;, (void*)sleep);</div><div class="line">    ptrace_call(pid,sleep_addr,parameters,1,&amp;regs);</div><div class="line">    //恢复寄存器</div><div class="line">    ptrace(PTRACE_SETREGS, pid, NULL, &amp;old_regs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;string.h&gt;  // strstr,strtok</div><div class="line">#include&lt;stdlib.h&gt;  //strtoul</div><div class="line">#include&lt;stdint.h&gt;  //uint32_t</div><div class="line">#include&lt;unistd.h&gt;  //sleep</div><div class="line">#include&lt;sys/ptrace.h&gt;</div><div class="line">#include&lt;linux/wait.h&gt;    // WUNTRACED</div><div class="line">#include&lt;time.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    if(argc != 2)&#123;</div><div class="line">        printf(&quot;usage: %s &lt;pid to be traced&gt;\n&quot;,argv[0]);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    int pid = atoi(argv[1]);</div><div class="line"></div><div class="line">    if(0 != ptrace(PTRACE_ATTACH, pid, NULL, NULL))&#123;</div><div class="line">        printf(&quot;attach failed.&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    inject(pid);</div><div class="line"></div><div class="line">    ptrace(PTRACE_DETACH, pid, NULL, NULL);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><h2 id="proc-lt-pid-gt-文件夹"><a href="#proc-lt-pid-gt-文件夹" class="headerlink" title="/proc/&lt;pid&gt; 文件夹"></a>/proc/&lt;pid&gt; 文件夹</h2><table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmdline</td>
<td>命令行全名(加参数变量)和 ps 命令中的command 列结果一样</td>
</tr>
<tr>
<td>cwd</td>
<td>进程的工作目录 和 (pwdx PID) 结果相同</td>
</tr>
<tr>
<td>environ</td>
<td>进程的环境变量</td>
</tr>
<tr>
<td>exe</td>
<td>一般是/bin/ 的链接</td>
</tr>
<tr>
<td>fd</td>
<td>进程打开的文件描述fu .用ls -l 可以查看具体的文件 (可以用lsof -p PID)</td>
</tr>
<tr>
<td>status</td>
<td>进程的相关状态</td>
</tr>
<tr>
<td>task</td>
<td>该目录下是进程所包含的线程(note: ps 可以查看线程)</td>
</tr>
<tr>
<td>mounts</td>
<td>进程挂载点</td>
</tr>
<tr>
<td>maps</td>
<td>进程内存映射详情</td>
</tr>
</tbody>
</table>
<h2 id="关于pc寄存器"><a href="#关于pc寄存器" class="headerlink" title="关于pc寄存器"></a>关于pc寄存器</h2><p><a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf" target="_blank" rel="external">arm.pdf</a> 中的<strong>A2.4.3 Register 15 and the program counter</strong>有这样一段话:<br>是关于指令集在pc寄存器上的表现的.</p>
<blockquote>
<p>Reading the program counter<br>When an instruction reads the PC, the value read depends on which instruction set it comes from:<br>• For an ARM instruction, the value read is the address of the instruction plus 8 bytes. Bits [1:0] of this<br>value are always zero, because ARM instructions are always word-aligned.<br>• For a Thumb instruction, the value read is the address of the instruction plus 4 bytes. Bit [0] of this<br>value is always zero, because Thumb instructions are always halfword-aligned.</p>
</blockquote>
<h2 id="关于CPSR寄存器"><a href="#关于CPSR寄存器" class="headerlink" title="关于CPSR寄存器"></a>关于CPSR寄存器</h2><table>
<thead>
<tr>
<th>31</th>
<th>30</th>
<th>29</th>
<th>28</th>
<th>27</th>
<th>26  25</th>
<th>24</th>
<th>23 20</th>
<th>19 16</th>
<th>15 10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>Z</td>
<td>C</td>
<td>V</td>
<td>Q</td>
<td>Res</td>
<td>J</td>
<td>RESERVED</td>
<td>GE[3:0]</td>
<td>RESERVED</td>
<td>E</td>
<td>A</td>
<td>I</td>
<td>F</td>
<td>T</td>
<td>M[4:0]</td>
</tr>
</tbody>
</table>
<p>其中J和T标记位代表当前指令集:</p>
<table>
<thead>
<tr>
<th>J</th>
<th>T</th>
<th>Instruction set</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>ARM</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Thumb</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Jazelle</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>RESERVED</td>
</tr>
</tbody>
</table>
<h2 id="关于waitpid"><a href="#关于waitpid" class="headerlink" title="关于waitpid"></a>关于waitpid</h2><p>详细介绍可看<a href="https://support.sas.com/documentation/onlinedoc/sasc/doc/lr2/wait.htm" target="_blank" rel="external">官方文档</a>.</p>
<h3 id="参数status"><a href="#参数status" class="headerlink" title="参数status"></a>参数status</h3><p><code>wait</code>函数调用过后,<code>status</code>指针指向可以被宏解析的值,这些宏在ndk目录下<code>platforms/android-21/arch-arm/usr/include/sys/wait.h</code>文件中定义.</p>
<p>高2字节用于表示导致子进程的退出或暂停状态信号值(<code>WTERMSIG</code>)，低2字节表示子进程是退出(0x0)还是暂停(0x7f)状态(<code>WEXITSTATUS</code>)。<br>如:0xb7f就表示子进程为暂停状态，导致它暂停的信号量为11即<code>sigsegv</code>错误。<br>关于错误代码的文档可看<a href="https://support.sas.com/documentation/onlinedoc/sasc/doc/lr1/lrv1ch5.htm" target="_blank" rel="external">这里</a>,<br>定义在ndk目录下<code>platforms/android-21/arch-arm/usr/include/asm/signal.h</code>中.</p>
<blockquote>
<p>其中两个宏:<br>WEXITSTATUS(*statusPtr):<br>if the child process terminates normally, this macro evaluates to the lower 8 bits of the value passed to the exit or _exit function or returned from main.<br>WTERMSIG(*statusPtr)<br>if the child process ends by a signal that was not caught, this macro evaluates to the number of that signal.</p>
</blockquote>
<h3 id="参数options"><a href="#参数options" class="headerlink" title="参数options"></a>参数options</h3><p>指定了<code>waitpid</code>的额外行动.选项有:</p>
<p><strong>WNOHANG</strong>:<br>告诉<code>waitpid</code>不等程序中止立即返回<code>status</code>信息.<br>正常情况是当主进程对子进程使用了<code>waitpid</code>,主进程就会阻塞直到<code>waitpid</code>返回<code>status</code>信息;如果指定了<code>WNOHANG</code>选项,主进程就不会阻塞了.<br>如果还没有可用的<code>status</code>信息,<code>waitpid</code>返回0.</p>
<p><strong>WUNTRACED</strong>:<br>告诉<code>waitpid</code>，如果子进程进入暂停状态或者已经终止，那么就立即返回<code>status</code>信息,正常情况是紫禁城终止的时候才返回.<br>如果是被ptrace的子进程，那么即使不提供WUNTRACED参数，也会在子进程进入暂停状态的时候立即返回。<br>对于使用<code>ptrace_cont</code>运行的子进程，它会在3种情况下进入暂停状态：①下一次系统调用；②子进程退出；③子进程的执行发生错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>程序中的<code>0xb7f</code>就表示子进程进入了暂停状态，且发送的错误信号为11(SIGSEGV)，它表示试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。<br>当子进程执行完注入的函数后，由于我们在前面设置了regs-&gt;ARM_lr = 0，它就会返回到0地址处继续执行，这样就会产生SIGSEGV了.</p>
<h1 id="调用自定义so库中的函数"><a href="#调用自定义so库中的函数" class="headerlink" title="调用自定义so库中的函数"></a>调用自定义so库中的函数</h1><ul>
<li>保存当前寄存器的状态</li>
<li>获取目标程序的mmap, dlopen, dlsym, dlclose函数地址</li>
<li>调用mmap分配空间保存参数信息</li>
<li>调用dlopen加载so库</li>
<li>调用dlsym找到目标函数地址</li>
<li>执行目标函数</li>
<li>调用dlclose卸载so库</li>
<li>恢复寄存器的状态</li>
</ul>
<h2 id="保存当前寄存器的状态"><a href="#保存当前寄存器的状态" class="headerlink" title="保存当前寄存器的状态"></a>保存当前寄存器的状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct pt_regs old_regs,regs;</div><div class="line">ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs);</div><div class="line">memcpy(&amp;regs,&amp;old_regs,sizeof(regs));</div></pre></td></tr></table></figure>
<h2 id="获取目标程序的mmap-dlopen-dlsym-dlclose函数地址"><a href="#获取目标程序的mmap-dlopen-dlsym-dlclose函数地址" class="headerlink" title="获取目标程序的mmap, dlopen, dlsym, dlclose函数地址"></a>获取目标程序的mmap, dlopen, dlsym, dlclose函数地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">long mmap_addr,dlopen_addr,dlsym_addr,dlclose_addr;</div><div class="line">mmap_addr = get_remote_addr(pid, libc_path, (void*)mmap);</div><div class="line">dlopen_addr = get_remote_addr(pid, libc_path, (void*)dlopen);</div><div class="line">dlsym_addr = get_remote_addr(pid, libc_path, (void*)dlsym);</div><div class="line">dlclose_addr = get_remote_addr(pid, libc_path, (void*)dlclose);</div></pre></td></tr></table></figure>
<h2 id="调用mmap分配空间保存参数信息"><a href="#调用mmap分配空间保存参数信息" class="headerlink" title="调用mmap分配空间保存参数信息"></a>调用mmap分配空间保存参数信息</h2><p>mmap的原型如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>addr</td>
<td>映射的起始地址,为0表示由系统决定映射的起始地址</td>
</tr>
<tr>
<td>length</td>
<td>映射的长度</td>
</tr>
<tr>
<td>prot</td>
<td>映射的内存保存属性,不能与文件的打开模式冲突</td>
</tr>
<tr>
<td>flags</td>
<td>指定映射对象的类型,映射选项和映射页是否可以共享</td>
</tr>
<tr>
<td>fd</td>
<td>有效的文件描述符,一般是由open()函数返回;其值也可以设置为-1,此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射</td>
</tr>
<tr>
<td>offset</td>
<td>被映射对象内容的起点</td>
</tr>
</tbody>
</table>
<p>这里我们需要的调用语句是<code>mmap(0,0x4000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE,0,0)</code>,<br><code>PROT_EXEC</code>表示可执行.<br><code>PROT_READ</code>表示可读.<br><code>PROT_WRITE</code>表示可写.<br><code>MAP_PRIVATE</code>表示建.立一个写入时拷贝的私有映射.内存区域的写入不会影响到原文件.这个标志和以上标志是互斥的,只能使用其中一个.<br><code>MAP_ANONYMOUS</code>表示匿名映射,映射区不与任何文件关联.<br>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">long parameters[10];    </div><div class="line">parameters[0] = 0;  //构造参数</div><div class="line">parameters[1] = 0x4000;</div><div class="line">parameters[2] = PROT_READ | PROT_WRITE | PROT_EXEC;</div><div class="line">parameters[3] = MAP_ANONYMOUS | MAP_PRIVATE;</div><div class="line">parameters[4] = 0;</div><div class="line">parameters[5] = 0;</div><div class="line">ptrace_call(pid,mmap_addr,parameters,6,&amp;regs);</div><div class="line">//调用结束后获得r0中保存的返回值</div><div class="line">ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">long mapping_base = regs.ARM_r0;</div></pre></td></tr></table></figure>
<h2 id="调用dlopen加载so库"><a href="#调用dlopen加载so库" class="headerlink" title="调用dlopen加载so库"></a>调用dlopen加载so库</h2><p><strong>原型:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *dlopen(const char *filename, int flags);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>so库名</td>
</tr>
<tr>
<td>flags</td>
<td>打开方式</td>
</tr>
</tbody>
</table>
<p>这里我们需要的调用语句是<code>dlopen(so_path,RTLD_NOW | RTLD_GLOBAL)</code>,<br><code>RTLD_NOW</code>表示需要在dlopen返回前,解析出所有未定义符号,如果解析不出来在dlopen会返回NULL;<br><code>RTLD_GLOBAL</code>表示动态库中定义的符号可被其后打开的其它库解析.<br>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">writeData(pid, mapping_base, so_path, strlen(so_path)+1);   //将库名字符串放入目标进程空间</div><div class="line">parameters[0] = mapping_base;</div><div class="line">parameters[1] = RTLD_NOW | RTLD_GLOBAL;</div><div class="line">ptrace_call(pid, dlopen_addr, parameters, 2, &amp;regs);</div><div class="line">ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);  //调用结束后获得r0中保存的返回值</div><div class="line">long handle = regs.ARM_r0;</div></pre></td></tr></table></figure>
<h2 id="调用dlsym找到目标函数地址"><a href="#调用dlsym找到目标函数地址" class="headerlink" title="调用dlsym找到目标函数地址"></a>调用dlsym找到目标函数地址</h2><p>原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *dlsym(void *handle, const char *symbol);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>handle</td>
<td>so库的基址</td>
</tr>
<tr>
<td>symbol</td>
<td>函数名地址</td>
</tr>
</tbody>
</table>
<p>这里我们需要的调用语句是<code>dlsym(handle, function_name)</code>,则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">writeData(pid, mapping_base, function_name, strlen(function_name)+1);</div><div class="line">parameters[0] = handle;</div><div class="line">parameters[1] = mapping_base;</div><div class="line">ptrace_call(pid, dlsym_addr, parameters, 2, &amp;regs);</div><div class="line">ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);  //调用结束后获得r0中保存的返回值</div><div class="line">long function_addr = regs.ARM_r0;</div></pre></td></tr></table></figure>
<h2 id="执行目标函数"><a href="#执行目标函数" class="headerlink" title="执行目标函数"></a>执行目标函数</h2><p>先写段c程序编译为so文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">void hello(char *str)</div><div class="line">&#123;</div><div class="line">    printf(&quot;hello %s\n&quot;,str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">writeData(pid, mapping_base, function_parameters, strlen(function_parameters)+1);</div><div class="line">parameters[0] = mapping_base;</div><div class="line">ptrace_call(pid, function_addr, parameters, 1, &amp;regs);</div></pre></td></tr></table></figure>
<h2 id="调用dlclose卸载so库"><a href="#调用dlclose卸载so库" class="headerlink" title="调用dlclose卸载so库"></a>调用dlclose卸载so库</h2><p>原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int dlclose(void *handle);</div></pre></td></tr></table></figure>
<p>则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parameters[0] = handle;</div><div class="line">ptrace_call(pid,dlclose_addr,parameters,1,&amp;regs);</div></pre></td></tr></table></figure>
<h2 id="恢复寄存器的状态"><a href="#恢复寄存器的状态" class="headerlink" title="恢复寄存器的状态"></a>恢复寄存器的状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ptrace(PTRACE_SETREGS,pid,NULL,&amp;old_regs);</div></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a></p>
<p><a href="http://blog.csdn.net/jinzhuojun/article/details/9900105" target="_blank" rel="external">Android中的so注入(inject)和挂钩(hook) - For both x86 and arm</a></p>
<p><a href="http://www.cnblogs.com/wanyuanchun/p/4020756.html" target="_blank" rel="external">Android注入完全剖析</a></p>
<p><a href="http://segmentfault.com/a/1190000000606904" target="_blank" rel="external">http://segmentfault.com/a/1190000000606904</a></p>
<p><a href="http://www.sanwho.com/133.html" target="_blank" rel="external">Android下so注入汇总</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对&lt;a href=&quot;http://www.weibo.com/zhengmin1989&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大犇蒸米spark&lt;/a&gt;的&lt;a href=&quot;http://drops.wooyun.org/tips/9300&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安卓动态调试七种武器之离别钩 – Hooking&lt;/a&gt;的实践记录以及知识整理!原文请戳&lt;a href=&quot;http://drops.wooyun.org/tips/9300&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="hook" scheme="http://kiya.studio/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫 - 登录csdn</title>
    <link href="http://kiya.studio/2015/12/22/csdn-login/"/>
    <id>http://kiya.studio/2015/12/22/csdn-login/</id>
    <published>2015-12-22T05:15:58.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>urllib2</code>、<code>BeautifulSoup</code>和<code>CookieJar</code>实现登录.</p>
<a id="more"></a>
<p>使用charles抓包找到post的login网址: <code>https://passport.csdn.net/account/login</code></p>
<p>再来看看post的参数:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/22/16/26/16" alt=""></p>
<p>哎呀这里的密码竟然是明文..</p>
<p>username、password和_eventId好说,只是lt和execution在哪里获得呢?</p>
<p>我们来看一下紧挨着的GET请求返回的html代码,这里竟然还有注释哇哇:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/22/16/29/43" alt=""></p>
<p>好,那么现在总结一下 <strong>步骤</strong>:</p>
<ol>
<li>对<code>https://passport.csdn.net/account/login</code>进行get请求,在html代码中获得lt和execution;</li>
<li>表单创建</li>
<li>带上POST表单,进行POST请求</li>
</ol>
<p><strong>代码如下:</strong></p>
<p>获取 lt 和 execution:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cookie = cookielib.MozillaCookieJar(&apos;cookie.txt&apos;)   # MozillaCookieJar可保存cookie</div><div class="line">cookie_handler = urllib2.HTTPCookieProcessor(cookie)</div><div class="line">opener = urllib2.build_opener(cookie_handler)</div><div class="line"># prepare for login</div><div class="line">response = opener.open(&apos;https://passport.csdn.net/account/login&apos;)</div><div class="line">data = response.read()</div><div class="line">lt = &quot;&quot;</div><div class="line">execution = &quot;&quot;</div><div class="line">bs = BeautifulSoup(response.read(),&quot;lxml&quot;)</div><div class="line">for input in bs.form.find_all(&apos;input&apos;):</div><div class="line">    if input.get(&apos;name&apos;) == &apos;lt&apos;:</div><div class="line">        lt = input.get(&apos;value&apos;)</div><div class="line">    if input.get(&apos;name&apos;) == &apos;execution&apos;:</div><div class="line">        execution = input.get(&apos;value&apos;)</div></pre></td></tr></table></figure>
<p><strong>表单</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">post_data = urllib.urlencode(&#123;</div><div class="line">    &apos;username&apos; : &apos;xxxx&apos;,</div><div class="line">    &apos;password&apos; : &apos;xxxx&apos;,</div><div class="line">    &apos;lt&apos; : lt,</div><div class="line">    &apos;execution&apos; : execution,</div><div class="line">    &apos;_eventId&apos; : &apos;submit&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>POST地址</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">login_url = &apos;https://passport.csdn.net/account/login&apos;</div></pre></td></tr></table></figure>
<p><strong>POST</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request = urllib2.Request(url = login_url,data=post_data)</div><div class="line">try:</div><div class="line">    response = opener.open(request)</div><div class="line">except urllib2.HTTPError as e:</div><div class="line">    print e.read()</div></pre></td></tr></table></figure>
<p><strong>GET其他网址验证</strong>:</p>
<p>注意这里的request请求需要带上headers,否则会报<code>403 forbidden</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">headers_data = &#123;</div><div class="line">    &apos;User-Agent&apos; :	&apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:42.0) Gecko/20100101 Firefox/42.0&apos;</div><div class="line">&#125;</div><div class="line">request = urllib2.Request(url = &apos;http://blog.csdn.net/attach_114&apos;,headers=headers_data)</div><div class="line">print opener.open(request).read()</div></pre></td></tr></table></figure>
<p><strong>完整代码:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">#coding:utf-8</div><div class="line">import urllib</div><div class="line">import urllib2</div><div class="line">import cookielib</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">from pass_csdn import username,password</div><div class="line">cookie = cookielib.MozillaCookieJar(&apos;cookie.txt&apos;)</div><div class="line">cookie_handler = urllib2.HTTPCookieProcessor(cookie)</div><div class="line">opener = urllib2.build_opener(cookie_handler)</div><div class="line">def login():</div><div class="line">    # prepare for login</div><div class="line">    response = opener.open(&apos;https://passport.csdn.net/account/login&apos;)</div><div class="line">    lt = &quot;&quot;</div><div class="line">    execution = &quot;&quot;</div><div class="line">    bs = BeautifulSoup(response.read(),&quot;lxml&quot;)</div><div class="line">    for input in bs.form.find_all(&apos;input&apos;):</div><div class="line">        if input.get(&apos;name&apos;) == &apos;lt&apos;:</div><div class="line">            lt = input.get(&apos;value&apos;)</div><div class="line">        if input.get(&apos;name&apos;) == &apos;execution&apos;:</div><div class="line">            execution = input.get(&apos;value&apos;)</div><div class="line">    post_data = urllib.urlencode(&#123;</div><div class="line">        &apos;username&apos; : username,</div><div class="line">        &apos;password&apos; : password,</div><div class="line">        &apos;lt&apos; : lt,</div><div class="line">        &apos;execution&apos; : execution,</div><div class="line">        &apos;_eventId&apos; : &apos;submit&apos;</div><div class="line">    &#125;)</div><div class="line">    headers_data = &#123;</div><div class="line">        &apos;User-Agent&apos; :	&apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:42.0) Gecko/20100101 Firefox/42.0&apos;</div><div class="line">    &#125;</div><div class="line">    login_url_with_jsession = &apos;https://passport.csdn.net/account/login&apos;</div><div class="line">    request = urllib2.Request(url = login_url_with_jsession,data=post_data)</div><div class="line">    try:</div><div class="line">        response = opener.open(request)</div><div class="line">    except urllib2.HTTPError as e:</div><div class="line">        print e.read()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    login()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;urllib2&lt;/code&gt;、&lt;code&gt;BeautifulSoup&lt;/code&gt;和&lt;code&gt;CookieJar&lt;/code&gt;实现登录.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://kiya.studio/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kiya.studio/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>hook - 拦截系统调用</title>
    <link href="http://kiya.studio/2015/12/21/hook-syscall/"/>
    <id>http://kiya.studio/2015/12/21/hook-syscall/</id>
    <published>2015-12-21T10:11:32.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对<a href="http://www.weibo.com/zhengmin1989" target="_blank" rel="external">大犇蒸米spark</a>的<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a>的实践记录以及知识整理!原文请戳<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">链接</a>.</p>
<a id="more"></a>
<p>实现hook就离不开<a href="http://kiya.space/2015/12/18/ptrace-basis/" target="_blank" rel="external">ptrace</a>.</p>
<h1 id="ARM上的系统调用"><a href="#ARM上的系统调用" class="headerlink" title="ARM上的系统调用"></a>ARM上的系统调用</h1><p>系统调用由SWI实现,即软件中断(Software Interrupt),在请求系统服务时造成的中断,由SWI指令造成异常从而切入特权模式,从而允许非特权模式访问特权模式的函数.</p>
<p>ARM中有两种系统调用方式: OABI(old application binary interface)和EABI(extended application binary interface).见(内核源码arch/arm/kernel/entry-common.S文件).</p>
<p>对于OABI: 通过跟随在swi指令后的调用号来进行. <code>1101 1111 vvvv vvvv -- SWI immed_8</code> (Thumb指令)格式)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swi (#num | 0x900000) (0x900000是个magic值)</div></pre></td></tr></table></figure></p>
<p>对于EABI: 调用号存放在r7中. <code>1110 1111 0000 0000 -- SWI 0</code> (Thumb指令格式)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov r7, #num</div><div class="line">swi 0x0</div></pre></td></tr></table></figure></p>
<p>在 <a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf" target="_blank" rel="external">arm.pdf</a>的 <strong>A4.1.107 SWI</strong> 和 <strong>A7.1.69 SWI</strong> 分别是对ARM和Thumb中SWI的描述.</p>
<p>所有的系统调用号在<code>arch/arm/include/asm/unistd.h</code>文件.</p>
<p>所以在得到一条SWI指令时,要解析出系统调用号得分两种情况:<br>这里的源程序直接按ARM指令集处理了,没有做判断thumb的处理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if(ins == 0xef000000)&#123;      //直接和指令比较</div><div class="line">    return regs-&gt;ARM_r7;</div><div class="line">&#125;else&#123;</div><div class="line">    if((ins &amp; 0x0ff00000) != 0x0f900000)&#123;   //和magic值比较,这里我认为前面两位0f改成别的值也是可以的,重要的是magic值</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    return ins &amp;= 0x000fffff;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="拦截系统调用"><a href="#拦截系统调用" class="headerlink" title="拦截系统调用"></a>拦截系统调用</h1><p><strong>整个思路是:</strong></p>
<p>使被调试程序在下次次调用系统函数前后停下(SYSCALL),这时调试程序对被调试进行操作(PTRACE_PEEKTEXT/PTRACE_GETREGS…),随后使被调试程序继续运行(SYSCALL),调试程序等待(wait).</p>
<p><strong>被调试程序:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">int count = 0;</div><div class="line">void print()</div><div class="line">&#123;</div><div class="line">	printf(&quot;hello,%d\n&quot;,count);</div><div class="line">        sleep(1);</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">	while(1)&#123;</div><div class="line">		print();</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>调试程序:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;sys/ptrace.h&gt;  //头文件路径根据ndk目录下/platforms/android-21/arch-arm/usr/include</div><div class="line">#include&lt;asm/unistd.h&gt;</div><div class="line">long getSystemCallNumber(int pid, struct pt_regs *regs)</div><div class="line">&#123;</div><div class="line">    long ins = 0;</div><div class="line">    ins = ptrace(PTRACE_PEEKTEXT, pid, (void *)(regs-&gt;ARM_pc - 4), NULL);   //r15-4</div><div class="line">    if(ins == 0)&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if(ins == 0xef000000)&#123;      //EABI</div><div class="line">        return regs-&gt;ARM_r7;</div><div class="line">    &#125;else&#123;</div><div class="line">        if((ins &amp; 0x0ff00000) != 0x0f900000)&#123;   //OABI</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        return ins &amp;= 0x000fffff;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void doSthBefore(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs regs;</div><div class="line">    int sysCallNumber = 0;</div><div class="line">    ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">    sysCallNumber = getSystemCallNumber(pid,&amp;regs);</div><div class="line">    printf(&quot;before syscallno: %d\n&quot;, sysCallNumber);</div><div class="line">    if(sysCallNumber == __NR_write)&#123;    //得到参数</div><div class="line">        printf(&quot;__NR_write &lt;&lt; %ld, %p, %ld\n&quot;,regs.ARM_r0, (void*)regs.ARM_r1, regs.ARM_r2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void doSthAfter(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs regs;</div><div class="line">    int sysCallNumber = 0;</div><div class="line">    ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">    sysCallNumber = getSystemCallNumber(pid,&amp;regs);</div><div class="line">    printf(&quot;after syscallno: %d\n&quot;, sysCallNumber);</div><div class="line">    if(sysCallNumber == __NR_write)&#123;</div><div class="line">        printf(&quot;__NR_write &gt;&gt; %ld\n&quot;,regs.ARM_r0);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    if(argc != 2)&#123;</div><div class="line">        printf(&quot;usage: %s &lt;pid to be traced&gt;\n&quot;,argv[0]);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    int pid = atoi(argv[1]);</div><div class="line">    if(0 != ptrace(PTRACE_ATTACH, pid, NULL, NULL))&#123;</div><div class="line">        printf(&quot;attach failed.&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);    //使之在系统调用前后停下</div><div class="line">    int status;</div><div class="line">    while(1)&#123;</div><div class="line">        wait(&amp;status);</div><div class="line">        doSthBefore(pid);</div><div class="line">        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);</div><div class="line">        wait(&amp;status);</div><div class="line">        doSthAfter(pid);</div><div class="line">        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);</div><div class="line">    &#125;</div><div class="line">    ptrace(PTRACE_DETACH, pid, NULL, NULL);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结果:</strong></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/19/16/20/25" alt=""></p>
<h1 id="修改函数参数"><a href="#修改函数参数" class="headerlink" title="修改函数参数"></a>修改函数参数</h1><p>修改printf的参数:字符串及其长度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">#define long_size 4</div><div class="line">void readData(int pid, long addr, char *str, int len)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    char *laddr;</div><div class="line">    union u&#123;</div><div class="line">        long val;</div><div class="line">        char chars[long_size];</div><div class="line">    &#125;data;</div><div class="line">    i = 0;</div><div class="line">    j = len / long_size;</div><div class="line">    laddr = str;</div><div class="line">    while (i &lt; j) &#123;</div><div class="line">        data.val = ptrace(PTRACE_PEEKDATA, pid, addr+i*4, NULL);    //PEEKDATA一次读一个字</div><div class="line">        memcpy(laddr,data.chars,long_size);</div><div class="line">        laddr += long_size;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    j = len % long_size;</div><div class="line">    if (j != 0) &#123;</div><div class="line">        data.val = ptrace(PTRACE_PEEKDATA, pid, addr+i*4, NULL);    //PEEKDATA一次读一个字</div><div class="line">        memcpy(laddr,data.chars,long_size);</div><div class="line">    &#125;</div><div class="line">    str[len] = &apos;\0&apos;;</div><div class="line">&#125;</div><div class="line">void writeData(int pid, long addr, char *str, int len)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    char *laddr;</div><div class="line">    union u&#123;</div><div class="line">        long val;</div><div class="line">        char chars[long_size];</div><div class="line">    &#125;data;</div><div class="line">    i = 0;</div><div class="line">    j = len / long_size;</div><div class="line">    laddr = str;</div><div class="line">    while (i &lt; j) &#123;</div><div class="line">        memcpy(data.chars,laddr,long_size);</div><div class="line">        ptrace(PTRACE_POKEDATA, pid, addr+i*4, data.val);    //PEEKDATA一次写一个字</div><div class="line">        laddr += long_size;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    j = len % long_size;</div><div class="line">    if (j != 0) &#123;</div><div class="line">        memcpy(data.chars,laddr,j);</div><div class="line">        ptrace(PTRACE_POKEDATA, pid, addr+i*4, data.val);    //POKEDATA一次写一个字</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void strrev(char *p)</div><div class="line">&#123;</div><div class="line">  char *q = p;</div><div class="line">  while(q &amp;&amp; *q) ++q;</div><div class="line">  for(--q; p &lt; q; ++p, --q)</div><div class="line">    *p = *p ^ *q,</div><div class="line">    *q = *p ^ *q,</div><div class="line">    *p = *p ^ *q;</div><div class="line">&#125;</div><div class="line">void modifyString(int pid,long addr,long len)</div><div class="line">&#123;</div><div class="line">    char *str;</div><div class="line">    str = (char*)calloc(sizeof(char)*(len+1),1);</div><div class="line">    readData(pid,addr,str,len);</div><div class="line">    strrev(str);</div><div class="line">    writeData(pid,addr,str,len);</div><div class="line">&#125;</div><div class="line">void doSthBefore(int pid)</div><div class="line">&#123;</div><div class="line">    struct pt_regs regs;</div><div class="line">    int sysCallNumber = 0;</div><div class="line">    ptrace(PTRACE_GETREGS,pid,NULL,&amp;regs);</div><div class="line">    sysCallNumber = getSystemCallNumber(pid,&amp;regs);</div><div class="line">    printf(&quot;before syscallno: %d\n&quot;, sysCallNumber);</div><div class="line">    if(sysCallNumber == __NR_write)&#123;</div><div class="line">        printf(&quot;__NR_write &lt;&lt; %ld, %p, %ld\n&quot;,regs.ARM_r0, (void*)regs.ARM_r1, regs.ARM_r2);</div><div class="line">        modifyString(pid,regs.ARM_r1,regs.ARM_r2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="external">安卓动态调试七种武器之离别钩 – Hooking</a></p>
<p><a href="http://www.xuebuyuan.com/706076.html" target="_blank" rel="external">Android ptrace简介</a></p>
<p><a href="http://blog.csdn.net/ce123/article/details/6925375" target="_blank" rel="external">浅谈EABI和OABI</a></p>
<p><a href="http://blog.csdn.net/myarrow/article/details/7036266" target="_blank" rel="external">Arm Linux系统调用流程详细解析-SWI</a></p>
<p><a href="http://bbs.pediy.com/showthread.php?t=196435" target="_blank" rel="external">linux arm 系统调用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对&lt;a href=&quot;http://www.weibo.com/zhengmin1989&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大犇蒸米spark&lt;/a&gt;的&lt;a href=&quot;http://drops.wooyun.org/tips/9300&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安卓动态调试七种武器之离别钩 – Hooking&lt;/a&gt;的实践记录以及知识整理!原文请戳&lt;a href=&quot;http://drops.wooyun.org/tips/9300&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="hook" scheme="http://kiya.studio/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>反调试方法二 - 抢占ptrace</title>
    <link href="http://kiya.studio/2015/12/18/ptrace-basis/"/>
    <id>http://kiya.studio/2015/12/18/ptrace-basis/</id>
    <published>2015-12-18T13:42:40.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>The ptrace() system call provides a means by which one process (the”tracer”) may observe and control the execution of another process(the “tracee”), and examine and change the tracee’s memory andregisters.  It is primarily used to implement breakpoint debugging and system call tracing.</p>
</blockquote>
<p>帮助文档<a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="external">online</a>.</p>
<a id="more"></a>
<h1 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h1><p><code>ptrace</code>可以让一个进程监视和控制另一个进程的执行,并且修改被监视进程的内存、寄存器等,主要应用于断点调试和系统调用跟踪.</p>
<p>函数原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long ptrace(int request, pid_t pid, void * addr, void * data)</div></pre></td></tr></table></figure></p>
<p>其中,request代表请求类型,pid代表被调试进程的pid.</p>
<blockquote>
<p>ptrace建立跟踪关系的两种方式:</p>
<ol>
<li>fork:<br>利用fork+execve执行被测试的程序，子进程在执行execve之前调用ptrace(PTRACE_TRACEME)，建立了与父进程(debugger)的跟踪关系。</li>
<li>attach: debugger可以调用ptrace(PTRACE_ATTACH，pid,…)，建立自己与进程号为pid的进程间的跟踪关系。<br>即利用PTRACE_ATTACH，使自己变成被调试程序的父进程(用ps可以看到)。用attach建立起来的跟踪关系，可以调用ptrace(PTRACE_DETACH，pid,…)来解除。注意attach进程时的权限问题，如一个非root权限的进程是不能attach到一个root进程上的。</li>
</ol>
</blockquote>
<p>有信号发生时,被调试进程就会暂停下来,并且通知调试进程.调试进程可以调用waitpid()获得被调试进程暂停位置的相关信息.<br>在被调试进程暂停的期间,调试进程可以各种ptrace request来对被调试进程进行操作,查看、修改、使之继续运行、忽略该信号甚至发送信号.</p>
<h1 id="部分ptrace-request"><a href="#部分ptrace-request" class="headerlink" title="部分ptrace request"></a>部分ptrace request</h1><h2 id="PTRACE-TRACEME"><a href="#PTRACE-TRACEME" class="headerlink" title="PTRACE_TRACEME"></a>PTRACE_TRACEME</h2><p>将当前进程切换到停止状态。它通常总是与 fork/exec 一起使用。对于每一个进程，PTRACE_TRACEME 只能被调用一次。</p>
<h2 id="PTRACE-ATTACH"><a href="#PTRACE-ATTACH" class="headerlink" title="PTRACE_ATTACH"></a>PTRACE_ATTACH</h2><p>根据pid将被调试进程附加到调试进程上,PTRACE_ATTACH向被调试进程发送SIGSTOP信号使之停下.<br>但是在<code>ptrace(PTRACE_ATTACH,pid,0,0)</code>执行完毕时被调试进程可能还没有暂停,可以使用<code>waitpid()</code>等待其停下.</p>
<h2 id="PTRACE-DETACH"><a href="#PTRACE-DETACH" class="headerlink" title="PTRACE_DETACH"></a>PTRACE_DETACH</h2><p>将被调试进程与调试进程分离,使被调试进程正常运行.</p>
<h2 id="PTRACE-SYSCALL"><a href="#PTRACE-SYSCALL" class="headerlink" title="PTRACE_SYSCALL"></a>PTRACE_SYSCALL</h2><p>使被调试进程继续运行,但是在下一个系统调用的入口处或出口处停下,或者是执行完一条指令后停下.<br>例如,调试进程可以监视被调试进程系统调用入口处的参数,接着再使用SYSCALL,监视系统调用的返回值.</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait函数会延迟父进程的执行，直到被调试的进程切换为停止状态或者终止为止.</p>
<h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><p>ptrace被广泛用于反调试,因为一个进程只能被ptrace一次,如果事先调用了ptrace方法,那就可以防止别人调试我们的程序.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;sys/ptrace.h&gt;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    ptrace(PTRACE_TRACEME);</div><div class="line">    while(1)&#123;</div><div class="line">        printf(&quot;Hello Ptrace!\n&quot;);</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译:<code>gcc -g -o hello-ptrace hello-ptrace.c</code></p>
<p>运行:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/18/16/07/45" alt=""></p>
<p>另开命令行调试:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/18/15/59/52" alt=""></p>
<h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;sys/ptrace.h&gt;</div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    if(-1 == ptrace(PTRACE_TRACEME))</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Debugger!\n&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;Hello Ptrace!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="反反调试"><a href="#反反调试" class="headerlink" title="反反调试"></a>反反调试</h1><p><code>ptrace</code>用户态源码(位于bionic/libc/bionic/ptrace.c):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">long ptrace(int request, pid_t pid, void * addr, void * data)</div><div class="line">&#123;</div><div class="line">    switch (request) &#123;</div><div class="line">        case PTRACE_PEEKUSR:</div><div class="line">        case PTRACE_PEEKTEXT:</div><div class="line">        case PTRACE_PEEKDATA:</div><div class="line">        &#123;</div><div class="line">            long word;</div><div class="line">            long ret;</div><div class="line">            ret = __ptrace(request, pid, addr, &amp;word);</div><div class="line">            if (ret == 0) &#123;</div><div class="line">                return word;</div><div class="line">            &#125; else &#123;</div><div class="line">                // __ptrace will set errno for us</div><div class="line">                return -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        default:</div><div class="line">             return __ptrace(request, pid, addr, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0表示成功,-1表示错误.</p>
<ul>
<li><p>单个应用可在ptrace下断点.</p>
</li>
<li><p>定制ROM,可以将ptrace源代码修改为<code>如果是自己的pid调用ptrace,返回-1;否则返回0</code>.</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.xuebuyuan.com/706076.html" target="_blank" rel="external">Android ptrace简介</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The ptrace() system call provides a means by which one process (the”tracer”) may observe and control the execution of another process(the “tracee”), and examine and change the tracee’s memory andregisters.  It is primarily used to implement breakpoint debugging and system call tracing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;帮助文档&lt;a href=&quot;http://man7.org/linux/man-pages/man2/ptrace.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;online&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="anti-debug" scheme="http://kiya.studio/tags/anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>脱壳基础 dvmDexFileOpenPartial</title>
    <link href="http://kiya.studio/2015/12/16/unshell-basic/"/>
    <id>http://kiya.studio/2015/12/16/unshell-basic/</id>
    <published>2015-12-16T05:33:50.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>栗子<a href="https://github.com/kiya-z/Android/blob/master/lab-mouse/shell-protect-1.apk" target="_blank" rel="external">在此</a></p>
<a id="more"></a>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><a href="http://kiya.space/2015/12/11/ida-dynamic-debug-dex/" target="_blank" rel="external">附加进程</a>后,在<code>libdvm.so</code>中的<code>dvmDexFileOpenPartial</code>函数下断点.</p>
<p>dvmDexFileOpenPartial的函数原型为(位于/dalvik/vm/DvmDex.cpp):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * @addr: 传入参数, dex文件的起始地址</div><div class="line"> * @len: 传出参数, dex文件的大小</div><div class="line"> * @ppDvmDex: 传出参数,指向 DvmDex 结构的地址</div><div class="line">*/</div><div class="line">int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)</div></pre></td></tr></table></figure></p>
<p>运行后断下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/16/13/39/27" alt=""></p>
<p>得R0为addr,R1为len.</p>
<p>执行脚本:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/16/13/39/41" alt=""></p>
<p>现在就可以使用baksmali处理dex文件继续分析了.</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>dalvik虚拟机会把dex文件优化为odex文件,而优化的源代码为<code>/dalvik/dexopt/OptMain.cpp</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Main entry point.  Decide where to go.</div><div class="line"> */</div><div class="line">int main(int argc, char* const argv[])</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    if (argc &gt; 1) &#123;</div><div class="line">        if (strcmp(argv[1], &quot;--zip&quot;) == 0)</div><div class="line">            return fromZip(argc, argv);</div><div class="line">        else if (strcmp(argv[1], &quot;--dex&quot;) == 0)</div><div class="line">            return fromDex(argc, argv);</div><div class="line">        else if (strcmp(argv[1], &quot;--preopt&quot;) == 0)</div><div class="line">            return preopt(argc, argv);</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>fromzip</code>和<code>preopt</code>都会调用<code>processZipFile</code>先将dex文件提取出来,<code>fromDex</code>则直接调用<code>dvmContinueOptimization</code>优化.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Common functionality for normal device-side processing as well as</div><div class="line"> * preoptimization.</div><div class="line"> */</div><div class="line">static int processZipFile(int zipFd, int cacheFd, const char* zipName,</div><div class="line">        const char *dexoptFlags)</div><div class="line">&#123;</div><div class="line">   	...</div><div class="line">    int result = extractAndProcessZip(zipFd, cacheFd, zipName, isBootstrap,</div><div class="line">            bcp, dexoptFlags);</div><div class="line">    free(bcpCopy);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>extractAndProcessZip</code>中处理zip文件并将dex提取出来,随后调用优化函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Extract &quot;classes.dex&quot; from zipFd into &quot;cacheFd&quot;, leaving a little space</div><div class="line"> * up front for the DEX optimization header.</div><div class="line"> */</div><div class="line">static int extractAndProcessZip(int zipFd, int cacheFd,</div><div class="line">    const char* debugFileName, bool isBootstrap, const char* bootClassPath,</div><div class="line">    const char* dexoptFlagStr)</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    /*</div><div class="line">     * Open the zip archive, find the DEX entry.</div><div class="line">     */</div><div class="line">    if (dexZipPrepArchive(zipFd, debugFileName, &amp;zippy) != 0) &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: unable to open zip archive &apos;%s&apos;&quot;, debugFileName);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    zipEntry = dexZipFindEntry(&amp;zippy, kClassesDex);</div><div class="line">    if (zipEntry == NULL) &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: zip archive &apos;%s&apos; does not include %s&quot;,</div><div class="line">            debugFileName, kClassesDex);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * Extract some info about the zip entry.</div><div class="line">     */</div><div class="line">    if (dexZipGetEntryInfo(&amp;zippy, zipEntry, NULL, &amp;uncompLen, NULL, NULL,</div><div class="line">            &amp;modWhen, &amp;crc32) != 0)</div><div class="line">    &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: zip archive GetEntryInfo failed on %s&quot;, debugFileName);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    uncompLen = uncompLen;</div><div class="line">    modWhen = modWhen;</div><div class="line">    crc32 = crc32;</div><div class="line">    /*</div><div class="line">     * Extract the DEX data into the cache file at the current offset.</div><div class="line">     */</div><div class="line">    if (dexZipExtractEntryToFile(&amp;zippy, zipEntry, cacheFd) != 0) &#123;</div><div class="line">        ALOGW(&quot;DexOptZ: extraction of %s from %s failed&quot;,</div><div class="line">            kClassesDex, debugFileName);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">   	...</div><div class="line">    /*</div><div class="line">     * Prep the VM and perform the optimization.</div><div class="line">     */</div><div class="line">    if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode,</div><div class="line">            dexoptFlags) != 0)</div><div class="line">    &#123;</div><div class="line">        ALOGE(&quot;DexOptZ: VM init failed&quot;);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">    //vmStarted = 1;</div><div class="line">    /* do the optimization */</div><div class="line">    if (!dvmContinueOptimization(cacheFd, dexOffset, uncompLen, debugFileName,</div><div class="line">            modWhen, crc32, isBootstrap))</div><div class="line">    &#123;</div><div class="line">        ALOGE(&quot;Optimization failed&quot;);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dvmContinueOptimization</code>函数位于/dalvik/vm/analysis/DexPrepare.cpp文件,其中调用了<code>dvmDexFileOpenPartial</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Do the actual optimization.  This is executed in the dexopt process.</div><div class="line"> *</div><div class="line"> * For best use of disk/memory, we want to extract once and perform</div><div class="line"> * optimizations in place.  If the file has to expand or contract</div><div class="line"> * to match local structure padding/alignment expectations, we want</div><div class="line"> * to do the rewrite as part of the extract, rather than extracting</div><div class="line"> * into a temp file and slurping it back out.  (The structure alignment</div><div class="line"> * is currently correct for all platforms, and this isn&apos;t expected to</div><div class="line"> * change, so we should be okay with having it already extracted.)</div><div class="line"> *</div><div class="line"> * Returns &quot;true&quot; on success.</div><div class="line"> */</div><div class="line">bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,</div><div class="line">    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)</div><div class="line">&#123;</div><div class="line">   ...</div><div class="line">		success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,</div><div class="line">                    doVerify, doOpt, &amp;pClassLookup, NULL);</div><div class="line">        if (success) &#123;</div><div class="line">            DvmDex* pDvmDex = NULL;</div><div class="line">            u1* dexAddr = ((u1*) mapAddr) + dexOffset;</div><div class="line">            if (dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex) != 0) &#123;</div><div class="line">                ALOGE(&quot;Unable to create DexFile&quot;);</div><div class="line">                success = false;</div><div class="line">            &#125; else &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dvmDexFileOpenPartial</code>调用了<code>dexFileParse</code>,用来解析内存中优化过或未优化过的dex文件,返回dexFile结构.<br>所以此时dex文件已经被加载进内存,就可以dump出来了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Create a DexFile structure for a &quot;partial&quot; DEX.  This is one that is in</div><div class="line"> * the process of being optimized.  The optimization header isn&apos;t finished</div><div class="line"> * and we won&apos;t have any of the auxillary data tables, so we have to do</div><div class="line"> * the initialization slightly differently.</div><div class="line"> *</div><div class="line"> * Returns nonzero on error.</div><div class="line"> */</div><div class="line">int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)</div><div class="line">&#123;</div><div class="line">    DvmDex* pDvmDex;</div><div class="line">    DexFile* pDexFile;</div><div class="line">    int parseFlags = kDexParseDefault;</div><div class="line">    int result = -1;</div><div class="line">    /* -- file is incomplete, new checksum has not yet been calculated</div><div class="line">    if (gDvm.verifyDexChecksum)</div><div class="line">        parseFlags |= kDexParseVerifyChecksum;</div><div class="line">    */</div><div class="line">    pDexFile = dexFileParse((u1*)addr, len, parseFlags);</div><div class="line">    if (pDexFile == NULL) &#123;</div><div class="line">        ALOGE(&quot;DEX parse failed&quot;);</div><div class="line">        goto bail;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栗子&lt;a href=&quot;https://github.com/kiya-z/Android/blob/master/lab-mouse/shell-protect-1.apk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="MSC" scheme="http://kiya.studio/tags/MSC/"/>
    
      <category term="enforce" scheme="http://kiya.studio/tags/enforce/"/>
    
  </entry>
  
  <entry>
    <title>反调试方法一 - 读取进程status文件</title>
    <link href="http://kiya.studio/2015/12/14/android-anti-debug-read-status/"/>
    <id>http://kiya.studio/2015/12/14/android-anti-debug-read-status/</id>
    <published>2015-12-14T13:33:56.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>栗子:<a href="https://github.com/kiya-z/Android/blob/master/lab-mouse/AliCrackme_2.apk" target="_blank" rel="external">阿里移动安全挑战赛第二题</a></p>
<a id="more"></a>
<blockquote>
<p>本栗反调试方法:<br>用fopen打开<code>/proc/&lt;pid&gt;/status</code>文件读取其中的<code>TracerPid</code>值来检测自己的进程是否被attach，<br>TracerPid如果为0说明没有别的进程在调试这个进程，如果不为0说明有程序在调试。</p>
</blockquote>
<p>使用ida附加进程,关键函数下断点F9之后,进程退出,ida退出.<br>调试过后发现JNI_OnLoad中有反调试方法(实际上是前辈的结论 :p).</p>
<p>根据<a href="http://kiya.space/2015/12/11/ida-dynamic-debug-so/" target="_blank" rel="external">使用ida调试so文件</a>的步骤在<code>library load</code>处断下.</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>打开Debugger windows -&gt; Module list,找到<code>/data/app-lib/com.yaotong.crackme-1/libcrackme.so</code>,为其中的JNI_OnLoad方法右键<code>Add breakpoint</code>.这里我们也可以得到libcrackme.so的基址为0x520AE000.<br>(当然如果反调试方法是在.initarray中,其地址需要手动计算.)</p>
<p>一步一步F8发现在执行这一句之后程序退出.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/14/22" alt=""></p>
<p>F7进去,发现是<code>pthread_create</code>函数.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/14/57" alt=""></p>
<p>所以上上图中的<code>unk_520AF6A4</code>函数就是线程回调函数咯.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/15/23" alt=""></p>
<p>先不去分析(其实是水平达不到 :( ),所以我们要用守株待兔的方法.<br>在module list中找到<code>libc.so</code>,在fopen函数下断点,以此检验程序是否打开了某些文件检测状态值.<br>同时打开一个hex view(View -&gt; Open subviews -&gt; Hex dump),设置数据与R0同步.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/15/46" alt=""></p>
<p>F9运行到fopen函数处(有时并不能一次就断在fopen,注意看注释).</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/06" alt=""></p>
<p>所以程序确实是读取了status文件. :P<br>这是需要找到是谁调用了fopen函数,然后修改读取status的返回值为0(不然就露馅了).<br>一直摁F8直到fopen函数返回,于是我们来到了这里.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/21" alt=""></p>
<p>一边是数据一边是代码,完全找不到函数开始的地方哇.<br>但是我们知道此处地址为<code>520AF420</code>,减去我们之前记下的libcrackme.so的基址520AE000,得到相对地址为<code>1420</code><br>另开一个ida,摁G键跳至此地址,F5发现是函数<code>sub_130c</code>.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/38" alt=""></p>
<p>将<code>sub_130c</code>的文件偏移转换为绝对地址:130c+520AE000=520AF30C.<br>p键将此处数据视为代码变成这样:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/21/02" alt=""></p>
<p>程序随后会用fgets()和strstr()来获取TracerId的值，于是我们在strstr()处下个断点，然后让hex view的数据与R0同步.<br>一直F9,直到R0的值变为这样:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/21/31" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/21/48" alt=""></p>
<p>F2修改为这样:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/22/34" alt=""></p>
<p>但是过一会程序又要获取,我们得一直不停的改,所以我们需要将这段代码nop掉,世界才安静.</p>
<h1 id="patch-so"><a href="#patch-so" class="headerlink" title="patch so"></a>patch so</h1><p>如果静态分析时找到JNI_OnLoad中关键的那句代码:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/16/59" alt=""></p>
<p>进入线程的回调函数,发现竟然是这样子的!</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/17/15" alt=""></p>
<p>回调函数<code>sub_16a4</code>中调用了<code>sub_130c</code>!<br>跟我们在动态调试时看到的完全不一样嘛.<br>现在将回调函数中的这一句nop掉就好了呗.<br>右键选择<code>copy to assembly</code></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/17/31" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/17/48" alt=""></p>
<p>我们的目标是<code>BL sub_130C</code>. arm中没有nop语句,所以将<code>movs r0,r0</code>作为NOP,对应的机器码为<code>00 00 A0 E1</code>.</p>
<p>右键进入hex view.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/18/02" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/18/17" alt=""></p>
<p>摁F2将<code>13 FF FF EB</code>改为<code>00 00 A0 E1</code>,再摁F2应用.<br>点击<code>Edit -&gt; Patch program -&gt; Apply patches to input file...</code>保存即可.</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/18/34" alt=""></p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/14/21/20/31" alt=""></p>
<p>将原apk中的so文件替换为此so文件,重新打包签名安装,现在直接打开app调试就不会退出了. Success!</p>
<hr>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>ida中按三下D，将数据格式从字符转化为指针形式.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://drops.wooyun.org/tips/6840" target="_blank" rel="external">安卓动态调试七种武器之孔雀翎 – Ida Pro</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栗子:&lt;a href=&quot;https://github.com/kiya-z/Android/blob/master/lab-mouse/AliCrackme_2.apk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里移动安全挑战赛第二题&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android Security" scheme="http://kiya.studio/categories/Android-Security/"/>
    
    
      <category term="anti-debug" scheme="http://kiya.studio/tags/anti-debug/"/>
    
      <category term="MSC" scheme="http://kiya.studio/tags/MSC/"/>
    
  </entry>
  
  <entry>
    <title>使用ida调试so文件</title>
    <link href="http://kiya.studio/2015/12/11/ida-dynamic-debug-so/"/>
    <id>http://kiya.studio/2015/12/11/ida-dynamic-debug-so/</id>
    <published>2015-12-11T05:16:52.000Z</published>
    <updated>2017-06-21T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>保护代码通常放在so文件中.</p>
<a id="more"></a>
<h1 id="正常的应用"><a href="#正常的应用" class="headerlink" title="正常的应用"></a>正常的应用</h1><h2 id="android机的准备工作"><a href="#android机的准备工作" class="headerlink" title="android机的准备工作"></a>android机的准备工作</h2><p>找到<code>ida</code>目录下的<code>/dbgsrv/android_server</code>文件,push进android机,启动<code>android_server</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">adb push android_server /data/local/tmp/</div><div class="line">adb shell</div><div class="line">su</div><div class="line">cd data/local/tmp</div><div class="line">chmod 755 android_server</div><div class="line">./android_server</div></pre></td></tr></table></figure>
<p>出现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@android:/data/local/tmp # ./android_server</div><div class="line">IDA Android 32-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015</div><div class="line">Listening on port #23946...</div></pre></td></tr></table></figure>
<p>另开命令行进行tcp端口转发：<br><code>adb forward tcp:23946 tcp:23946</code></p>
<p>[<strong>注意事项</strong>]</p>
<ol>
<li>此android_server需和ida是配套的</li>
<li>出现<code>bind: Address already in use</code>错误<br>这是因为手机中可能已经在运行android_server,使用<code>ps | grep android_server</code>看一下,有的话杀掉.<br>如下:(14061是pid)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@android:/ # ps | grep android_server</div><div class="line">root      14061 13574 11180  9504  ffffffff 40183da0 S /data/local/tmp/android_server</div><div class="line">127|root@android:/ # kill -s 9 14061</div></pre></td></tr></table></figure>
<h2 id="ida-的准备"><a href="#ida-的准备" class="headerlink" title="ida 的准备"></a>ida 的准备</h2><p>打开ida，打开so文件,记录so文件中感兴趣的函数的文件偏移.</p>
<p>手机打开app.</p>
<p>另开一个ida,菜单栏设置<code>Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger</code>如下:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/46/45" alt=""></p>
<p>点击ok,弹出进程列表,例如:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/11/13/49/17" alt=""></p>
<blockquote>
<p><strong>注意</strong><br>如果此时进程列表中只有一两个进程,可能是因为上一步启动<code>android_server</code>时你使用了这样的命令:<br><code>adb shell /data/local/tmp/android_server</code><br>只要先进入<code>adb shell</code>再执行就没问题了.</p>
</blockquote>
<p>选择要调试的进程,等待分析完毕.</p>
<p><code>ctrl+s</code>打开segment列表,找到要调试的so文件,选择class属性为CODE的那个就ok了.记得记下so的基址(start属性).<br>基址加上刚刚记录的函数的文件偏移即得函数的地址,按快捷键G输入地址跳转,下断点运行即可.</p>
<h1 id="不正常的应用"><a href="#不正常的应用" class="headerlink" title="不正常的应用"></a>不正常的应用</h1><p>(此步骤也适用于给系统函数下断点)<br>so文件在被加载的时候会首先执行.init_array中的函数，然后再执行JNI_OnLoad()函数。如果在这中间加了反调试代码,那么我们一旦开始调试app可能就会退出.所以我们需要在so文件被加载之前就断下来.</p>
<h2 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h2><p>使用am start命令启动app:<br><code>adb shell am start -D -n com.yaotong.crackme/com.yaotong.crackme.MainActivity</code><br><strong>com.yaotong.crackme</strong> 为包名,<strong>com.yaotong.crackme.MainActivity</strong> 为主activity名.</p>
<p>此时手机上会弹出:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/12/13/35/08" alt=""></p>
<h2 id="ida准备"><a href="#ida准备" class="headerlink" title="ida准备"></a>ida准备</h2><p>同样是设置<code>Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger</code>再选择进程.<br>之后需要设置调试器调试选项为:</p>
<p><img src="http://7xo976.com1.z0.glb.clouddn.com/from_clipboard/2015/12/12/13/35/31" alt=""></p>
<p>F9运行.<br>在控制台使用jdb恢复进程运行:<br><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></p>
<p>正常情况会出现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">设置未捕获的java.lang.Throwable</div><div class="line">设置延迟的未捕获的java.lang.Throwable</div><div class="line">正在初始化jdb...</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">java.net.ConnectException: Connection refused: connect</div><div class="line">        at java.net.DualStackPlainSocketImpl.connect0(Native Method)</div><div class="line">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:79)</div><div class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:345)</div><div class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</div><div class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</div><div class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)</div><div class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</div><div class="line">        at java.net.Socket.connect(Socket.java:589)</div><div class="line">        at com.sun.tools.jdi.SocketTransportService.attach(SocketTransportService.java:222)</div><div class="line">        at com.sun.tools.jdi.GenericAttachingConnector.attach(GenericAttachingConnector.java:116)</div><div class="line">        at com.sun.tools.jdi.SocketAttachingConnector.attach(SocketAttachingConnector.java:90)</div><div class="line">        at com.sun.tools.example.debug.tty.VMConnection.attachTarget(VMConnection.java:519)</div><div class="line">        at com.sun.tools.example.debug.tty.VMConnection.open(VMConnection.java:328)</div><div class="line">        at com.sun.tools.example.debug.tty.Env.init(Env.java:63)</div><div class="line">        at com.sun.tools.example.debug.tty.TTY.main(TTY.java:1066)</div><div class="line">致命错误:</div><div class="line">无法附加到目标 VM。</div></pre></td></tr></table></figure>
<ul>
<li>打开ddms尝试.</li>
<li>检查调试的app配置文件中是否有<code>android:debuggable=&quot;true&quot;</code>，导致不能调试。<br>若无则在清单文件的application中加上,重新打包即可.</li>
</ul>
<p>接下来就可以在.initarray和JNI_OnLoad下断点了.</p>
<hr>
<blockquote>
<p>番外</p>
</blockquote>
<h1 id="initarray"><a href="#initarray" class="headerlink" title=".initarray"></a>.initarray</h1><p>静态分析so文件时,按<code>ctrl+s</code>出现segment列表,进入<code>.initarray</code>即可看到列表.</p>
<h1 id="如何dump-so文件"><a href="#如何dump-so文件" class="headerlink" title="如何dump so文件"></a>如何dump so文件</h1><p>dump时务必确保so文件已经加载.<br>python脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import idaapi</div><div class="line">data = idaapi.dbg_read_memory(start_addr,file_len)</div><div class="line">f = open(r&apos;C:\Users\...\Desktop\dump.so&apos;,&apos;wb&apos;)</div><div class="line">f.write(data)</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>ida的api函数地址:<a href="https://www.hex-rays.com/products/ida/support/idapython_docs/idaapi-module.html" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/idapython_docs/idaapi-module.html</a></p>
<p>以上.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;保护代码通常放在so文件中.&lt;/p&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://kiya.studio/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="MSC" scheme="http://kiya.studio/tags/MSC/"/>
    
      <category term="debug" scheme="http://kiya.studio/tags/debug/"/>
    
      <category term="ida" scheme="http://kiya.studio/tags/ida/"/>
    
  </entry>
  
</feed>
